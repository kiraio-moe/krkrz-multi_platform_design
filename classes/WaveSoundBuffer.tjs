/**
 * @description The WaveSoundBuffer class is a class that manages PCM playback.
 * The WaveSoundBuffer class can read and process .sli files created with the Loop Tuner.
 * See the loop tuner description for details.
 */
class WaveSoundBuffer {
	/**
	 * Building a WaveSoundBuffer object
	 *
	 * @param owner Specify where the event will occur.
	 * @description Build an object of the WaveSoundBuffer class.
	 * When the event occurs, it calls the action method of the object specified by owner.
	 * If you specify null for owner, the action method will not be called.
	 * Normally, you specify an object of the Window class as owner.
	 */
	function WaveSoundBuffer( owner);

	/**
	 * Status changed
	 *
	 * @param status New status. See the WaveSoundBuffer.status property.
	 * @description Occurs when the playback status changes.
	 */
	event onStatusChanged( status);

	/**
	 * Passed the label
	 *
	 * @param name The name of the label passed.
	 * @description Occurs when the playback position passes the label.
	 */
	event onLabel( name);

	/**
	 * The fade is over
	 *
	 * @description Occurs when the fade started by the WaveSoundBuffer.fade method ends.
	 */
	event onFadeCompleted( );

	/**
	 * Open media
	 *
	 * @param storage Specify the storage you want to play.
	 * @description Opens the specified media.
	 * This method does not start playback.
	 * If there is a file name with .sli added to the specified storage name, it will be read as sound loop information.
	 */
	function open( storage);

	/**
	 * Play media
	 *
	 * @description Start playing the media.
	 */
	function play( );

	/**
	 * Stop media
	 *
	 * @description Stop the media.
	 */
	function stop( );

	/**
	 * Start fading
	 *
	 * @param to Specifies the volume to reach.
	 * See the WaveSoundBuffer.volume property for volume specifications.
	 * @param time Specifies the time to fade in ms.
	 * @param delay Specifies the wait time in ms to start the fade.
	 * @description Starts a fade (continuous change in volume).
	 */
	function fade( to, time, delay=0);

	/**
	 * Stop fading
	 *
	 * @description Forcibly stops the fade started by the WaveSoundBuffer.fade method.
	 * The volume remains as it was when it was stopped.
	 */
	function stopFade( );

	/**
	 * Release DirectSound
	 *
	 * @description Release DirectSound.
	 * All WaveSoundBuffer class objects are in a stopped state.
	 * Use this method to release DirectSound in an environment where DirectSound and WaveMapper (MCI, etc.) cannot be played at the same time.
	 * This method only exists on the WaveSoundBuffer class (it doesn't exist on objects created from WaveSoundBuffer).
	 * Use WaveSoundBuffer.freeDirectSound (); to use it.
	 */
	function freeDirectSound( );

	/**
	 * Acquisition of data for visualization
	 *
	 * @param buffer Specifies the buffer to write the output data to.
	 * The buffer is an array of 16-bit signed integers and must be large enough (numsamples * channels and above) to write the samples specified by the numsamples and channels arguments.
	 * If you specify a channel other than 1, the samples for each channel are interleaved (in stereo, right, left, right, left, and so on) and stored.
	 * You need to specify a pointer to the first element of the array, but cast it to an integer type and pass it.
	 * @param numsamples Specify the number of samples to acquire.
	 * @param channel Specify the number of channels to acquire.
	 * If you specify 1, you can get the data downmixed to 1 channel if it is monaural or not.
	 * If you specify a number other than 1, you must specify the same number of channels as the sound being played.
	 * In this case, you can get the data as it is.
	 * @param ahead Specify the number of samples to read ahead.
	 * You can get from the sample that is ahead by the number of samples specified by this argument from the current playback position.
	 * If you specify 0 or omit this argument, the acquisition is from the current playback position.
	 * @return The number of samples that can be obtained is returned.
	 * @description Acquires PCM data for visualization.
	 * Reads PCM data from the current playback position and writes it to the array specified by the buffer argument.
	 * However, depending on the buffer status and playback format, it may not be possible to read the data normally.
	 * Since this method is supposed to be used by plugins written in C or C ++, it is not possible to specify an array of TJS in the buffer argument, for example.
	 * The WaveSoundBuffer.useVisBuffer property must be truly specified to use this method.
	 */
	function getVisBuffer( buffer, numsamples, channel, ahead=0);

	/**
	 * Playback position
	 *
	 * @description Represents the playback position in ms.
	 * If you set a value, it will move to that position.
	 */
	 property position {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Playback position
	 *
	 * @description The playback position is expressed in units of the number of samples.
	 * If you set a value, it will move to that position.
	 */
	 property samplePosition {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether it is in a paused state
	 *
	 * @description Indicates whether it is in a paused state.
	 * You can also set the value. If true, it is in a paused state.
	 */
	 property paused {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Media play time
	 *
	 * @description Represents the total play time of the media in ms.
	 */
	 property totalTime {
		 getter() { return value; }
	}
	/**
	 * Whether to perform loop playback
	 *
	 * @description Indicates whether to perform loop playback.
	 * You can also set the value.
	 * If true is specified, loop playback will be performed.
	 * Even if you specify false, if the media being played has loop information, the loop information will be used.
	 */
	 property looping {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Volume
	 *
	 * @description Represents the volume to play.
	 * You can also set the value.
	 * Specify a number from 0 to 100000, 0 for full mute and 100000 for 100% volume.
	 */
	 property volume {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 2nd volume
	 *
	 * @description Represents the volume to play. You can set the value.
	 * Unlike the WaveSoundBuffer.volume property, this property does not change with the WaveSoundBuffer.fade method.
	 * The final volume is determined by the product of the volume property and this property.
	 * If the volume property is 100000 (100%) and the volume2 property is also 100000 (100%), then 100% x 100% = 100% will play at 100% volume.
	 * If the volume property is 50000 (50%) and the volume2 property is 75000 (75%), then 50% x 75% = 37.5% will play at 37.5% volume.
	 */
	 property volume2 {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * status
	 *
	 * @description Represents the current state.
	 * The state is represented by a character string and has the following values.
	 *
	 * + "unload"   :   Media is not open
	 * + "play"     :   Media is playing
	 * + "stop"     :   Media is down
	 *
	 */
	 property status {
		 getter() { return value; }
	}
	/**
	 * Whether to use a visualization buffer
	 *
	 * @description Indicates whether to use a visualization buffer.
	 * You can also set the value.
	 * If true, the visualization buffer is available and the WaveSoundBuffer.getVisBuffer method is available.
	 * The default is false.
	 * Note that specifying true consumes more memory and CPU time than specifying false.
	 */
	 property useVisBuffer {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Number of channels
	 *
	 * @description Represents the number of channels of the sound currently playing.
	 * 1 for monaural and 2 for stereo.
	 * It may not return normal values when the media is not open.
	 */
	 property channels {
		 getter() { return value; }
	}
	/**
	 * Sampling frequency
	 *
	 * @description Represents the sampling frequency of the sound currently being played.
	 * You can also set the value.
	 * If the sampling frequency is the same as that of a CD, it will be 44100.
	 * It may not return normal values when the media is not open.
	 * If you set a value, it will play at that frequency.
	 */
	 property frequency {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Number of quantization bits
	 *
	 * @description Represents the number of quantization bits of the sound currently being played.
	 * 16 for the same number of quantization bits as a CD.
	 * It may not return normal values when the media is not open.
	 */
	 property bits {
		 getter() { return value; }
	}
	/**
	 * flag
	 *
	 * @description You can get an object that represents the flag.
	 * This object has 0 to 15 properties, each representing the value of each flag.
	 * Properties can be accessed using the indirect member selection operator ('[]' operator).
	 * You can also set values for these properties.
	 * Values range from 0 to 9999 and cannot be below or above this.
	 * The count property of this object always returns 16.
	 * This object has a reset method, which resets all flags to 0.
	 * If you have not opened the media, setting a value for this object's properties will be ignored.
	 * This object looks like an array object at first glance, but it is not a so-called TJS array object (an object of the'Array' class).
	 * All flags are reset to 0 with the WaveSoundBuffer.open method.
	 * Example:
	 *
	 * ```
	 * var buf = new WaveSoundBuffer (window);
	 * (Omitted)
	 * buf.flags.reset ();
	 * // Reset all flags to 0
	 * var cnt = buf.flags.count;
	 * // cnt contains 16
	 * buf.flags [4] = 34;
	 * // Substitute 34 for flag 4
	 *```
	 *
	 */
	 property flags {
		 getter() { return value; }
	}
	/**
	 * label
	 *
	 * @description You can get an object that represents the label.
	 * This object is a dictionary array, each containing an element whose member name is the label name in the loop information.
	 * Each element is also a dictionary array, the name member represents the name of the label, the position member represents the position of the label in milliseconds, and the samplePosition represents the position of the label in units of samples.
	 * Think of this dictionary array as read-only.
	 * Assigning a value or creating a new member will not take effect.
	 * Example:
	 *
	 * ```
	 * var buf = new WaveSoundBuffer (window);
	 * (Omitted)
	 * debug.message (buf.labels ['start']. position);
	 * // Position the label name'start'in milliseconds
	 * debug.message (buf.labels ['start']. samplePosition);
	 * // Position the label name'start'in units of sample size
	 * ```
	 *
	 */
	 property labels {
		 getter() { return value; }
	}
	/**
	 * Bread
	 *
	 * @description Represents pan (sound image position).
	 * You can also set the value.
	 * You can specify the left and right positions where you can hear the sound.
	 * Specify a number from -100000 to 0 to 100000, where -100000 is completely left, 0 is center, and 100000 is completely right.
	 */
	 property pan {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Global volume
	 *
	 * @description Represents the global volume (master volume).
	 * You can also set the value.
	 * This volume affects all WaveSoundBuffers.
	 * Specify a number from 0 to 100000, 0 for full mute and 100000 for 100% volume.
	 * The default value is 100000.
	 * This property only exists on the WaveSoundBuffer class (it doesn't exist on objects created from WaveSoundBuffer).
	 * Use WaveSoundBuffer.globalVolume when using it.
	 */
	 property globalVolume {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Focus mode
	 *
	 * @description Represents the focus mode.
	 * You can also set the value.
	 * Focus mode is a mode that mutes when the application is minimized or inactive.
	 *
	 * + If you specify sgfmNeverMute, the application will not mute under any conditions.
	 * + If you specify sgfmMuteOnMinimize, the application mutes when minimized.
	 * + Specify sgfmMuteOnDeactivate to mute when the application is deactivated.
	 *
	 * This property only exists on the WaveSoundBuffer class (it doesn't exist on objects created from WaveSoundBuffer).
	 * When using it, set it to WaveSoundBuffer.globalFocusMode.
	 * The'-wsmute' (DirectSound mute) setting specified in the command line option takes precedence over the setting of this property.
	 * On Android, it is muted when it becomes inactive.
	 * In the background, the processing speed will slow down and you will not be able to play normally.
	 */
	 property globalFocusMode {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Filter array
	 *
	 * @description An array (an instance of the Array class) that holds the insertion filter object.
	 * By registering a filter object in this array, you can apply various effects to the audio in real time during playback.
	 * Changes to the filter array will only take effect when the WaveSoundBuffer.open method is executed.
	 * Until then, any changes to this array will not take effect.
	 * Example:
	 * ```
	 * var buf = new WaveSoundBuffer (window);
	 * (Omitted)
	 * buf.filters.clear ();
	 * // Clear the filter array
	 * buf.filters.add (new WaveSoundBuffer.PhaseVocoder ());
	 * // Add Phase Vocoder filter
	 * buf.filters [0] .time = 0.5;
	 * // Double speed playback
	 * ```
	 */
	 property filters {
		 getter() { return value; }
	}
};
