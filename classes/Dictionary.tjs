/*
 * @description Dictionary クラスは辞書配列を扱うクラスです。
 *
 * 辞書配列は連想配列とも呼ばれ、名前と、それに結びつけられた値を一つのペアとして、それを複数保持するオブジェクトです。
 * 配列と同じように [ ] (間接参照) 演算子でアクセスしますが、添え字の代わりに文字列を使い、それが名前となります。
 * 名前が識別子として有効なものであれば、 . (直接参照) 演算子も使うことができます。
 * また、存在しない名前を参照すると void になります。
 * 要素を削除するには delete 演算子を使います。
 *
 * # 式中辞書配列
 * %[ ] を使って、式中に Dictionary クラスのオブジェクトをその場で記述することができます。
 * 要素名 => 要素の値、をカンマで区切り、初期要素となる式を列挙します。たとえば、
 *
 * ```
 * var dic = %["a" => 1, "b" => 2, "c" => 3];
 * ```
 *
 *と記述すれば、dic に、要素名と要素の組がそれぞれ "a":1、 "b":2、 "c":3 となる Dictionary クラスのオブジェクトへの参照が代入されます。
 * 内部的には、=> はカンマと全く同じものですが、読みやすさを考え、=> を使用できるようになっています ( perl と同じです )。
 *
 * # Dictionary クラスのメソッドへのアクセス
 *
 * Dictionary クラスのオブジェクトは、作成された状態ではメンバを何一つ持っていません。
 * たとえば、assign メソッドを使おうと思って、Dictionary クラスのオブジェクト dict に対してdict.assign(src) のように記述しても、dict が assign というメソッドを持っていないためにエラーになります。
 * したがって、incontextof 演算子を使って、Dictionary クラスに直接属しているメソッドを、対象となる Dictionary クラスのオブジェクトをコンテキストとして実行させます。
 *
 * 例:
 * ```
 * var a = %[];
 * var b = %[];
 * (Dictionary.assign incontextof a)(b); // b を a にコピー
 * (Dictionary.clear incontextof b)(); // b の内容をクリア
 * ```
 *
 */
class Dictionary {
	/**
	 * ファイルへ構造化されたデータの出力を行います
	 * @description 要素の状態を復元可能な状態でファイルに出力します。
	 * 各要素には文字列、実数、オクテット列、整数を含めることができます。
	 * また、要素にオブジェクトがあった場合は、それが Array クラスあるいは Dictionary クラスのオブジェクトである場合に限り、そのオブジェクトの中身もファイルに出力します。
	 * それ以外の要素は void が出力されます。
	 * @param storage 書き出すファイル名
	 * @param mode ファイルを書き込む際のモード文字列を指定します。
	 *
	 * + "c" を指定するとファイルに簡単な暗号化がかかります ( そのまま load メソッドで読み込むことができます ) 。
	 * + "z" を指定するとファイルを圧縮して保存できます ("c" と併用は出来ません; これもそのまま load メソッドで読み込むことができます)。
	 * + "o" に続いてオフセットを10進で指定するとファイルのそのバイト位置からの書き込みになります。
	 * + "b"を指定するとバイナリ形式で保存されます(他のモード指定と併用は出来ません; これもそのまま load メソッドで読み込むことができます)。
	 *
	 * @return 出力した Dictionary クラスのオブジェクトを返します。
	 * @see Array.saveStruct
	 */
	function saveStruct( storage:string, mode:string=null ):Dictionary;

	/**
	 * ファイルから構造化されたデータの入力を行います
	 * @description 構造化されたデータをファイルから辞書配列、もしくは配列として読み込みます。
	 * テキスト形式、バイナリ形式の両方で読み込めます。
	 * クラスメソッドです。
	 * @param storage 読み込むファイル名
	 * @param mode ファイルを読み込む際のモード文字列を指定します。
	 *
	 * + "o" に続いてオフセットを10進で指定するとファイルのそのバイト位置からの書き込みになります。
	 *
	 * @return 読み込んだ Dictionary か Array クラスのオブジェクトを返します。
	 * @see Array.loadStruct
	 */
	function loadStruct( storage:string, mode:string=null ):Dictionary;

	/**
	 * 辞書配列をコピーします
	 * @param src コピー元辞書配列
	 * @param clear 内容をクリアするか
	 * @description 引数で指定された他の辞書配列の内容を、そっくりコピーします。
	 * clar が偽の場合は、コピー先 (メソッドを実行するオブジェクト) の内容をクリアせず、コピー元辞書配列の内容を上書きします。
	 * コピー元辞書配列と同じ名前のメンバがコピー先辞書配列にあった場合は、コピー元の内容でコピー先が上書きされます。
	 * 配列 (Arrayクラスのオブジェクト) をコピー元配列に指定した場合は、その配列には、この辞書配列のメンバとなるべき要素が名前、値の順に並んでいるとみなし、その配列の内容をこの辞書配列にコピーします。
	 */
	function assign( src:Dictionary, clear:bool=true );

	/**
	 * 辞書配列をコピーします
	 * @param src コピー元辞書配列
	 * @description 引数で指定された他の辞書配列の内容を、そっくりコピーします。
	 * assign メソッドと違い、メンバに配列あるいは辞書配列があった場合は、再帰的にその内容もコピーします ( assign メソッドの場合は参照がコピーされるだけです )。
	 */
	function assignStruct( src:Dictionary );

	/**
	 * 辞書配列の内容をすべて消去します
	 * @description 辞書配列の内容をすべて消去します。
	 */
	function clear();

	/**
	 * オブジェクトのメンバの数を返します。
	 * @description オブジェクトのメンバの数を返します。対象は辞書配列以外でも機能します。
	 * @param target メンバ数をカウントするオブジェクト
	 * @return メンバの数
	 */
	function getCount( target:Dictionary ):int;

	/**
	 * オブジェクトのキーの配列を返します。
	 * @description オブジェクトのキーの配列を返します。対象は辞書配列以外でも機能します。
	 * 返された配列の順序はArray.assginと同じでソートはされていません。
	 * @param target メンバ数をカウントするオブジェクト
	 * @return キーの配列
	 */
	function keys( target:Dictionary ):Array;

	/**
	 * オブジェクトの値の配列を返します。
	 * @description オブジェクトの値の配列を返します。対象は辞書配列以外でも機能します。
	 * @param target メンバ数をカウントするオブジェクト
	 * @return 値の配列
	 */
	function values( target:Dictionary ):Array;

	/**
	 * 辞書配列に指定された key が存在するか判定します。
	 * @description 辞書に指定されたkey存在する場合はtrue、しない場合はfalseを返します。
	 * コンテキストがある場合は target を省略できます。
	 * in 演算子でも判定可能です。
	 * @param target 存在を確認する辞書配列
	 * @param key 存在を確認するキー
	 * @return キーの有無
	 */
	function contains( target:Dictionary, key:string ):bool;
};
