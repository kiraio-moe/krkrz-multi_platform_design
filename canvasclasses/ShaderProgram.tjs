/**
 * Vertex/Fragmentシェーダーをコンパイル/リンクしたものを格納するクラス
 * コンストラクタでコンパイル/リンクは実行され、エラーがあると例外が出るのでログを見て修正する。
 * シェーダーの入力に使われるパラメータは、メンバに追加されるので、メンバ経由で値の設定が可能(Uniformのみ)。
 * シェーダーからの変数名取得は、リフレクションを使用し取得する。
 * Textureなどの指定は決められた予約語としてあらかじめ定めておき、その名前で作る。
 * 頂点情報となる Attribute 属性値はメンバ経由の設定は出来ず、決められた予約語での設定か、Mesh2D クラスによる指定(予定)となる。
 * (自由名にして呼び出し時指定してもいいが……、元々いくつか予約語あるし固定にしても大差ないはず)
 * ShaderProgram に元々あるメンバ関数やプロパティは必然的にシェーダー内で入力変数名としては使えない(そのため現状は最小限のメンバしか追加していない)。
 *
 * シェーダー内で定義された入力名として追加されたプロパティに値を設定しておくと、描画時にその値が設定される。
 * 追加されたプロパティは値の設定のみ可能で、取得は出来ない。
 * 値は保持され続けるので、同じシェーダーを使う場合、描画前に指定したい値に変更しておく必要がある。
 * プロパティの型は、シェーダースクリプトから取得される。
 * vec4などはArrayクラスにreal型の配列として受け渡しする。
 *
 * 予約語は、描画実行時に内部的に自動的に設定されるので、明示的に値を設定する必要はない。
 * ex. s_tex0 には、1個目の texture id が渡される。
 * 自動的に設定される値は描画命令に依存する → 順次整備
 *
 * シェーダーがスクリプトから指定出来て、自由に入れ替えられるのなら、従来のようにLayerに機能拡張するためにプラグインを書かなくても、
 * TJS2 スクリプトのみで、従来の CPU 処理するよりも高速に演出の追加が可能になると予測できる。
 * Layer 相当の機能が現状ないが、Layer/Sprite などを TJS2 スクリプトで実現するために必要な周辺機能を充実させれば、その辺りスクリプト
 * で書けて、従来よりネイティブ(C++)プラグインの出番を少なくできる。
 * 複数 CPU に向けてバイナリを準備する必要のある Android ではスクリプトで機能拡張できるのは、apk サイズ縮小にも役立つはず。
 * また、マルチプラットフォームでも有利。
 * シェーダー + それを扱う Sprite 等を実現する TJS2 スクリプトをセットで配布すれば、それで演出強化できる。
 *
 * シェーダースクリプトをファイル入力する場合は、UTF-8で記述すること。
 *
 *
 * シェーダー内で使用できない(内部定義されている)変数名
 * ShaderProgram
 * finalize
 *
 * 自動的に設定される値の名称
 * テクスチャ
 * s_tex0, s_tex1, s_tex2, s_tex3...
 * 頂点座標
 * a_pos(vec2)
 * テクスチャ座標
 * a_texCoord(vec2)
 * 行列
 * a_modelMat4(mat4)
 *
 *
 * GLSLの構造体と配列には初期段階では未対応。
 */
class ShaderProgram {

	/**
	 * コンストラクタ
	 * @param vertex パーティンクシェーダーを指定します。fileがtrueの時はファイル名、falseの時は直接文字列を指定します。
	 * @param fragment フラグメントシェーダーを指定します。fileがtrueの時はファイル名、falseの時は直接文字列を指定します。
	 * @param file vertex/fragmentで指定された文字列がファイルか直接スクリプト指定かを選択します。
	 */
	function ShaderProgram( vertex:string, fragment:string, file:boolean=true );

};
