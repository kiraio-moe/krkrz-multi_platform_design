/**
 * @description Layer クラスは、レイヤを管理するためのクラスです。
 */
class Layer {
	/**
	 * Layer オブジェクトの構築
	 *
	 * @param window このレイヤを保有することになるウィンドウ ( Window クラスの
	 * 				オブジェクト ) を指定します。ウィンドウはいったん決定したら変更することはできません。
	 * @param parent このレイヤの親となるレイヤを指定します。null を指定するとプライマリレイヤになります。プライマリレイヤはウィンドウに一つのみ存在することができ、また、レイヤを用いる場合は
	 * 				かならず一つ存在しなければならない、すべてのレイヤの親となるレイヤです。ただし、描画デバイス ( Window.drawDevice で設定可能) によっては、ウィンドウが
	 * 				複数のプライマリレイヤを持つことができる物があります。レイヤの親は、Layer.parent プロパティで変更することができます。
	 * @description Layer クラスのオブジェクトを構築します。Layer クラスは非表示の状態で構築されます。
	 */
	function Layer( window, parent);

	/**
	 * レイヤがクリックされた
	 *
	 * @param x レイヤがクリックされた位置の x 座標 ( レイヤの表示座標での ) の値です。
	 * @param y レイヤがクリックされた位置の y 座標 ( レイヤの表示座標での ) の値です。
	 * @description レイヤがクリックされた時に発生します。
	 * @see Layer.onMouseDown
	 * @see Layer.onDoubleClick
	 */
	event onClick( x, y);

	/**
	 * レイヤがダブルクリックされた
	 *
	 * @param x レイヤがダブルクリックされた位置の x 座標 ( レイヤの表示座標での ) の値です。
	 * @param y レイヤがダブルクリックされた位置の y 座標 ( レイヤの表示座標での ) の値です。
	 * @description レイヤがダブルクリックされた時に発生します。
	 * @see Layer.onClick
	 */
	event onDoubleClick( x, y);

	/**
	 * マウスのボタンが押された
	 *
	 * @param x マウスのボタンが押された位置の x 座標 ( レイヤの表示座標での ) の値です。
	 * @param y マウスのボタンが押された位置の y 座標 ( レイヤの表示座標での ) の値です。
	 * @param button 押されたマウスボタンです。以下のいずれかの値になります。mbLeft    : マウスの左ボタンが押されたmbMiddle  : マウスの中ボタンが押されたmbRight   : マウスの右ボタンが押されたmbX1      : マウスのサイドキー第1ボタンが押されたmbX2      : マウスのサイドキー第2ボタンが押された
	 * @param shift マウスボタンが押されたときに同時に押されていたシフト系のキーの状態です。
	 * 				以下の値のビット OR による組み合わせになります。ssAlt     : ALT キーが押されていたssShift   : SHIFT キーが押されていたssCtrl    : CTRL キーが押されていた
	 * @description マウスボタンが押された時に発生します。
	 * @see Layer.onClick
	 */
	event onMouseDown( x, y, button, shift);

	/**
	 * マウスのボタンが離された
	 *
	 * @param x マウスのボタンが離された位置の x 座標 ( レイヤの表示座標での ) の値です。
	 * @param y マウスのボタンが離された位置の y 座標 ( レイヤの表示座標での ) の値です。
	 * @param button 離されたマウスボタンです。以下のいずれかの値になります。mbLeft    : マウスの左ボタンが離されたmbMiddle  : マウスの中ボタンが離されたmbRight   : マウスの右ボタンが離されたmbX1      : マウスのサイドキー第1ボタンが離されたmbX2      : マウスのサイドキー第2ボタンが離された
	 * @param shift マウスボタンが離された時に同時に押されていたシフト系のキーの状態です。
	 * 				以下の値のビット OR による組み合わせになります。ssAlt     : ALT キーが押されていたssShift   : SHIFT キーが押されていたssCtrl    : CTRL キーが押されていた
	 * @description マウスボタンが離された時に発生します。
	 */
	event onMouseUp( x, y, button, shift);

	/**
	 * マウスが移動した
	 *
	 * @param x マウスが移動した位置の x 座標 ( レイヤの表示座標での ) の値です。
	 * @param y マウスが移動した位置の y 座標 ( レイヤの表示座標での ) の値です。
	 * @param shift マウスが移動していた時に同時に押されていたシフト系のキーやマウスのボタンの状態です。
	 * 				以下の値のビット OR による組み合わせになります。ssAlt     : ALT キーが押されていたssShift   : SHIFT キーが押されていたssCtrl    : CTRL キーが押されていたssLeft    : マウスの左ボタンが押されていたssMiddle  : マウスの中ボタンが押されていたssRight   : マウスの右ボタンが押されていた
	 * @description マウスが移動した時に発生します。
	 */
	event onMouseMove( x, y, shift);

	/**
	 * マウスが入ってきた
	 *
	 * @description マウスがレイヤの領域内に入ってきたときに発生します。
	 * @see Layer.onMouseLeave
	 */
	event onMouseEnter( );

	/**
	 * マウスが出ていった
	 *
	 * @description マウスがレイヤの領域内から出ていったときに発生します。
	 * @see Layer.onMouseEnter
	 */
	event onMouseLeave( );

	/**
	 * マウスホイールが回転した
	 *
	 * @param shift マウスが移動していた時に同時に押されていたシフト系のキーやマウスのボタンの状態です。
	 * 				以下の値のビット OR による組み合わせになります。ssAlt     : ALT キーが押されていたssShift   : SHIFT キーが押されていたssCtrl    : CTRL キーが押されていたssLeft    : マウスの左ボタンが押されていたssMiddle  : マウスの中ボタンが押されていたssRight   : マウスの右ボタンが押されていた
	 * @param delta ホイールの回転角です。上方向(ユーザの反対側の方向)に回された場合は正、
	 * 				下方向(ユーザ側の方向)に回された場合は負の値になります。通常、最小量は 120
	 * 				となります。
	 * @param x ホイールが回転した位置の x 座標 ( レイヤの表示座標での ) の値です。
	 * @param y ホイールが回転した位置の y 座標 ( レイヤの表示座標での ) の値です。
	 * @description マウスホイールが回転した時に発生します。このイベントは、キーボードイベントと同じく、フォーカスを持っているレイヤにのみ発生します。
	 */
	event onMouseWheel( shift, delta, x, y);

	/**
	 * キーが押された
	 *
	 * @param key 押されたキーの仮想キーコードの値です。
	 * @param shift キーが押された時に同時に押されていたシフト系のキーやマウスのボタンの状態です。
	 * 				以下の値のビット OR による組み合わせになります。ssAlt     : ALT キーが押されていたssShift   : SHIFT キーが押されていたssCtrl    : CTRL キーが押されていたssLeft    : マウスの左ボタンが押されていたssMiddle  : マウスの中ボタンが押されていたssRight   : マウスの右ボタンが押されていたまた、キーボードが長時間押され、キーリピートが発生している場合は
	 * 				以下の値も組み合わされます。ssRepeat  : キーリピートが発生した
	 * @param process 親クラスのonKeyDownを呼ぶ際、この引数に偽を渡すと、親クラスでは
	 * 				そのキーに対するデフォルトの処理(フォーカスの移動など)を行わなくなります。
	 * @description キーが押された時に発生します。
	 */
	event onKeyDown( key, shift, process=true);

	/**
	 * キーが離された
	 *
	 * @param key 離されたキーの仮想キーコードの値です。
	 * @param shift キーが離された時に同時に押されていたシフト系のキーやマウスのボタンの状態です。
	 * 				以下の値のビット OR による組み合わせになります。ssAlt     : ALT キーが押されていたssShift   : SHIFT キーが押されていたssCtrl    : CTRL キーが押されていたssLeft    : マウスの左ボタンが押されていたssMiddle  : マウスの中ボタンが押されていたssRight   : マウスの右ボタンが押されていた
	 * @param process 親クラスのonKeyUpを呼ぶ際、この引数に偽を渡すと、親クラスでは
	 * 				そのキーに対するデフォルトの処理(フォーカスの移動など)を行わなくなります。
	 * @description キーが離された時に発生します。
	 */
	event onKeyUp( key, shift, process=true);

	/**
	 * 文字が入力された
	 *
	 * @param key 入力された文字です。
	 * @param process 親クラスのonKeyPressを呼ぶ際、この引数に偽を渡すと、親クラスでは
	 * 				そのキーに対するデフォルトの処理(フォーカスの移動など)を行わなくなります。
	 * @description 文字が入力されたときに発生します。Layer.onKeyDown と異なるのは、onKeyDown が
	 * 		仮想キーコードを扱うのに対し、このイベントは文字そのものを扱います。押されたキーが
	 * 		文字とは関係のないキー (ファンクションキーなど) の場合はこのイベントは発生しません。
	 */
	event onKeyPress( key, process=true);

	/**
	 * 当たり判定
	 *
	 * @param x 当たり判定を行う位置の ( レイヤの表示座標内での )  x 座標です。
	 * @param y 当たり判定を行う位置の ( レイヤの表示座標内での )  y 座標です。
	 * @param hit 当たり判定の結果、当たっている場合は真, はずれている場合は偽になります。
	 * 				当たり判定の結果は、同名のスーパークラスのイベントのこの引数に渡してください。
	 * @description レイヤ内のある点に対して、当たり判定 ( ヒットテスト ) が行われる場合に呼び出されます。当たり判定の結果は、スーパークラスのこのイベントの第３引数に当たり判定の結果を
	 * 		渡してください ( 第１引数と
	 * 		第２引数はそのまま渡してください )。当たり判定の結果、当たっていればマウスメッセージは不透過になり、そのレイヤで処理されます。当たっていなければ透過となり、マウスメッセージはより奥にあるレイヤで処理されます。このイベントは、Layer.hitThreshold や Layer.hitType で行われる
	 * 		当たり判定で「当たっている」という判定がされた後に呼び出されます。したがって
	 * 		Layer.hitThreshold や Layer.hitType で「当たってない」と判定されている場合は
	 * 		このイベントは呼び出されません。
	 */
	event onHitTest( x, y, hit);

	/**
	 * フォーカスを失った
	 *
	 * @param focused あらたにフォーカスを得たレイヤオブジェクトです。
	 * @description レイヤがフォーカスを失った際に呼ばれます。
	 */
	event onBlur( focused);

	/**
	 * フォーカスを得た
	 *
	 * @param focused フォーカスを失ったレイヤオブジェクトです。
	 * @param direction フォーカスの後方検索によってフォーカスが変更されるときは真、
	 * 				フォーカスの前方検索によって行われる場合は偽になります。
	 * @description レイヤがフォーカスを得た際に呼ばれます。
	 */
	event onFocus( focused, direction);

	/**
	 * ノードが操作不能になった
	 *
	 * @description そのレイヤや、そのレイヤの ( 親子関係的に ) 上位のレイヤの Layer.enabled プロパティ
	 * 		が変更されたために、そのレイヤが操作不能になったときに呼ばれます。
	 */
	event onNodeDisabled( );

	/**
	 * ノードが操作可能になった
	 *
	 * @description そのレイヤや、そのレイヤの ( 親子関係的に ) 上位のレイヤの Layer.enabled プロパティ
	 * 		が変更されたために、そのレイヤが操作可能になったときに呼ばれます。
	 */
	event onNodeEnabled( );

	/**
	 * フォーカス可能なレイヤの前方検索
	 *
	 * @param layer フォーカスを受け取るレイヤオブジェクトです。親クラスの同名のメソッドを呼ぶときに引数として指定します。null を渡すと、フォーカス可能なレイヤは無いとして処理されます。
	 * @description フォーカス可能なレイヤの前方検索を行うときに発生するイベントです。フォーカスを受け取るレイヤを指定するときは、スーパークラスの同名のイベント
	 * 		の引数にそのレイヤを指定してください。
	 */
	event onSearchPrevFocusable( layer);

	/**
	 * フォーカス可能なレイヤの後方検索
	 *
	 * @param layer フォーカスを受け取るレイヤオブジェクトです。親クラスの同名のメソッドを呼ぶときに引数として指定します。null を渡すと、フォーカス可能なレイヤは無いとして処理されます。
	 * @description フォーカス可能なレイヤの後方検索を行うときに発生するイベントです。フォーカスを受け取るレイヤを指定するときは、スーパークラスの同名のイベント
	 * 		の引数にそのレイヤを指定してください。
	 */
	event onSearchNextFocusable( layer);

	/**
	 * フォーカスを受け取る直前
	 *
	 * @param layer フォーカスを受け取るレイヤオブジェクトです。通常は this が渡されますが、スーパークラスの同名のイベントを呼ぶときに
	 * 				異なるレイヤオブジェクトを指定すれば、そのレイヤにフォーカスを
	 * 				渡すようにすることができます。
	 * @param blurred フォーカスを失うレイヤオブジェクトです。
	 * @param direction フォーカスの後方検索によってフォーカスが変更されるときは真、
	 * 				フォーカスの前方検索によって行われる場合は偽になります。
	 * @description フォーカスを受け取る直前に発生するイベントです。フォーカスを受け取るレイヤを指定するときは、スーパークラスの同名のイベント
	 * 		の第１引数にそのレイヤを指定する事ができます。
	 */
	event onBeforeFocus( layer, blurred, direction);

	/**
	 * 描画されるとき
	 *
	 * @description レイヤが実際にウィンドウに描画される直前に呼ばれます。このイベントは Layer.callOnPaint プロパティが真の時のみに呼ばれ、
	 * 		Layer.callOnPaint はこのイベントが実行し終わった後自動的に偽に設定されます。
	 * @see Layer.update
	 */
	event onPaint( );

	/**
	 * トランジションが終了した
	 *
	 * @param dest トランジション先のレイヤオブジェクト ( 通常は this ) が渡されます。
	 * @param src トランジション元のレイヤオブジェクトが渡されます。トランジションの種類によっては null になり得ます。
	 * @description トランジションが終了した時に呼ばれます。
	 */
	event onTransitionCompleted( dest, src);

	/**
	 * 画面がタッチされた
	 *
	 * @param x タッチされた位置の x 座標 ( クライアント座標での ) の値です。
	 * @param y タッチされた位置の y 座標 ( クライアント座標での ) の値です。
	 * @param cx 指が接触している横方向ピクセル数です。デバイスが対応していない場合は常に1です。
	 * @param cy 指が接触している縦方向ピクセル数です。デバイスが対応していない場合は常に1です。
	 * @param id タッチIDです。マルチタッチ時、各位置ごとに固有の値が設定され、このIDによって位置を識別できます。
	 * @description タッチパネルにタッチされた時に発生します。このイベントが発生するのはX,Y座標がこのレイヤ内にある場合です。
	 */
	event onTouchDown( x, y, cx, cy, id);

	/**
	 * 画面から指が離された
	 *
	 * @param x 離された位置の x 座標 ( クライアント座標での ) の値です。
	 * @param y 離された位置の y 座標 ( クライアント座標での ) の値です。
	 * @param cx 指が接触している横方向ピクセル数です。デバイスが対応していない場合は常に1です。
	 * @param cy 指が接触している縦方向ピクセル数です。デバイスが対応していない場合は常に1です。
	 * @param id タッチIDです。マルチタッチ時、各位置ごとに固有の値が設定され、このIDによって位置を識別できます。
	 * @description タッチパネルから指が離された時に発生します。このイベントが発生するのはX,Y座標がこのレイヤ内にある場合です。ただし、マウスとは異なり、現在の座標で判定されるのでonTouchDownが発生したレイヤと同一ではない可能性があります。
	 */
	event onTouchUp( x, y, cx, cy, id);

	/**
	 * 指が移動した
	 *
	 * @param x タッチ位置の x 座標 ( クライアント座標での ) の値です。
	 * @param y タッチ位置の y 座標 ( クライアント座標での ) の値です。
	 * @param cx 指が接触している横方向ピクセル数です。デバイスが対応していない場合は常に1です。
	 * @param cy 指が接触している縦方向ピクセル数です。デバイスが対応していない場合は常に1です。
	 * @param id タッチIDです。マルチタッチ時、各位置ごとに固有の値が設定され、このIDによって位置を識別できます。
	 * @description タッチパネル上で触れている指が移動した時に発生します。このイベントが発生するのはX,Y座標がこのレイヤ内にある場合です。ただし、マウスとは異なり、現在の座標で判定されるのでonTouchDownが発生したレイヤと同一ではない可能性があります。
	 */
	event onTouchMove( x, y, cx, cy, id);

	/**
	 * 拡大操作した
	 *
	 * @param startdistance マルチタッチが開始された時のピクセル距離です。
	 * @param currentdistance イベント発生時のタッチのピクセル距離です。
	 * @param cx 中心位置の x 座標 ( クライアント座標での ) の値です。
	 * @param cy 中心位置の y 座標 ( クライアント座標での ) の値です。
	 * @param flag マルチタッチ状態フラグです。0x01     : マルチタッチが開始された最初のイベントに設定されています。
	 * @description タッチパネル上でマルチタッチによって拡大操作した時に発生します。このイベントが発生するのは、フォーカスのあるレイヤです。
	 */
	event onTouchScaling( startdistance, currentdistance, cx, cy, flag);

	/**
	 * 回転操作した
	 *
	 * @param startangle マルチタッチが開始された時のラジアン角度です。
	 * @param currentangle イベント発生時のタッチのラジアン角度です。
	 * @param distance イベント発生時のタッチのピクセル距離です。
	 * @param cx 中心位置の x 座標 ( クライアント座標での ) の値です。
	 * @param cy 中心位置の y 座標 ( クライアント座標での ) の値です。
	 * @param flag マルチタッチ状態フラグです。0x01     : マルチタッチが開始された最初のイベントに設定されています。
	 * @description タッチパネル上でマルチタッチによって回転操作した時に発生します。このイベントが発生するのは、フォーカスのあるレイヤです。
	 */
	event onTouchRotate( startangle, currentangle, distance, cx, cy, flag);

	/**
	 * マルチタッチ状態が変化した
	 *
	 * @description マルチタッチ状態が開始されたり、移動したり、離れた時に発生します。座標情報は Window.touchPointCount プロパティと Window.getTouchPoint メソッドで取得できます。このイベントが発生するのは、フォーカスのあるレイヤです。
	 * @see Window.getTouchPoint
	 * @see Window.touchPointCount
	 */
	event onMultiTouch( );

	/**
	 * 指定レイヤの手前に移動
	 *
	 * @param layer ここで指定したレイヤの手前に移動します。兄弟レイヤ ( 同じ親を持つレイヤ ) のみを指定できます。
	 * @description 重ね合わせ順において、指定されたレイヤの手前に移動します。このメソッドは Layer.absoluteOrderMode プロパティを false に設定します。
	 */
	function moveBefore( layer);

	/**
	 * 指定レイヤの奥に移動
	 *
	 * @param layer ここで指定したレイヤの奥に移動します。兄弟レイヤ ( 同じ親を持つレイヤ ) のみを指定できます。
	 * @description 重ね合わせ順において、指定されたレイヤの奥に移動します。このメソッドは Layer.absoluteOrderMode プロパティを false に設定します。
	 */
	function moveBehind( layer);

	/**
	 * 一番奥に移動
	 *
	 * @description 重ね合わせ順において、兄弟レイヤ ( 同じ親を持つレイヤ ) の中でもっとも奥に移動します。このメソッドを実行すると親レイヤの Layer.absoluteOrderMode プロパティが偽に設定されます。
	 * @see Layer.order
	 * @see Layer.absolute
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToFront
	 */
	function bringToBack( );

	/**
	 * 一番手前に移動
	 *
	 * @description 重ね合わせ順において、兄弟レイヤ ( 同じ親を持つレイヤ ) の中でもっとも手前に移動します。このメソッドを実行すると親レイヤの Layer.absoluteOrderMode プロパティが偽に設定されます。
	 * @see Layer.order
	 * @see Layer.absolute
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToBack
	 */
	function bringToFront( );

	/**
	 * 画像の読み込み
	 *
	 * @param image 読み込む画像ストレージを指定します。ここで指定したストレージ名(拡張子を除く) に _m を付加した画像ストレージが
	 * 				存在すれば、マスク(不透明度)画像として読み込まれます。ここで指定したストレージ名(拡張子を除く) に _p を付加した画像ストレージが
	 * 				存在すれば、領域画像として読み込まれます。
	 * @param colorkey 読み込む画像のカラーキー ( 透明色 ) を指定します。0xRRGGBB 形式で色を指定すると、その色をカラーキーとします。clPalIdx に 任意のパレットインデックスを加算した数値を指定すると、
	 * 				そのパレットインデックスが透明色になります ( 256 色以下の画像の場合 )。clAdapt を指定すると、画像の一番上のラインにおいて
	 * 				もっとも多く使われている色が自動的に透明色になります。clAlphaMat に 0xRRGGBB
	 * 				形式の色を表す数値を加算したものを指定すると、画像がその色の上に
	 * 				αブレンド(ltAlphaの方式)を用いて重ね合わせられます。
	 * 				たとえば、(clAlphaMat + 0xffffff) を指定すると、
	 * 				読み込まれた画像が白い色の上に重ね合わせられます。
	 * 				画像は全て不透明な画像となります
	 * 				( 画像は全て不透明となりますが、
	 * 				このモードではタグ情報はいっさい変更されないので
	 * 				注意してください )。
	 * @return タグ情報の辞書配列
	 * @description レイヤに画像を読み込みます。このメソッドはレイヤの画像サイズは変更しますが、画像サイズがレイヤの表示サイズより小さかった場合を
	 * 		除いて、レイヤの表示サイズは変更しません。戻り値としてタグ情報(その画像のレイヤタイプや表示位置など、画像そのものに対する情報)の辞書配列が返ります。KAG の「タグ」の意味と混同しないように注意してください。画像がタグ情報を持たない場合は null が返ります。現バージョンでは、タグ情報は PNG, TLG5/6 形式のみが持つことができます。取得可能な情報については、画像フォーマットコンバータ を参照してください。
	 */
	function loadImages( image, colorkey=clNone);

	/**
	 * 領域画像の読み込み
	 *
	 * @param image 領域画像として読み込む画像ストレージを指定します。
	 * @description レイヤの領域画像を読み込みます。それ以外の画像はそのままとなります。読み込もうとした画像がレイヤの画像サイズと異なる場合は例外が発生します。
	 */
	function loadProvinceImage( image);

	/**
	 * メイン画像の色の取得
	 *
	 * @param x 色を取得する ( レイヤの画像座標での ) x 座標を指定します。
	 * @param y 色を取得する ( レイヤの画像座標での ) y 座標を指定します。
	 * @return 0xRRGGBB 形式の色番号
	 * @description レイヤメイン画像 ( 色を保持している画像 ) の任意の位置の色を取得します。画像座標として無効な ( 範囲外の ) 位置を指定すると例外が発生します。
	 */
	function getMainPixel( x, y);

	/**
	 * メイン画像の色の設定
	 *
	 * @param x 色を設定する ( レイヤの画像座標での ) x 座標を指定します。
	 * @param y 色を設定する ( レイヤの画像座標での ) y 座標を指定します。
	 * @param color 設定する色を 0xRRGGBB 形式で指定します。
	 * @description レイヤメイン画像 ( 色を保持している画像 ) の任意の位置の色を設定します。画像座標として無効な ( 範囲外の ) 位置を指定すると例外が発生します。
	 */
	function setMainPixel( x, y, color);

	/**
	 * マスク画像の値の取得
	 *
	 * @param x 値を取得する ( レイヤの画像座標での ) x 座標を指定します。
	 * @param y 値を取得する ( レイヤの画像座標での ) y 座標を指定します。
	 * @return マスク画像の値 ( 0 ～ 255 )
	 * @description レイヤマスク画像 ( 不透明度を保持している画像 ) の任意の位置の値 ( 0 ～ 255 ) を取得します。画像座標として無効な ( 範囲外の ) 位置を指定すると例外が発生します。
	 */
	function getMaskPixel( x, y);

	/**
	 * マスク画像の値の設定
	 *
	 * @param x 値を設定する ( レイヤの画像座標での ) x 座標を指定します。
	 * @param y 値を設定する ( レイヤの画像座標での ) y 座標を指定します。
	 * @param value 設定する値 ( 0 ～ 255 ) を指定します。
	 * @description レイヤマスク画像 ( 不透明度を保持している画像 ) の任意の位置の値 ( 0 ～ 255 ) を設定します。画像座標として無効な ( 範囲外の ) 位置を指定すると例外が発生します。
	 */
	function setMaskPixel( x, y, value);

	/**
	 * 領域画像の値の取得
	 *
	 * @param x 値を取得する ( レイヤの画像座標での ) x 座標を指定します。
	 * @param y 値を取得する ( レイヤの画像座標での ) y 座標を指定します。
	 * @return 領域画像の値 ( 0 ～ 255 )
	 * @description レイヤ領域画像の任意の位置の値 ( 0 ～ 255 ) を取得します。画像座標として無効な ( 範囲外の ) 位置を指定すると例外が発生します。
	 */
	function getProvincePixel( x, y);

	/**
	 * 領域画像の値の設定
	 *
	 * @param x 値を設定する ( レイヤの画像座標での ) x 座標を指定します。
	 * @param y 値を設定する ( レイヤの画像座標での ) y 座標を指定します。
	 * @param value 設定する値 ( 0 ～ 255 ) を指定します。
	 * @description レイヤ領域画像の任意の位置の値 ( 0 ～ 255 ) を設定します。画像座標として無効な ( 範囲外の ) 位置を指定すると例外が発生します。
	 */
	function setProvincePixel( x, y, value);

	/**
	 * 指定位置のレイヤを取得
	 *
	 * @param x 取得したいレイヤの位置の x 座標を表示座標上でピクセル単位で指定します。このメソッドを実行するレイヤの表示座標が用いられます ( プライマリレイヤ上の
	 * 				表示座標ではありません )
	 * @param y 取得したいレイヤの位置の y 座標を表示座標上でピクセル単位で指定します。このメソッドを実行するレイヤの表示座標が用いられます ( プライマリレイヤ上の
	 * 				表示座標ではありません )
	 * @param exclude_self レイヤの検索から自分自身を除外するかどうかを指定します。偽を指定すると、自分自身のレイヤも検索に含まれます。真を指定すると、自分自身のレイヤは検索から除外され、あたかも存在しないかのように扱われます。この引数を省略すると偽が指定されたと見なされます。
	 * @param get_disabled 無効になっているレイヤのオブジェクトを得るかどうかを指定します。偽を指定すると、無効 (Layer.enabled プロパティが偽など) になっているレイヤが指定位置にあった場合、null が返ります。真を指定すると、無効になっているレイヤが指定位置にあった場合は、そのレイヤオブジェクトを返します。この引数を省略すると偽が指定されたと見なされます。
	 * @return 指定位置にあったレイヤオブジェクト。指定位置にレイヤが無かった場合などは null が戻ります。
	 * @description x,y で示された位置にあるレイヤオブジェクトを返します。当たり判定は通常のマウスイベントの当たり判定と同じ機構が用いられます。つまり、指定位置を、レイヤの重ね順において一番手前から見ていき、最初に当たり判定に該当したレイヤが返されます。exclude_self 引数で真を指定すると、このメソッドを実行するレイヤを検索の対象から除外することができます。
	 * @see Layer.hitType
	 * @see Layer.hitThreshold
	 * @see Layer.onHitTest
	 */
	function getLayerAt( x, y, exclude_self=false, get_disabled=false);

	/**
	 * マウスイベントキャプチャの解除
	 *
	 * @description マウスイベントキャプチャを解除します。マウスイベントキャプチャとは、最初にマウスボタンを押下した位置にあったレイヤのみに、マウスボタンを放すまでずっとマウスイベントが占有的に送られる機能です。このメソッドは、この機能を解除し、通常のマウスイベントの処理状態に戻します。このメソッドを実行すると、同じウィンドウに属しているレイヤのマウスキャプチャは、たとえメソッドを実行するレイヤとキャプチャの対象となっているレイヤが異なっていても解除されます。このメソッドはキャプチャ状態でない場合は何もしません。
	 */
	function releaseCapture( );

	/**
	 * レイヤ表示位置の設定
	 *
	 * @param left レイヤの ( 親レイヤの表示座標での ) 左端位置をピクセル単位で指定します。この値は Layer.left プロパティでも取得や設定ができます。
	 * @param top レイヤの ( 親レイヤの表示座標での ) 上端位置をピクセル単位で指定します。この値は Layer.top プロパティでも取得や設定ができます。
	 * @param width レイヤの横幅をピクセル単位で指定します。この値は Layer.width プロパティでも取得や設定ができます。この引数と height 引数が省略された場合は left 引数と top 引数による位置の変更のみとなります。
	 * @param height レイヤの縦幅をピクセル単位で指定します。この値は Layer.height プロパティでも取得や設定ができます。この引数と width 引数が省略された場合は left 引数と top 引数による位置の変更のみと
	 * 				なります。
	 * @description レイヤの表示位置を設定します。
	 */
	function setPos( left, top, width=void, height=void);

	/**
	 * 描画クリップ矩形の設定
	 *
	 * @param left 描画クリップ矩形の ( レイヤの画像座標での ) 左端位置をピクセル単位で指定します。この値は Layer.clipLeft プロパティでも取得や設定ができます。
	 * @param top 描画クリップ矩形の ( レイヤの画像座標での ) 上端位置をピクセル単位で指定します。この値は Layer.clipTop プロパティでも取得や設定ができます。
	 * @param width 描画クリップ矩形の横幅をピクセル単位で指定します。この値は Layer.clipWidth プロパティでも取得や設定ができます。
	 * @param height 描画クリップ矩形の縦幅をピクセル単位で指定します。この値は Layer.clipHeight プロパティでも取得や設定ができます。
	 * @description レイヤの描画クリップ矩形を設定します。レイヤに対する描画は、この描画クリップ矩形内に制限されます ( 矩形外にはみ出た部分は
	 * 		描画されません )。ただし、Layer.flipLR や Layer.flipUD のように
	 * 		描画クリップ矩形の影響を受けないメソッドもあります。初期値は、クリップ矩形はレイヤ画像領域全体に設定されています ( レイヤ全面
	 * 		に描画する事ができます )。描画クリップ矩形は、画像読み込みや画像サイズが変更されたり、レイヤの表示タイプが
	 * 		変更されると初期値に戻ります。また、このメソッドを引数なしで呼び出すと、描画クリップ矩形を初期値に戻すことができます。
	 */
	function setClip( left, top, width=void, height=void);

	/**
	 * レイヤ表示サイズの設定
	 *
	 * @param width レイヤの表示の横幅をピクセル単位で指定します。この値は Layer.width プロパティでも取得や設定ができます。
	 * @param height レイヤの表示の縦幅をピクセル単位で指定します。この値は Layer.height プロパティでも取得や設定ができます。
	 * @description レイヤの表示サイズを設定します。
	 */
	function setSize( width, height);

	/**
	 * レイヤ表示サイズを画像サイズに合わせる
	 *
	 * @description レイヤの表示サイズを画像サイズと同じにします。画像サイズを変更する多くの操作では表示サイズまでは変更しませんが、
	 * 		このメソッドを使うと表示サイズを画像サイズと同じにすることができます。
	 */
	function setSizeToImageSize( );

	/**
	 * レイヤ画像オフセットの設定
	 *
	 * @param left レイヤに表示する画像の左端位置 ( x オフセット ) をピクセル単位で指定します。この値は Layer.imageLeft プロパティでも取得や設定ができます。
	 * @param top レイヤに表示する画像の上端位置 ( y オフセット ) をピクセル単位で指定します。この値は Layer.imageTop プロパティでも取得や設定ができます。
	 * @description レイヤ画像オフセットを指定します。レイヤ画像サイズはレイヤ表示サイズより大きくすることができますが、すべてを表示する
	 * 		ことはできませんので、このメソッドや Layer.imageLeft や Layer.imageTopプロパティで表示オフセットを指定することになります。オフセットは、 0 か、負の数値になります。
	 */
	function setImagePos( left, top);

	/**
	 * レイヤ画像サイズの設定
	 *
	 * @param width レイヤ画像の横幅をピクセル単位で指定します。この値は Layer.imageWidth プロパティでも取得や設定ができます。
	 * @param height レイヤ画像の縦幅をピクセル単位で指定します。この値は Layer.imageHeight プロパティでも取得や設定ができます。
	 * @description レイヤ画像サイズを指定します。サイズが拡張される場合は、レイヤの表示サイズは変更されませんが、サイズが縮小
	 * 		される場合はレイヤの表示サイズも縮小されます。
	 */
	function setImageSize( width, height);

	/**
	 * メイン画像の共有の解除
	 *
	 * @param copy 共有状態を解除する際、元の画像をコピーするかどうかを指定します。真を指定すると元の画像をコピーします。偽を指定すると元の画像はコピーされず、画像の
	 * 				内容は不定となります。
	 * 			
	 * @description レイヤ画像の共有状態を強制的に解除します。吉里吉里は、assignImages などで画像をまるごと他のレイヤにコピーした場合、実際には
	 * 		画像バッファのコピーを行わず、同一の画像を共有するようになります。通常、画像に変更を加えようとする直前でこの共有状態は自動的に解除されますが、
	 * 		このメソッドで強制的に解除することができます。copy 引数に false を指定した場合は、画像の共有は解除されますが、元の画像を
	 * 		引き継ぐことは保証されません ( 画像の内容は不定になります ) が、共有の解除を
	 * 		より高速に行うことができます。レイヤの画像全部を書き換える場合は元の画像を
	 * 		引き継ぐ必要はありませんので、描画を行う前にあらかじめこのメソッドに false を
	 * 		指定して呼び出すと効率が良くなる場合があります。このメソッドは、画像が共有されていない場合は何もしません。
	 */
	function independMainImage( copy=true);

	/**
	 * 領域画像の共有の解除
	 *
	 * @param copy 共有状態を解除する際、元の画像をコピーするかどうかを指定します。真を指定すると元の画像をコピーします。偽を指定すると元の画像はコピーされず、画像の
	 * 				内容は不定となります。
	 * 			
	 * @description 領域画像の共有状態を強制的に解除します。吉里吉里は、assignImages などで画像をまるごと他のレイヤにコピーした場合、実際には
	 * 		画像バッファのコピーを行わず、同一の画像を共有するようになります。通常、画像に変更を加えようとする直前でこの共有状態は自動的に解除されますが、
	 * 		このメソッドで強制的に解除することができます。copy 引数に false を指定した場合は、画像の共有は解除されますが、元の画像を
	 * 		引き継ぐことは保証されません ( 画像の内容は不定になります ) が、共有の解除を
	 * 		より高速に行うことができます。レイヤの画像全部を書き換える場合は元の画像を
	 * 		引き継ぐ必要はありませんので、描画を行う前にあらかじめこのメソッドに false を
	 * 		指定して呼び出すと効率が良くなる場合があります。このメソッドは、画像が共有されていない場合は何もしません。
	 */
	function independProvinceImage( copy=true);

	/**
	 * 矩形塗りつぶし
	 *
	 * @param left 塗りつぶす矩形の左端位置を ( 画像位置における ) ピクセル単位で指定します。
	 * @param top 塗りつぶす矩形の上端位置を ( 画像位置における ) ピクセル単位で指定します。
	 * @param width 塗りつぶす矩形の横幅を ( 画像位置における ) ピクセル単位で指定します。
	 * @param height 塗りつぶす矩形の縦幅を ( 画像位置における ) ピクセル単位で指定します。
	 * @param value 塗りつぶす色や値を指定します。この値は、Layer.face プロパティの値によって意味が変わります。dfAlpha (またはdfBoth)   : 0xAARRGGBB 形式で不透明度と色を指定してください。メインとマスクの両方が塗りつぶされます。dfAddAlpha               : 0xAARRGGBB 形式で不透明度と色を指定してください。メインとマスクの両方が塗りつぶされます。dfOpaque (またはdfMain)  : 0xRRGGBB 形式で色を指定してください。Layer.holdAlpha プロパティが真の時は、メインのみが塗りつぶされ、マスクはそのままになります。偽の時は dfAlpha や dfAddAlpha の時と同じく、0xAARRGGBB 形式での不透明度と色の指定を受け付け、メインとマスクの両方が塗りつぶされます。dfMask                   : マスク(不透明度)の値 ( 0 ～ 255 ) を指定してください。マスクのみが塗りつぶされ、メインはそのままになります。dfProvince               : 領域の値 ( 0 ～ 255 ) を指定してください。領域のみが塗りつぶされます。
	 * @description 指定されたレイヤ画像の矩形を指定された方法で塗りつぶします。
	 */
	function fillRect( left, top, width, height, value);

	/**
	 * 矩形半透明塗りつぶし
	 *
	 * @param left 塗りつぶす矩形の左端位置を ( 画像位置における ) ピクセル単位で指定します。
	 * @param top 塗りつぶす矩形の上端位置を ( 画像位置における ) ピクセル単位で指定します。
	 * @param width 塗りつぶす矩形の横幅を ( 画像位置における ) ピクセル単位で指定します。
	 * @param height 塗りつぶす矩形の縦幅を ( 画像位置における ) ピクセル単位で指定します。
	 * @param value 塗りつぶす色や値を指定します。この値は、Layer.face プロパティの値によって意味が変わります。dfAlpha (またはdfBoth)    : 0xRRGGBB 形式で色を指定してくださいdfAddAlpha                    : 0xRRGGBB 形式で色を指定してくださいdfOpaque (またはdfMain)   : 0xRRGGBB 形式で色を指定してくださいdfMask                        : マスク(不透明度)の値 ( 0 ～ 255 ) を指定してくださいdfProvince                    : 領域の値 ( 0 ～ 255 ) を指定してくださいdfOpaque を指定した場合は、マスク情報は無視されます(マスク情報が保持されるか破壊されるかは Layer.holdAlpha プロパティによります)。また、dfMask を指定した場合は、色の情報はそのままになります。dfAlpha の場合でかつ opa が負の場合はこの引数は無視されます。
	 * @param opa 塗りつぶす不透明度 ( -255 ～ 0 ～ 255 ) を指定します。この引数は、Layer.face プロパティの値が dfMask や
	 * 				dfProvince の場合は無視されます ( 常に完全不透明 )。負の数の指定は Layer.face が dfAlpha の場合のみに有効で、
	 * 				この場合は value 引数は無視され、画像から不透明度が取り除かれます (
	 * 				-255 を指定すると矩形は完全に透明になります )。
	 * 			
	 * @description 指定されたレイヤ画像の矩形を指定された方法で塗りつぶします。Layer.fillRect と異なり、透明度を指定して半透明で塗りつぶすことができます。
	 */
	function colorRect( left, top, width, height, value, opa=255);

	/**
	 * 文字描画
	 *
	 * @param x 文字描画を開始する原点の ( 画像位置における ) x 座標をピクセル単位で指定します。
	 * @param y 文字描画を開始する原点の ( 画像位置における ) y 座標をピクセル単位で指定します。
	 * @param text 描画する文字を指定します。
	 * @param color 描画する文字の色を 0xRRGGBB 形式で指定します。
	 * @param opa 描画する文字の不透明度 ( -255 ～ 0 ～ 255 ) を指定します。負の数の指定は Layer.face が dfAlpha の場合のみに有効で、
	 * 				この場合は文字の形に不透明度が取り除かれる事になります ( 値が小さいほど
	 * 				効果が大きくなります )。
	 * @param aa アンチエイリアスを行うかどうかを指定します。真を指定するとアンチエイリアスが行われます。偽を指定すると行われません。
	 * @param shadowlevel 影の不透明度を指定します。shadowwidth 引数の値によって適切な値は変動します。0 を指定すると影は描画されません。
	 * @param shadowcolor 影の色を 0xRRGGBB 形式で指定します。
	 * @param shadowwidth 影の幅 ( ぼけ ) を指定します。 0 がもっともシャープ ( ぼけない ) で、値を大きく
	 * 				すると影をぼかすことができます。
	 * @param shadowofsx 影の位置の x 座標の値をピクセル単位で指定します。 0 を指定すると影は真下に描画されます。
	 * @param shadowofsy 影の位置の y 座標の値をピクセル単位で指定します。 0 を指定すると影は真下に描画されます。
	 * @description レイヤに文字を描画します。Layer.face が dfAlpha (または dfBoth) か dfAddAlpha か dfOpaque (または dfMain)
	 * 		の場合のみ描画することができます。dfOpaque (またはdfMain) を指定した場合、描画先のマスクが破壊されるか保護されるかは Layer.holdAlpha プロパティによります。フォントは Layer.font で指定したものが用いられます。
	 */
	function drawText( x, y, text, color, opa=255, aa=true, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0);

	/**
	 * 文字描画
	 *
	 * @param x 文字描画を開始する原点の ( 画像位置における ) x 座標をピクセル単位で指定します。
	 * @param y 文字描画を開始する原点の ( 画像位置における ) y 座標をピクセル単位で指定します。
	 * @param glyph 描画するグリフを指定します。
	 * @param color 描画する文字の色を 0xRRGGBB 形式で指定します。
	 * @param opa 描画する文字の不透明度 ( -255 ～ 0 ～ 255 ) を指定します。負の数の指定は face が dfAlpha の場合のみに有効で、
	 * 				この場合は文字の形に不透明度が取り除かれる事になります ( 値が小さいほど
	 * 				効果が大きくなります )。
	 * @param aa アンチエイリアスを行うかどうかを指定します。真を指定するとアンチエイリアスが行われます。偽を指定すると行われません。
	 * @param shadowlevel 影の不透明度を指定します。shadowwidth 引数の値によって適切な値は変動します。0 を指定すると影は描画されません。
	 * @param shadowcolor 影の色を 0xRRGGBB 形式で指定します。
	 * @param shadowwidth 影の幅 ( ぼけ ) を指定します。 0 がもっともシャープ ( ぼけない ) で、値を大きく
	 * 				すると影をぼかすことができます。
	 * @param shadowofsx 影の位置の x 座標の値をピクセル単位で指定します。 0 を指定すると影は真下に描画されます。
	 * @param shadowofsy 影の位置の y 座標の値をピクセル単位で指定します。 0 を指定すると影は真下に描画されます。
	 * @description レイヤ にグリフを描画します。グリフは、glyph : Array[9] = [ width, height, originx, originy, incx, incy, inc, bitmap(Octet), colors ] の様な形式の配列を指定します。グリフの colors が省略された場合は、256階調であると判断されます。
	 */
	function drawGlyph( x, y, glyph, color, opa=255, aa=true, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0);

	/**
	 * 矩形コピー
	 *
	 * @param dleft コピー先の矩形の左端位置を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dtop コピー先の矩形の上端位置を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param src コピー元のレイヤオブジェクトを指定します。Bitmap クラスのオブジェクトも指定可能です。(1.1.0以降)
	 * @param sleft コピーする矩形の左端位置を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param stop コピーする矩形の上端位置を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param swidth コピーする矩形の横幅を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param sheight コピーする矩形の縦幅を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @description 指定されたコピー元レイヤの矩形部分を自分のレイヤの指定位置にコピーします。コピーされる画像は、コピー先レイヤ ( メソッドを実行するレイヤ  ) の
	 * 		Layer.face プロパティの値によって変わります。dfAlpha (または dfBoth)     : メイン画像とマスク画像がコピーされますdfAddAlpha              : メイン画像とマスク画像がコピーされますdfOpaque (または dfMain)    : Layer.holdAlpha プロパティが真の場合は、メイン画像のみがコピーされます ( マスク画像はコピーされません )。偽の場合はメイン画像とマスク画像がコピーされますdfMask                  : マスク画像のみがコピーされます ( メイン画像はコピーされません )dfProvince              : 領域画像のみがコピーされます ( マスク画像やメイン画像はコピーされません )コピー元のレイヤの Layer.face プロパティは無視されます。このメソッドは、Layer.holdAlpha の影響は受けません (dfAlpha や dfAddAlpha の場合は holdAlpha に関わらずマスク画像もコピーされます)
	 */
	function copyRect( dleft, dtop, src, sleft, stop, swidth, sheight);

	/**
	 * 9 path を利用した画像コピー(1.3.0以降)
	 *
	 * @param src コピー元のレイヤオブジェクトを指定します。Bitmapクラスのオブジェクトも指定可能です。
	 * @return マージン情報
	 * @description 9 path ( slice ) を利用した画像コピーを行います。返されるマージン情報はRectクラスのオブジェクトです。
	 */
	function copy9Patch( src);

	/**
	 * レイヤを重ね合わせた画像をコピー
	 *
	 * @param dleft コピー先の矩形の左端位置を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dtop コピー先の矩形の上端位置を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param src コピー元のレイヤオブジェクトを指定します。
	 * @param sleft コピーする矩形の左端位置を ( コピー元レイヤの表示位置における ) ピクセル単位で指定します。
	 * @param stop コピーする矩形の上端位置を ( コピー元レイヤの表示位置における ) ピクセル単位で指定します。
	 * @param swidth コピーする矩形の横幅を ( コピー元レイヤの表示位置における ) ピクセル単位で指定します。
	 * @param sheight コピーする矩形の縦幅を ( コピー元レイヤの表示位置における ) ピクセル単位で指定します。
	 * @description 指定されたコピー元レイヤの指定された矩形部分を、子レイヤも含めて重ね合わせ、その
	 * 		結果の画像を、自分のレイヤの指定位置にコピーします。このメソッドは、コピー元レイヤやコピー先レイヤの Layer.face プロパティには
	 * 		影響されません。
	 * 	
	 */
	function piledCopy( dleft, dtop, src, sleft, stop, swidth, sheight);

	/**
	 * 矩形演算合成
	 *
	 * @param dleft 演算先の矩形の左端位置を ( 演算先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dtop 演算先の矩形の上端位置を ( 演算先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param src 演算元のレイヤオブジェクトを指定します。Bitmap クラスのオブジェクトも指定可能です。(1.1.0以降)
	 * @param sleft 演算する矩形の左端位置を ( 演算元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param stop 演算する矩形の上端位置を ( 演算元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param swidth 演算する矩形の横幅を ( 演算元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param sheight 演算する矩形の縦幅を ( 演算元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param mode 演算のモードを指定します。omAuto が指定された場合は演算元レイヤのLayer.typeプロパティに従って演算の種類が自動的に決定されます。omPsNormal が指定された場合はPhotoshop互換のアルファ合成が行われます。omPsAdditive が指定された場合はPhotoshop互換の覆い焼き(リニア)合成が行われます。omPsSubtractive が指定された場合はPhotoshop互換の焼き込み(リニア)合成が行われます。omPsMultiplicative が指定された場合はPhotoshop互換の乗算合成が行われます。omPsScreen が指定された場合はPhotoshop互換のスクリーン合成が行われます。omPsOverlay が指定された場合はPhotoshop互換のオーバーレイ合成が行われます。omPsHardLight が指定された場合はPhotoshop互換のハードライト合成が行われます。omPsSoftLight が指定された場合はPhotoshop互換のソフトライト合成が行われます。omPsColorDodge が指定された場合はPhotoshop互換の覆い焼きカラー合成が行われます。omPsColorDodge5 が指定された場合はPhotoshopのバージョン5.x 以下と互換の覆い焼きカラー合成が行われます。omPsColorBurn が指定された場合はPhotoshop互換の焼き込みカラー合成が行われます。omPsLighten が指定された場合はPhotoshop互換の比較(明)合成が行われます。omPsDarken が指定された場合はPhotoshop互換の比較(暗)合成が行われます。omPsDifference が指定された場合はPhotoshop互換の差の絶対値合成が行われます。omPsDifference5 が指定された場合はPhotoshopのバージョン 5.x 以下と互換の差の絶対値合成が行われます。omPsExclusion が指定された場合はPhotoshop互換の除外合成が行われます。omAdditive が指定された場合は加算合成が行われます。omSubtractive が指定された場合は減算合成が行われます。omMultiplicative が指定された場合は乗算合成が行われます。omDodge が指定された場合は覆い焼き合成が行われます。omDarken が指定された場合は比較(暗)合成が行われます。omLighten が指定された場合は比較(明)合成が行われます。omScreen が指定された場合はスクリーン乗算合成が行われます。omAlpha が指定された場合はアルファ合成が行われます。omAddAlpha が指定された場合は加算アルファ合成が行われます。omOpaque が指定された場合は src のアルファ情報は無視され、src は常に完全不透明であると見なされます。
	 * @param opa 演算の強度 ( 0 ～ 255 ) を指定します。
	 * @description 指定された演算元レイヤの矩形部分を自分のレイヤの指定位置に指定のモードで演算合成します。演算先の ( メソッドを実行する ) レイヤや演算元のレイヤの Layer.face プロパティの値
	 * 		は無視されます。mode に omAuto を指定した場合は、演算元レイヤのLayer.typeプロパティに従って演算の種類が自動的に決定されます。
	 */
	function operateRect( dleft, dtop, src, sleft, stop, swidth, sheight, mode=omAuto, opa=255);

	/**
	 * 拡大縮小コピー
	 *
	 * @param dleft コピー先の矩形の左端位置を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dtop コピー先の矩形の上端位置を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dwidth コピー先の矩形の横幅を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dheight コピー先の矩形の縦幅を ( コピー先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param src コピー元のレイヤオブジェクトを指定します。Bitmap クラスのオブジェクトも指定可能です。(1.1.0以降)
	 * @param sleft コピーする矩形の左端位置を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param stop コピーする矩形の上端位置を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param swidth コピーする矩形の横幅を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param sheight コピーする矩形の縦幅を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param type 拡大縮小のタイプを指定します。stNearest           : 最近傍点法が用いられますstFastLinear        : 低精度の線形補間が用いられます(一部実装)stSemiFastLinear    : 固定小数線形補間が用いられます(1.3以降)stLinear            : 線形補間が用いられます(1.3以降実装変更)stFastCubic         : 固定小数３次元補間が用いられます(1.3以降)stCubic             : ３次元補間が用いられます(1.3以降実装変更)stFastLanczos2      : 固定小数Lanczos補間の範囲4x4が用いられます(1.3以降)stLanczos2          : Lanczos補間の範囲4x4が用いられます(1.3以降)stFastLanczos3      : 固定小数Lanczos補間の範囲6x6が用いられます(1.3以降)stLanczos3          : Lanczos補間の範囲6x6が用いられます(1.3以降)stFastSpline16      : 固定小数スプライン補間4x4が用いられます(1.3以降)stSpline16          : スプライン補間4x4が用いられます(1.3以降)stFastSpline36      : 固定小数スプライン補間6x6が用いられます(1.3以降)stSpline36          : スプライン補間6x6が用いられます(1.3以降)stFastAreaAvg       : 固定小数面積平均縮小が用いられます。拡大は出来ません(1.3以降)stAreaAvg           : 面積平均縮小が用いられます。拡大は出来ません(1.3以降)stFastGaussian      : 固定小数ガウス補間4x4が用いられます(1.3以降)stGaussian          : ガウス補間4x4が用いられます(1.3以降)stFastBlackmanSinc  : 固定小数Blackman-Sinc補間8x8が用いられます(1.3以降)stBlackmanSinc      : Blackman-Sinc補間8x8が用いられます(1.3以降)速度は stNearest > stFastLinear > stLinear > stCubic の順に高速ですが、画質は速度が
	 * 				速ければ速いタイプほど低画質になります。stCubic 以降の補間方法は十分高画質で好みの差とも言えます。ただし、ガウス補間についてはぼやけたような画質になります。stFastLinear と他の線形補間(stSemiFastLinear と stLinear)の差は縮小時に大きく出ます。stFastLinear は、常に周囲4画素を参照するのに対して、stSemiFastLinear、stLinear は、縮小時は
	 * 				等倍時の影響範囲が4画素となるような範囲、つまりより広い範囲の画素を参照し補間するためより高画質です
	 * 				(アルゴリズム的には本来の線形補間です)。stFastLinear に対しては、stRefNoClip をビット論理和で追加指定することができ、この場合は、
	 * 				　コピーするビットマップの領域外を参照して色を合成することを許可します。これを指定しない場合は、
	 * 				　転送元ビットマップの周囲に余裕があったとしても、転送元ビットマップの範囲外を参照することは
	 * 				　ありません(範囲外の色はもっとも近い位置にある範囲内のピクセルの色と見なされます)。
	 * @param option 1.3以降で追加されました。３次元補間時のシャープネスです。他の補間方法では現在のところ意味を持ちません。シャープネスの値をプラス方向に大きくするとぼやけていき、マイナス方向に大きくしていくとシャープになっていきます。
	 * @description 指定されたコピー元レイヤの矩形を、コピー先 ( メソッドを実行するレイヤ ) の矩形に
	 * 		コピーします。コピー元矩形とコピー先矩形のサイズが異なる場合は拡大または縮小が
	 * 		行われます。現バージョンでは stFastLinear の指定で線形補間が効くのは、重ね合わせ先の ( メソッドを実行する ) レイヤの Layer.face プロパティが dfAlpha (または dfBoth) または dfAddAlpha の場合です。また、Layer.face プロパティが dfOpaque で、Layer.holdAlpha プロパティが偽の時も線形補間が可能です。また、現バージョンでは stLinear あるいは stCubic の指定が有効なのは、左右／上下反転を
	 * 		伴わず、コピー先矩形がレイヤをはみ出さない場合のみです。重ね合わせ先の ( メソッドを実行する ) レイヤの Layer.face プロパティが
	 * 		dfAlpha (または dfBoth) または dfAddAlpha の場合は、メイン画像とマスク画像の両方がコピーされます。dfOpaque (または dfMain) の場合は、Layer.holdAlpha プロパティが真の時はメイン画像のみがコピーされ、偽の時はメイン画像とマスク画像の両方がコピーされます。
	 */
	function stretchCopy( dleft, dtop, dwidth, dheight, src, sleft, stop, swidth, sheight, type=stNearest, option=-1.0);

	/**
	 * 拡大縮小演算合成
	 *
	 * @param dleft 重ね合わせ先の矩形の左端位置を ( 重ね合わせ先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dtop 重ね合わせ先の矩形の上端位置を ( 重ね合わせ先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dwidth 重ね合わせ先の矩形の横幅を ( 重ね合わせ先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param dheight 重ね合わせ先の矩形の縦幅を ( 重ね合わせ先レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param src 重ね合わせ元のレイヤオブジェクトを指定します。Bitmap クラスのオブジェクトも指定可能です。(1.1.0以降)
	 * @param sleft 重ね合わせる矩形の左端位置を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param stop 重ね合わせる矩形の上端位置を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param swidth 重ね合わせる矩形の横幅を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param sheight 重ね合わせる矩形の縦幅を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param mode 演算のモードを指定します。omAuto が指定された場合は演算元レイヤのLayer.typeプロパティに従って演算の種類が自動的に決定されます。omPsNormal が指定された場合はPhotoshop互換のアルファ合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsAdditive が指定された場合はPhotoshop互換の覆い焼き(リニア)合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsSubtractive が指定された場合はPhotoshop互換の焼き込み(リニア)合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsMultiplicative が指定された場合はPhotoshop互換の乗算合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsScreen が指定された場合はPhotoshop互換のスクリーン合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsOverlay が指定された場合はPhotoshop互換のオーバーレイ合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsHardLight が指定された場合はPhotoshop互換のハードライト合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsSoftLight が指定された場合はPhotoshop互換のソフトライト合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsColorDodge が指定された場合はPhotoshop互換の覆い焼きカラー合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsColorDodge5 が指定された場合はPhotoshopのバージョン5.x 以下と互換の覆い焼きカラー合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsColorBurn が指定された場合はPhotoshop互換の焼き込みカラー合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsLighten が指定された場合はPhotoshop互換の比較(明)合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsDarken が指定された場合はPhotoshop互換の比較(暗)合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsDifference が指定された場合はPhotoshop互換の差の絶対値合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsDifference5 が指定された場合はPhotoshopのバージョン 5.x 以下と互換の差の絶対値合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omPsExclusion が指定された場合はPhotoshop互換の除外合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omAdditive が指定された場合は加算合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omSubtractive が指定された場合は減算合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omMultiplicative が指定された場合は乗算合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omDodge が指定された場合は覆い焼き合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omDarken が指定された場合は比較(暗)合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omLighten が指定された場合は比較(明)合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omScreen が指定された場合はスクリーン乗算合成が行われます(1.3以降ではstNearestとstFastLinear以外で実装)。omAlpha が指定された場合はアルファ合成が行われます。omAddAlpha が指定された場合は加算アルファ合成が行われます。この場合は、転送先の Layer.face プロパティが dfOpaque かつ Layer.holdAlpha プロパティが偽のとき、type 引数に stFastLinear を指定することにより線形補間が可能です。omOpaque が指定された場合は src のアルファ情報は無視され、src は常に完全不透明であると見なされます。この場合は、転送先の Layer.face プロパティが dfOpaque かつ Layer.holdAlpha プロパティが偽のとき、type 引数に stFastLinear を指定することにより線形補間が可能です。
	 * @param opa 演算の強度 ( 0 ～ 255 ) を指定します。
	 * @param type 拡大縮小のタイプを指定します。stNearest           : 最近傍点法が用いられますstFastLinear        : 低精度の線形補間が用いられます(一部実装)stSemiFastLinear    : 固定小数線形補間が用いられます(1.3以降)stLinear            : 線形補間が用いられます(1.3以降実装変更)stFastCubic         : 固定小数３次元補間が用いられます(1.3以降)stCubic             : ３次元補間が用いられます(1.3以降実装変更)stFastLanczos2      : 固定小数Lanczos補間の範囲4x4が用いられます(1.3以降)stLanczos2          : Lanczos補間の範囲4x4が用いられます(1.3以降)stFastLanczos3      : 固定小数Lanczos補間の範囲6x6が用いられます(1.3以降)stLanczos3          : Lanczos補間の範囲6x6が用いられます(1.3以降)stFastSpline16      : 固定小数スプライン補間4x4が用いられます(1.3以降)stSpline16          : スプライン補間4x4が用いられます(1.3以降)stFastSpline36      : 固定小数スプライン補間6x6が用いられます(1.3以降)stSpline36          : スプライン補間6x6が用いられます(1.3以降)stFastAreaAvg       : 固定小数面積平均縮小が用いられます。拡大は出来ません(1.3以降)stAreaAvg           : 面積平均縮小が用いられます。拡大は出来ません(1.3以降)stFastGaussian      : 固定小数ガウス補間4x4が用いられます(1.3以降)stGaussian          : ガウス補間4x4が用いられます(1.3以降)stFastBlackmanSinc  : 固定小数Blackman-Sinc補間8x8が用いられます(1.3以降)stBlackmanSinc      : Blackman-Sinc補間8x8が用いられます(1.3以降)速度は stNearest > stFastLinear > stLinear > stCubic の順に高速ですが、画質は速度が
	 * 				速ければ速いタイプほど低画質になります。stCubic 以降の補間方法は十分高画質で好みの差とも言えます。ただし、ガウス補間についてはぼやけたような画質になります。stFastLinear と他の線形補間(stSemiFastLinear と stLinear)の差は縮小時に大きく出ます。stFastLinear は、常に周囲4画素を参照するのに対して、stSemiFastLinear、stLinear は、縮小時は
	 * 				等倍時の影響範囲が4画素となるような範囲、つまりより広い範囲の画素を参照し補間するためより高画質です
	 * 				(アルゴリズム的には本来の線形補間です)。stFastLinear に対しては、stRefNoClip をビット論理和で追加指定することができ、この場合は、
	 * 				　コピーするビットマップの領域外を参照して色を合成することを許可します。これを指定しない場合は、
	 * 				　転送元ビットマップの周囲に余裕があったとしても、転送元ビットマップの範囲外を参照することは
	 * 				　ありません(範囲外の色はもっとも近い位置にある範囲内のピクセルの色と見なされます)。
	 * @param option 1.3以降で追加されました。３次元補間時のシャープネスです。他の補間方法では現在のところ意味を持ちません。シャープネスの値をプラス方向に大きくするとぼやけていき、マイナス方向に大きくしていくとシャープになっていきます。
	 * @description 指定された重ね合わせ元レイヤの矩形を、重ね合わせ先 ( メソッドを実行するレイヤ ) の矩形に
	 * 		演算合成します。重ね合わせ元矩形と重ね合わせ先矩形のサイズが異なる場合は拡大または縮小が行われます。mode に omAuto を指定した場合は、演算元レイヤのLayer.typeプロパティに従って演算の種類が自動的に決定されます。
	 */
	function operateStretch( dleft, dtop, dwidth, dheight, src, sleft, stop, swidth, sheight, mode=omAuto, opa=255, type=stNearest, option=-1.0);

	/**
	 * アフィン変換コピー
	 *
	 * @param src コピー元のレイヤオブジェクトを指定します。Bitmap クラスのオブジェクトも指定可能です。(1.1.0以降)
	 * @param sleft コピーする矩形の左端位置を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param stop コピーする矩形の上端位置を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param swidth コピーする矩形の横幅を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param sheight コピーする矩形の縦幅を ( コピー元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param affine 続く６つの引数 (A ～ F パラメータ)をどのように扱うかを指定します。真を指定すると、６つのパラメータはそれぞれ以下のように解釈されます。A   : 2Dアフィン変換行列の aB   : 2Dアフィン変換行列の bC   : 2Dアフィン変換行列の cD   : 2Dアフィン変換行列の dE   : 2Dアフィン変換行列の txF   : 2Dアフィン変換行列の tyアフィン変換により、コピー元の画像位置 (x, y) ( ただし、コピー元矩形の左上隅を (0, 0) とする ) は以下の式により、コピー先の画像位置 (x', y')に変換されます。x' =  a*x + c*y + txy' =  b*x + d*y + ty偽を指定すると、６つのパラメータはそれぞれ以下のように解釈されます。これらのパラメータは実数での指定も受け付けます。A   : コピー元矩形の左上隅の点の、コピー先での画像位置における X 座標位置(x0)B   : コピー元矩形の左上隅の点の、コピー先での画像位置における Y 座標位置(y0)C   : コピー元矩形の右上隅の点の、コピー先での画像位置における X 座標位置(x1)D   : コピー元矩形の右上隅の点の、コピー先での画像位置における Y 座標位置(y1)E   : コピー元矩形の左下隅の点の、コピー先での画像位置における X 座標位置(x2)F   : コピー元矩形の左下隅の点の、コピー先での画像位置における Y 座標位置(y2)偽を指定した場合、コピー元の右下隅に対応する、コピー先位置(x3, y3)は自動的に以下の式によって計算されます。x3 = x1 - x0 + x2y3 = y1 - y0 + y2
	 * @param A A パラメータです。affine 引数によって解釈が変わります。
	 * @param B B パラメータです。affine 引数によって解釈が変わります。
	 * @param C C パラメータです。affine 引数によって解釈が変わります。
	 * @param D D パラメータです。affine 引数によって解釈が変わります。
	 * @param E E パラメータです。affine 引数によって解釈が変わります。
	 * @param F F パラメータです。affine 引数によって解釈が変わります。
	 * @param type アフィン変換のタイプを指定します。stNearest     : 最近傍点法が用いられますstFastLinear  : 低精度の線形補間が用いられます(一部実装)stLinear      : 線形補間が用いられます(未実装)stCubic       : ３次元補間が用いられます(未実装)stFastLinear や stLinear, stCubic に対しては、stRefNoClip をビット論理和で追加指定
	 * 				することができ、この場合は、コピーするビットマップの領域外を参照して色を合成することを
	 * 				許可します。これを指定しない場合は、転送元ビットマップの周囲に余裕があったとしても、
	 * 				転送元ビットマップの範囲外を参照することはありません(範囲外の色はもっとも近い位置にある
	 * 				範囲内のピクセルの色と見なされます)。
	 * @param clear 転送先レイヤの、アフィン変換された画像の周囲をLayer.neutralColor プロパティで示された色・透明度でクリアするかどうかを指定します。真を指定するとクリアされ、この引数を省略するか偽を渡すとクリアされません。クリアされる領域は Layer.setClip メソッドで制限することもできます。このクリアの機能を使うと、いったん転送先レイヤをクリアしてからアフィン変換で画像を上書き転送する際の、上書きされる領域(クリアされた場所にアフィン変換で上書きされる部分)のクリアの無駄を省くことができます。
	 * @description 指定されたコピー元レイヤの矩形を、コピー先 ( メソッドを実行するレイヤ ) に
	 * 		アフィン変換を行いながらコピーします。affine 引数によって、変形パラメータとして二次元アフィン変換行列を指定するか、
	 * 		あるいは変換後の点を直接指定するかを選ぶことができます。現バージョンでは stFastLinear の指定で線形補間が効くのは、重ね合わせ先の ( メソッドを実行する ) レイヤの Layer.face プロパティが dfAlpha (または dfBoth) または dfAddAlpha の場合です。また、Layer.face プロパティが dfOpaque で、Layer.holdAlpha プロパティが偽の時も線形補間が可能です。重ね合わせ先の ( メソッドを実行する ) レイヤの Layer.face プロパティが
	 * 		dfAlpha (または dfBoth) または dfAddAlpha の場合は、メイン画像とマスク画像の両方がコピーされます。重ね合わせ先の ( メソッドを実行する ) レイヤの Layer.face プロパティが
	 * 		dfOpaque (または dfMain) の場合は、Layer.holdAlpha プロパティが真の時はメイン画像のみがコピーされ、偽の時はメイン画像とマスク画像の両方がコピーされます。二次元アフィン変換行列による変換は、コピー元矩形の左上を原点 (0, 0) とし、
	 * 		以下のように定義されます。二次元アフィン変換を行うことにより、拡大縮小、回転、せん断(傾け)、平行移動、反転、あるいはこれらの組み合わせすべての変形を行うことができます。二次元アフィン変換を行うメソッドでは、二次元アフィン行列ではなく、変換後の各頂点を直接指定することでも変形を指定できますが、この場合でも二次元アフィン変換で定義できないような変形は行うことはできません。アフィン変換においては、ピクセルは 1.0 × 1.0 のサイズを持っていると見なされます。つまり、(0, 0) の位置にあるピクセルは (-0.5, -0.5) - (0.5, 0.5) の範囲にあると見なされます。
	 */
	function affineCopy( src, sleft, stop, swidth, sheight, affine, A, B, C, D, E, F, type=stNearest, clear=false);

	/**
	 * アフィン変換演算合成
	 *
	 * @param src 重ね合わせ元のレイヤオブジェクトを指定します。Bitmap クラスのオブジェクトも指定可能です。(1.1.0以降)
	 * @param sleft 重ね合わせる矩形の左端位置を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param stop 重ね合わせる矩形の上端位置を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param swidth 重ね合わせる矩形の横幅を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param sheight 重ね合わせる矩形の縦幅を ( 重ね合わせ元レイヤの画像位置における ) ピクセル単位で指定します。
	 * @param affine 続く６つの引数 (A ～ F パラメータ)をどのように扱うかを指定します。真を指定すると、６つのパラメータはそれぞれ以下のように解釈されます。A   : 2Dアフィン変換行列の aB   : 2Dアフィン変換行列の bC   : 2Dアフィン変換行列の cD   : 2Dアフィン変換行列の dE   : 2Dアフィン変換行列の txF   : 2Dアフィン変換行列の tyアフィン変換により、重ね合わせ元の画像位置 (x, y) ( ただし、重ね合わせ元矩形の左上隅を (0, 0) とする ) は以下の式により、重ね合わせ先の画像位置 (x', y')に変換されます。x' =  a*x + c*y + txy' =  b*x + d*y + ty偽を指定すると、６つのパラメータはそれぞれ以下のように解釈されます。A   : コピー元矩形の左上隅の点の、コピー先での画像位置における X 座標位置(x0)B   : コピー元矩形の左上隅の点の、コピー先での画像位置における Y 座標位置(y0)C   : コピー元矩形の右上隅の点の、コピー先での画像位置における X 座標位置(x1)D   : コピー元矩形の右上隅の点の、コピー先での画像位置における Y 座標位置(y1)E   : コピー元矩形の左下隅の点の、コピー先での画像位置における X 座標位置(x2)F   : コピー元矩形の左下隅の点の、コピー先での画像位置における Y 座標位置(y2)偽を指定した場合、重ね合わせ元の右下隅に対応する、重ね合わせ先位置(x3, y3)は自動的に以下の式によって計算されます。x3 = x1 - x0 + x2y3 = y1 - y0 + y2
	 * @param A A パラメータです。affine 引数によって解釈が変わります。
	 * @param B B パラメータです。affine 引数によって解釈が変わります。
	 * @param C C パラメータです。affine 引数によって解釈が変わります。
	 * @param D D パラメータです。affine 引数によって解釈が変わります。
	 * @param E E パラメータです。affine 引数によって解釈が変わります。
	 * @param F F パラメータです。affine 引数によって解釈が変わります。
	 * @param mode 演算のモードを指定します。omAuto が指定された場合は演算元レイヤのLayer.typeプロパティに従って演算の種類が自動的に決定されます。omPsNormal が指定された場合はPhotoshop互換のアルファ合成が行われます(現バージョンでは未実装です)。omPsAdditive が指定された場合はPhotoshop互換の覆い焼き(リニア)合成が行われます(現バージョンでは未実装です)。omPsSubtractive が指定された場合はPhotoshop互換の焼き込み(リニア)合成が行われます(現バージョンでは未実装です)。omPsMultiplicative が指定された場合はPhotoshop互換の乗算合成が行われます(現バージョンでは未実装です)。omPsScreen が指定された場合はPhotoshop互換のスクリーン合成が行われます(現バージョンでは未実装です)。omPsOverlay が指定された場合はPhotoshop互換のオーバーレイ合成が行われます(現バージョンでは未実装です)。omPsHardLight が指定された場合はPhotoshop互換のハードライト合成が行われます(現バージョンでは未実装です)。omPsSoftLight が指定された場合はPhotoshop互換のソフトライト合成が行われます(現バージョンでは未実装です)。omPsColorDodge が指定された場合はPhotoshop互換の覆い焼きカラー合成が行われます(現バージョンでは未実装です)。omPsColorDodge5 が指定された場合はPhotoshopのバージョン5.x 以下と互換の覆い焼きカラー合成が行われます(現バージョンでは未実装です)。omPsColorBurn が指定された場合はPhotoshop互換の焼き込みカラー合成が行われます(現バージョンでは未実装です)。omPsLighten が指定された場合はPhotoshop互換の比較(明)合成が行われます(現バージョンでは未実装です)。omPsDarken が指定された場合はPhotoshop互換の比較(暗)合成が行われます(現バージョンでは未実装です)。omPsDifference が指定された場合はPhotoshop互換の差の絶対値合成が行われます(現バージョンでは未実装です)。omPsDifference5 が指定された場合はPhotoshopのバージョン 5.x 以下と互換の差の絶対値合成が行われます(現バージョンでは未実装です)。omPsExclusion が指定された場合はPhotoshop互換の除外合成が行われます(現バージョンでは未実装です)。omAdditive が指定された場合は加算合成が行われます(現バージョンでは未実装です)。omSubtractive が指定された場合は減算合成が行われます(現バージョンでは未実装です)。omMultiplicative が指定された場合は乗算合成が行われます(現バージョンでは未実装です)。omDodge が指定された場合は覆い焼き合成が行われます(現バージョンでは未実装です)。omDarken が指定された場合は比較(暗)合成が行われます(現バージョンでは未実装です)。omLighten が指定された場合は比較(明)合成が行われます(現バージョンでは未実装です)。omScreen が指定された場合はスクリーン乗算合成が行われます(現バージョンでは未実装です)。omAlpha が指定された場合はアルファ合成が行われます。omAddAlpha が指定された場合は加算アルファ合成が行われます。この場合は、転送先の Layer.face プロパティが dfOpaque かつ Layer.holdAlpha プロパティが偽のとき、type 引数に stFastLinear を指定することにより線形補間が可能です。omOpaque が指定された場合は src のアルファ情報は無視され、src は常に完全不透明であると見なされます。この場合は、転送先の Layer.face プロパティが dfOpaque かつ Layer.holdAlpha プロパティが偽のとき、type 引数に stFastLinear を指定することにより線形補間が可能です。
	 * @param opa 重ね合わせの不透明度 ( 0 ～ 255 ) を指定します。
	 * @param type アフィン変換のタイプを指定します。stNearest     : 最近傍点法が用いられますstFastLinear  : 低精度の線形補間が用いられます(一部実装)stLinear      : 線形補間が用いられます(未実装)stCubic       : ３次元補間が用いられます(未実装)速度は stNearest > stFastLinear > stLinear > stCubic の順に高速ですが、画質は速度が
	 * 				速ければ速いモードほど低画質になります。stFastLinear や stLinear, stCubic に対しては、stRefNoClip をビット論理和で追加指定
	 * 				することができ、この場合は、コピーするビットマップの領域外を参照して色を合成することを
	 * 				許可します。これを指定しない場合は、転送元ビットマップの周囲に余裕があったとしても、
	 * 				転送元ビットマップの範囲外を参照することはありません(範囲外の色はもっとも近い位置にある
	 * 				範囲内のピクセルの色と見なされます)。
	 * @description 指定された重ね合わせ元レイヤの矩形を、重ね合わせ先 ( メソッドを実行するレイヤ ) に
	 * 		アフィン変換を行いながら演算合成します。アフィン変換については Layer.affineCopy も参照してください。mode に omAuto を指定した場合は、演算元レイヤのLayer.typeプロパティに従って演算の種類が自動的に決定されます。
	 */
	function operateAffine( src, sleft, stop, swidth, sheight, affine, A, B, C, D, E, F, mode=omAuto, opa=255, type=stNearest);

	/**
	 * 矩形ブラーをかける
	 *
	 * @param xblur 横方向のブラーの範囲を指定します。
	 * 			
	 * @param yblur 縦方向のブラーの範囲を指定します。
	 * 			
	 * @description ブラー(ぼかし)をかけます。アルゴリズムは「矩形ブラー」(box blur)です。矩形ブラーは、xblurとyblurの２つのパラメータによって表現される「範囲」中のピクセルの輝度の平均値をとる物です。たとえば xblur=10 yblur=2 の場合は、対象のピクセルを中心に、横方向は -10～10、縦方向は -2～2 の矩形範囲のピクセルの輝度の平均をとり、それが最終的なそのピクセルの輝度となります。範囲の面積は (xblur×2+1) × (yblur×2+1) で計算することができます。現バージョンではこの面積が 256 未満 の場合は、面積が256以上の場合よりも高速なアルゴリズムが採用されます。Layer.face プロパティが dfAlpha の場合は、アルファ合成用の特別なアルゴリズムを使用しますので、少々遅くなります。dfAddAlpha や他の描画方式の場合は、より高速なアルゴリズムとなります。
	 */
	function doBoxBlur( xblur=1, yblur=1);

	/**
	 * ガンマ補正
	 *
	 * @param rgamma 赤成分のガンマ値 ( 0.0 ～ 1.0 ～ 9.0 ) を指定します。
	 * @param rfloor 赤成分の出力最低値 ( 0 ～ 255 ) を指定します。
	 * @param rceil 赤成分の出力最大値 ( 0 ～ 255 ) を指定します。
	 * @param ggamma 緑成分のガンマ値 ( 0.0 ～ 1.0 ～ 9.0 ) を指定します。
	 * @param gfloor 緑成分の出力最低値 ( 0 ～ 255 ) を指定します。
	 * @param gceil 緑成分の出力最大値 ( 0 ～ 255 ) を指定します。
	 * @param bgamma 青成分のガンマ値 ( 0.0 ～ 1.0 ～ 9.0 ) を指定します。
	 * @param bfloor 青成分の出力最低値 ( 0 ～ 255 ) を指定します。
	 * @param bceil 青成分の出力最大値 ( 0 ～ 255 ) を指定します。
	 * @description 画像に対してガンマ補正を実行します。ガンマ値には 1.0 を指定するとガンマ曲線が直線になります。出力最低値と出力最高値は各成分の輝度の最低値と最高値を指定するものです。最高値に最低値よりも低い値を設定すると画像を反転させることができます。このメソッドはLayer.faceプロパティを参照します。これが dfAddAlpha の場合、このメソッドは
	 * 		加算アルファ合成用の特別なガンマ補正ルーチンを用います。このルーチンは加算アルファ合成のうち、アルファ合成に相当する成分に対してはガンマ補正を行いますが、加算合成に相当する成分に対してはガンマ補正を行いません。
	 */
	function adjustGamma( rgamma=1.0, rfloor=0, rceil=255, ggamma=1.0, gfloor=0, gceil=255, bgamma=1.0, bfloor=0, bceil=255);

	/**
	 * グレースケール変換
	 *
	 * @description 画像をグレースケールに変換します。
	 */
	function doGrayScale( );

	/**
	 * 左右反転
	 *
	 * @description 画像の左右反転を行います。このメソッドは、Layer.setClip メソッドなどによる描画クリップ矩形の影響を受けません ( 常にレイヤ画像全体が反転します )。また、Layer.face プロパティやLayer.holdAlpha プロパティの影響も受けません。
	 */
	function flipLR( );

	/**
	 * 上下反転
	 *
	 * @description 画像の上下反転を行います。このメソッドは、Layer.setClip メソッドなどによる描画クリップ矩形の影響を受けません ( 常にレイヤ画像全体が反転します )。また、Layer.face プロパティやLayer.holdAlpha プロパティの影響も受けません。
	 */
	function flipUD( );

	/**
	 * レイヤ画像表現形式の変換
	 *
	 * @param from 変換元となる描画方式タイプを指定します。
	 * 			
	 * @description レイヤ画像の形式を変換します。このメソッドは、ltAlpha (dfAlpha) と ltAddAlpha (dfAddAlpha) のように、「レイヤの画像表現形式が異なるが同様の表現が可能なタイプ」間での画像表現形式の変換を行います。たとえば、ltAlpha で表示しているレイヤのタイプをそのまま ltAddAlpha に変更しただけでは、アルファチャンネルと色情報の扱いが異なるので正常に表示されません。そのため、このメソッドを用い、dfAlpha から dfAddAlpha に変換を行う必要があります。このメソッドでは、変換先の画像表現形式は Layer.face プロパティで指定した描画方式に対応した形式になります (Layer.typeで指定するレイヤタイプではなくて、描画方式であることに注意してください )。from 引数には、変換元の画像表現形式に対応する描画方式(dfで始まる定数; Layer.face参照)を指定します。from 引数には dfAuto は指定できません。現在サポートされている変換は、dfAlpha→dfAddAlpha と dfAddAlpha→dfAlpha の変換です。dfAddAlpha→dfAlphaでは、変換により色情報が失われる場合があります。このメソッドは、描画クリップ矩形の影響を受けません ( 常にレイヤ画像全体が影響を受けます )。
	 */
	function convertType( from);

	/**
	 * 画像の更新
	 *
	 * @param left 更新する矩形の左端位置を表示座標におけるピクセル単位で指定します。
	 * @param top 更新する矩形の上端位置を表示座標におけるピクセル単位で指定します。
	 * @param width 更新する矩形の横幅を表示座標におけるピクセル単位で指定します。
	 * @param height 更新する矩形の縦幅を表示座標におけるピクセル単位で指定します。
	 * @description このメソッドはレイヤを強制的に画面に描画させます。描画系のメソッドなどを実行すると自動的に画面更新が発生しますが、
	 * 		このメソッドで画面への描画を強制的に起こさせることができます。引数をすべて省略するとレイヤ全体が再描画されます。このメソッドは、Layer.callOnPaint プロパティを真に設定します。実際に画面に描画されるまでは、何度このメソッドを実行しても画面描画が
	 * 		発生するのは１回のみです ( キャッシュされます )。
	 */
	function update( left, top, width, height);

	/**
	 * マウスカーソル位置の指定
	 *
	 * @param x マウスカーソルの ( このレイヤの表示座標における ) x 座標値をピクセル単位で指定します。この値は Layer.cursorX プロパティでも設定／取得する事ができます。
	 * @param y マウスカーソルの ( このレイヤの表示座標における ) y 座標値をピクセル単位で指定します。この値は Layer.cursorX プロパティでも設定／取得する事ができます。
	 * @description マウスカーソルの位置を指定します。
	 */
	function setCursorPos( x, y);

	/**
	 * フォーカスの設定
	 *
	 * @param direction Layer.onBeforeFocus や Layer.onFocus イベントの
	 * 				direction 引数に渡される値です。
	 * @description レイヤにフォーカスを指定します。レイヤがフォーカスを受け取ると
	 * 		キーボード入力が可能になります。
	 */
	function focus( direction=true);

	/**
	 * 前方のレイヤにフォーカスを設定
	 *
	 * @return 新たにフォーカスを得たレイヤオブジェクト
	 * @description フォーカス可能なレイヤを前方検索し、レイヤが見つかればそのレイヤにフォーカスを設定します。
	 */
	function focusPrev( );

	/**
	 * 後方のレイヤにフォーカスを設定
	 *
	 * @return 新たにフォーカスを得たレイヤオブジェクト
	 * @description フォーカス可能なレイヤを後方検索し、レイヤが見つかればそのレイヤにフォーカスを設定します。
	 */
	function focusNext( );

	/**
	 * モーダル状態にする
	 *
	 * @description レイヤにモードを設定します。モードを設定すると ( モーダルになると )、そのレイヤの子レイヤ
	 * 		のみがフォーカスやマウスメッセージを受け取ることができるようになります。
	 * 	
	 */
	function setMode( );

	/**
	 * モーダル状態を解除する
	 *
	 * @description Layer.setMode で設定したモーダル状態を解除します。
	 */
	function removeMode( );

	/**
	 * 注視位置の指定
	 *
	 * @param left 注視する ( このレイヤの表示座標における ) x 座標値をピクセル単位で指定します。この値は Layer.attentionLeft プロパティでも設定／取得する事ができます。
	 * @param top 注視する ( このレイヤの表示座標における ) x 座標値をピクセル単位で指定します。この値は Layer.attentionTop プロパティでも設定／取得する事ができます。
	 * @description 注視位置を指定します。注視位置とは通常カレット ( キーボードからの文字入力位置を
	 * 		示すためにテキストエディタなどで点滅する棒 ) の位置に設定します。IME の未確定文字はこの注視位置に
	 * 		表示されます。
	 * @see Layer.useAttention
	 */
	function setAttentionPos( left, top);

	/**
	 * トランジションの開始
	 *
	 * @param name トランジション名を指定します。デフォルトでは 'crossfade' ( クロスフェード )、'universal' ( ユニバーサルトラン
	 * 				ジション )、'scroll' ( スクロールトランジション ) が定義されています。
	 * @param withchildren 子レイヤも一緒にトランジションを行うかどうかです。真を指定すると
	 * 				子レイヤごとトランジションします。偽を指定するとメソッドを実行するレイヤのみ
	 * 				がトランジションします。
	 * @param transsrc 切り替わり先となるレイヤを指定します。トランジションによっては指定が必要ない
	 * 				もの ( 単独でトランジションするものなど ) もあるかもしれません。
	 * @param options トランジションのオプションを辞書配列で指定します。必要なオプションはトランジションの種類によって異なります。トランジションの種類に関係なく、共通して指定できるオプションとして 'selfupdate' メンバと 'callback' メンバがあります。'selfupdate' メンバが 真 の場合は、吉里吉里は自動での画面更新を行わなくなります。
	 * 				この場合は、適宜プログラム側で Layer.update メソッドなどで画面を更新しなければなりません。この機能は、トランジションによる描画とプログラムによる描画を完全に同期させたい場合に便利です。'callback' メンバにTJS2のメソッドを指定すると、
	 * 				描画が実際に行われる度にそのメソッドが呼ばれます。
	 * 				このメソッド(コールバックされるメソッド)では 'tick' 値を0以上の値で返してください。
	 * 				多くのトランジションは、ミリ秒単位での実際の時間である'tick'
	 * 				値を元にトランジションを行っていますが、
	 * 				このコールバックされるメソッドで任意のtickを返すように実装することにより、
	 * 				トランジションの効果を任意の時点で巻き戻したり、途中で早送りをしたりが可能になり、
	 * 				実際の時間に関係なくトランジションを制御できるようになります。
	 * 				多くのトランジションは、オプションの'time'
	 * 				メンバで指定した値がトランジションの終端であると見なしています。
	 * 				そのため、たとえばオプションの 'time' には 1000 等の適当な値を指定しておき、
	 * 				このコールバックされるメソッドで 1000 未満の値を返すことにより、
	 * 				任意の段階でのトランジションの表示などを行わせることができるようになります。
	 * 				また、多くのトランジションの場合、オプションの 'time' で指定された値に 'tick'
	 * 				値が達すると、トランジションが停止しますので、
	 * 				トランジションを停止させたくない場合は、 'time' で指定した値未満の値を常に
	 * 				指定するようにしてください。
	 * 			
	 * @description トランジションを開始します。children=真 の場合のトランジションは、終了するときに、transsrc で指定した
	 * 		トランジション元とそっくり親子関係のツリー構造が入れ替わります。children=偽 の場合は、トランジション元のレイヤとメソッドを実行したレイヤ ( 
	 * 		トランジション先のレイヤ ) のみが入れ替わります。どちらの場合も、ツリー構造上での入れ替えが行われるため注意してください。このメソッドはトランジションを開始させるだけですぐに戻ります。
	 */
	function beginTransition( name, withchildren=true, transsrc=null, options=%[ ]);

	/**
	 * トランジションを停止する
	 *
	 * @description 進行中のトランジションを停止します。
	 */
	function stopTransition( );

	/**
	 * 画像のコピー
	 *
	 * @param src コピー元のレイヤを指定します。
	 * @description src で指定したレイヤの、メイン画像、マスク画像、領域画像をすべてコピーします。画像サイズはコピー元のレイヤの画像サイズと同一になります。それ以外の情報はコピーしません。コピーといっても、実際は「同じ画像を二つ以上のレイヤで共有している」という状態になるだけなので
	 * 		このメソッドはほとんど実行時間がかかりません。
	 */
	function assignImages( src);

	/**
	 * 画像の保存
	 *
	 * @param name 保存するストレージ名を指定します。
	 * @param type 保存する画像形式を文字列で指定します。現バージョンでは以下の形式を指定可能です。"bmp" または "bmp32"32bpp の BMP です。アルファチャンネル(マスク)も保存します。"bmp24"24bpp の BMP です。アルファチャンネル(マスク)は保存されません。"bmp8"8bpp の BMP です。アルファチャンネル(マスク)は保存されません。画像は
	 * 					252色の固定パレットによる4×4組織化ディザリングを用いて減色されます。"jpg"JPEG です。アルファチャンネル(マスク)は保存されません。画像は
	 * 					クオリティー90%で保存されます。"jpg###"JPEG です。アルファチャンネル(マスク)は保存されません。画像は
	 * 					###で指定されたクオリティーで保存されます。"jpg010" で 10%、"jpg100" で 100%、"jpg080" で 80%です。"png"32bpp の PNG です。アルファチャンネル(マスク)も保存します。"png24"24bpp の PNG です。アルファチャンネル(マスク)は保存されません。"tlg5"32bpp の TLG5 です。アルファチャンネル(マスク)も保存します。"tlg524"24bpp の TLG5 です。アルファチャンネル(マスク)は保存されません。"tlg6"32bpp の TLG6 です。アルファチャンネル(マスク)も保存します。"tlg624"24bpp の TLG6 です。アルファチャンネル(マスク)は保存されません。
	 * @description name で指定したストレージ (ファイル) に、type で指定した画像形式でファイルを保存します。保存されるのはレイヤの画像で、領域画像は保存することはできません。
	 */
	function saveLayerImage( name, type="bmp");

	/**
	 * Bitmap への画像のコピー
	 *
	 * @param dest コピー先の Bitmap オブジェクトを指定します。
	 * @description dest で指定した Bitmap オブジェクトへレイヤのメイン画像をコピーします。画像サイズはコピー元のレイヤの画像サイズと同一になります。コピーといっても、実際は「同じ画像を二つ以上のレイヤで共有している」という状態になるだけなので
	 * 		このメソッドはほとんど実行時間がかかりません。
	 * @see Layer.copyFromBitmapToMainImage
	 */
	function copyToBitmapFromMainImage( dest);

	/**
	 * Bitmap からの画像のコピー
	 *
	 * @param src コピー元の Bitmap オブジェクトを指定します。
	 * @description src で指定した Bitmap オブジェクトからレイヤのメイン画像へ画像をコピーします。画像サイズはコピー元のBitmap オブジェクトの画像サイズと同一になります。コピーといっても、実際は「同じ画像を二つ以上のレイヤで共有している」という状態になるだけなので
	 * 		このメソッドはほとんど実行時間がかかりません。
	 * @see Layer.copyToBitmapFromMainImage
	 */
	function copyFromBitmapToMainImage( src);

	/**
	 * 親レイヤ
	 *
	 * @description 親レイヤオブジェクトを表します。値を設定することもできます。値を設定するとそのレイヤの子になります。異なるウィンドウや異なるプライマリレイヤに所属するレイヤの子になったり、自分自身や自分の子孫の
	 * 		子になることはできません。
	 */
	 property parent {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 子レイヤ配列
	 *
	 * @description 子レイヤの格納された配列オブジェクトを表します。ここで得られた配列に値を書き込んだり、項目の削除や追加などをしても実際のレイヤの状態には反映されません。読み取りのみが行えると考えてください。
	 */
	 property children {
		 getter() { return value; }
	}
	/**
	 * 相対位置
	 *
	 * @description 同じ親を持つ兄弟レイヤ間での順位を表します。値が小さいほど奥に表示されます。値を設定すると兄弟レイヤ間での順位を変えることができます。値を設定すると
	 * 		親レイヤの Layer.absoluteOrderMode プロパティが偽に設定されます。
	 * @see Layer.absolute
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToBack
	 * @see Layer.bringToFront
	 */
	 property order {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 絶対位置
	 *
	 * @description 同じ親を持つ兄弟レイヤ間での重ね合わせ順序を表します。値が小さいほど奥に表示されます。Layer.order プロパティと違い、同じ兄弟間で値は連続している必要はありません。値を設定すると兄弟レイヤ間での順位を変えることができます。値を設定すると
	 * 		親レイヤの Layer.absoluteOrderMode プロパティが真に設定されます。
	 * @see Layer.order
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToBack
	 * @see Layer.bringToFront
	 */
	 property absolute {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 絶対位置モードかどうか
	 *
	 * @description 直属の子レイヤの重ね合わせ順モードを表します。値を設定することもできます。偽を指定すると相対位置指定となり、Layer.order プロパティが
	 * 		その順位を表すようになります。真を指定すると絶対位置指定となり、Layer.absolute プロパティが
	 * 		その順位を表すようになります。
	 * @see Layer.order
	 * @see Layer.absolute
	 * @see Layer.bringToBack
	 * @see Layer.bringToFront
	 */
	 property absoluteOrderMode {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 可視かどうか
	 *
	 * @description 可視かどうかを表します。値を設定することもできます。偽を指定すると不可視になります。真を指定すると可視になります。
	 */
	 property visible {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * キャッシュを行うか
	 *
	 * @description キャッシュを行うかどうかを表します。値を設定することもできます。キャッシュを行う設定の場合、自分自身と子レイヤをすべて重ね合わせた状態の画像をあらかじめ持っておくことになり、以後、自分や子レイヤに変更が加わらない限り、自分自身と子レイヤの重ね合わせに関する画像演算を行いません(変更があった場合は自動的にキャッシュを再構成します)。キャッシュを行わない設定の場合は、画面更新の際に毎回重ね合わせの演算が行われます。デフォルトではキャッシュは行いませんが、トランジション中は自動的にキャッシュが有効になります (ただしこのプロパティはトランジション中などで自動的に有効になるようなキャッシュの有無の状態までは表しません )。あるレイヤの画像とその子レイヤの画像や状態に変化がないことが分かっていて、かつ画面が頻繁に書き換わるような場合では、そのレイヤではキャッシュを行った方が全体のパフォーマンスがあがります。
	 */
	 property cached {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * ノードが可視かどうか
	 *
	 * @description ノードが可視かどうかを表します。親レイヤの中で一つでも不可視のレイヤがあると偽になります。親レイヤがすべて可視ならば真になります。
	 */
	 property nodeVisible {
		 getter() { return value; }
	}
	/**
	 * 中性色
	 *
	 * @description レイヤの中性色を 0xAARRGGBB 形式で表します。値を設定することもできます。レイヤの中性色は、Layer.type プロパティを変更したときに、そのタイプの中性色に設定されます。中性色は、レイヤ画像のサイズが拡張されたときに、拡張された部分を塗りつぶす初期値になります。値を設定することにより、レイヤ画像のサイズ拡張時の初期色を指定することができます。
	 */
	 property neutralColor {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * レイヤが画像を持っているかどうか
	 *
	 * @description レイヤが画像を持っているかどうかを表します。値を設定することもできます。真を指定するとレイヤは画像を持ちます。これがデフォルトです。偽を指定するとレイヤの画像は開放され、レイヤは画像を持たなくなります。Layer.typeプロパティを設定するとhasImageは真にリセットされます。レイヤが画像を持たない場合、Layer.typeがltOpaqueならばレイヤは全面
	 * 		Layer.neutralColorで塗りつぶされているとして表示されます。それ以外のタイプの場合は完全に透明として扱われます。このプロパティが偽のレイヤはLayer.hitTypeがhtMaskの場合は全面が不透明度0 (完全に透明)であると見なされます。また、描画やフォントを操作することはできません。このプロパティが偽のレイヤは、通常、複数の子レイヤをまとめ、自分自身は透明なだけのレイヤとして使います。
	 * 	
	 */
	 property hasImage {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 不透明度
	 *
	 * @description レイヤの不透明度を表します。値を設定することができます。値は 0 ～ 255 の整数で、値が大きいほど不透明な表示になります。
	 */
	 property opacity {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * ウィンドウオブジェクト
	 *
	 * @description このレイヤを保持しているウィンドウオブジェクトを表します。
	 */
	 property window {
		 getter() { return value; }
	}
	/**
	 * プライマリレイヤかどうか
	 *
	 * @description プライマリレイヤかどうかを表します。プライマリレイヤは親を持たないレイヤで、一番奥に表示されるレイヤです。
	 */
	 property isPrimary {
		 getter() { return value; }
	}
	/**
	 * 左端位置
	 *
	 * @description レイヤ左端位置を、親レイヤの表示座標におけるピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setPos
	 */
	 property left {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 上端位置
	 *
	 * @description レイヤ上端位置を、親レイヤの表示座標におけるピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setPos
	 */
	 property top {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 横幅
	 *
	 * @description レイヤの表示横幅をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setSize
	 */
	 property width {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 縦幅
	 *
	 * @description レイヤの表示縦幅をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setSize
	 */
	 property height {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * レイヤ画像左端オフセット
	 *
	 * @description レイヤの表示オフセットの左端をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setImagePos
	 */
	 property imageLeft {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * レイヤ画像上端オフセット
	 *
	 * @description レイヤの表示オフセットの上端をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setImagePos
	 */
	 property imageTop {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 画像横幅
	 *
	 * @description レイヤの画像の横幅をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setImageSize
	 */
	 property imageWidth {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 画像縦幅
	 *
	 * @description レイヤの画像の縦幅をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setSize
	 */
	 property imageHeight {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 描画クリップ矩形左端位置
	 *
	 * @description 描画クリップ矩形の左端をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setClip
	 */
	 property clipLeft {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 描画クリップ矩形上端位置
	 *
	 * @description 描画クリップ矩形の上端をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setClip
	 */
	 property clipTop {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 描画クリップ矩形横幅
	 *
	 * @description 描画クリップ矩形の横幅をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setClip
	 */
	 property clipWidth {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 描画クリップ矩形縦幅
	 *
	 * @description 描画クリップ矩形の縦幅をピクセル単位で指定します。値を設定することもできます。
	 * @see Layer.setClip
	 */
	 property clipHeight {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * レイヤ表示タイプ
	 *
	 * @description レイヤの表示タイプを表します。値を設定することもできます。ltOpaque または ltCoverRect を指定すると、ピクセルごとのアルファブレンドが無効になります。ltCoverRectもltOpaqueも同じ意味です。
	 * 		Layer.opacity プロパティが 255 の場合は、完全に不透明の矩形として表示される
	 * 		事になります。マスク画像は無視されます。このタイプに適した描画方式(Layer.faceで指定)はdfOpaqueです。ltAlpha または ltTransparent を指定すると、ピクセルごとのアルファブレンドが有効になります。ltTransparentもltAlphaも同じ意味です。
	 * 		マスク画像が透過に用いられます。このタイプに適した描画方式はdfAlphaです。ltAddAlpha を指定すると、ピクセルごとの加算アルファブレンドが有効になります。このタイプに適した描画方式は dfAddAlpha です。ltAdditive を指定すると、加算合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。ltSubtractive を指定すると、減算合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。ltMultiplicative を指定すると、乗算合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。ltDodge を指定すると、覆い焼き合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。ltDarken を指定すると、比較(暗)合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。ltLighten を指定すると、比較(明)合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。ltScreen を指定すると、スクリーン乗算合成が行われます。マスク画像は無視されます。このタイプに適した描画方式は dfOpaque です。この他のレイヤ表示タイプについてはグラフィックシステムを参照してください。
	 * @see Layer.face
	 */
	 property type {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 描画方式
	 *
	 * @description レイヤへの描画方式を表します。値を設定することもできます。吉里吉里 2.23 beta 1 以前では「描画面」と呼ばれていました。dfAlpha または dfBoth を指定すると、画像はアルファチャンネルつき画像と見なされ、描画されます。dfBoth でも dfAlpha でも同じになります。この描画方法に対応するレイヤタイプは ltTransparent または ltAlpha です。dfAddAlpha を指定すると、画像は加算アルファチャンネルつき画像として見なされ、描画されます。この描画方法に対応するレイヤタイプは ltAddAlpha です。 dfOpaque または dfMain を指定すると、レイヤの画像はすべて完全不透明であると見なされ、描画されます。この描画方法に対応するレイヤタイプは ltOpaque または ltCoverRect、または ltAdditive のような算術/論理演算を行うレイヤタイプです。dfMask を指定すると、マスク画像(アルファチャンネル)を描画の対象にします。dfProvince を指定すると、領域画像を描画の対象にします。dfAuto を指定すると、現在の Layer.type プロパティに従って描画方式が自動的に決定されます。作成された直後のレイヤの描画方式は dfAuto です。このプロパティの値によっては操作できないメソッドがあります。
	 * @see Layer.type
	 */
	 property face {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * アルファチャンネルを保護するか
	 *
	 * @description 描画においてアルファチャンネルを保護するかどうかを指定します。値を設定することもできます。デフォルトでは偽です。吉里吉里 2.23 beta 1 以前では、各描画メソッドに hda というパラメータがあり、それがこのプロパティと同じ動作をしていましたが、2.23 beta 2 よりプロパティとして分離されました。いくつかの描画演算では、Layer.face プロパティが dfOpaque のとき、画像のアルファチャンネル(マスク画像)を保持するかどうかをこのプロパティで指定できます。多くのメソッドでは、このプロパティを偽にした方が高速な描画が可能です。Layer.type が ltAlpha でも ltAddAlpha でも無い場合は、画像のアルファチャンネルは使用されないので、このプロパティを偽に設定しても問題有りません。ただし、このプロパティが偽だとアルファチャンネルは破壊されます。以下のメソッドはこのプロパティの影響を受けません。Layer.loadImagesLayer.loadProvinceImageLayer.setMainPixelLayer.setMaskPixelLayer.setProvincePixelLayer.piledCopyLayer.adjustGamma(常にアルファチャンネルは保護されます)Layer.doGrayScale(常にアルファチャンネルは保護されます)Layer.flipLRLayer.flipUDLayer.assignImages以下のメソッドはこのプロパティの影響を受けます。Layer.copyRectLayer.stretchCopyLayer.affineCopyLayer.fillRectLayer.colorRectLayer.drawTextLayer.operateRectLayer.operateStretchLayer.operateAffine
	 */
	 property holdAlpha {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 画像が変更されたか
	 *
	 * @description レイヤの画像が変更されたかどうかを表します。値を設定することもできます。レイヤの画像に描画を行ったり、レイヤの画像のサイズを変更したりすると自動的に真に設定されます。このプロパティを偽に設定しておけば、レイヤの画像が変更されると真になるので、
	 * 		レイヤの画像が変更されたかどうかを知ることができます。このプロパティ自体は、レイヤの動作に影響を与えません。
	 */
	 property imageModified {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 当たり判定のタイプ
	 *
	 * @description マウスイベントの当たり判定のタイプを表します。値を設定することもできます。htProvince を指定すると、領域画像において 0 以外の領域のみマウスイベントを受け取る
	 * 		ようになります。htMask を指定すると、マスク(不透明度)画像の値が、Layer.hitThreshold プロパティで指
	 * 		定した値以上の場合のみマウスイベントを受け取るようになります。受け取られなかったマウスイベントは、より奥のレイヤで処理されます。初期状態では htMask となっています。
	 */
	 property hitType {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 当たり判定の敷居値
	 *
	 * @description マウスイベントの当たり判定の式位置を表します。値を設定することもできます。このプロパティは Layer.hitType プロパティが htMask の時のみ有効で、
	 * 		マスク(不透明度)画像の値がこのプロパティで指定した値以上の場合にマウスメッセージが受け取られます。0 を指定するとすべてのマウスメッセージが受け取られます。256 を指定するとすべてのマウスメッセージは
	 * 		受け取られません。初期状態では 16 となっています。
	 */
	 property hitThreshold {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * マウスカーソル
	 *
	 * @description レイヤのマウスカーソルを表します。値を設定することもできます。マウスカーソルには、cr で始まるマウスカーソル定数 か、.cur の拡張子を持つ
	 * 		マウスカーソルや .ani の拡張子を持つアニメーションマウスカーソルのストレージ名を
	 * 		指定することができます。
	 */
	 property cursor {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * マウスカーソル x 位置
	 *
	 * @description レイヤのマウスカーソルの x 座標値を、表示座標におけるピクセル単位で表します。値を設定することもできます。値を設定するときは、cursorX プロパティを設定しただけではマウスカーソルは移動しません。
	 * 		続いて cursorY プロパティを設定したときにマウスカーソルが移動します。
	 * @see Layer.setCursorPos
	 */
	 property cursorX {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * マウスカーソル y 位置
	 *
	 * @description レイヤのマウスカーソルの y 座標値を、表示座標におけるピクセル単位で表します。値を設定することもできます。値を設定するときは、cursorX プロパティを設定しただけではマウスカーソルは移動しません。
	 * 		続いて cursorY プロパティを設定したときにマウスカーソルが移動します。
	 * @see Layer.setCursorPos
	 */
	 property cursorY {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * ヒント
	 *
	 * @description レイヤのヒント文字列を表します。値を設定することもできます。ヒント文字列はレイヤ上にマウスカーソルを少し静止させたときに、マウスカーソルの近くに
	 * 		表示される文字列です。ヒントを表示させたくない場合は空文字列を指定します。
	 * @see Layer.showParentHint
	 */
	 property hint {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 親レイヤのヒントを引き継ぐか
	 *
	 * @description 親レイヤのヒントを引き継ぐかどうかを表します。値を設定することもできます。真の場合は、Layer.hint プロパティが空文字列の場合は、親レイヤをさか
	 * 		のぼり、ヒントが設定されているレイヤのヒントをそのまま引き継いで
	 * 		表示します。Layer.hint プロパティが空文字列でなかった場合はそれを表示します。 
	 * 		　偽の場合は、Layer.hint プロパティが空文字列でなければそれを表示し、空文字列であれば
	 * 		ヒントは表示しません。
	 */
	 property showParentHint {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * フォーカスを受け取れるかどうか
	 *
	 * @description フォーカスを受け取れるかどうかを表します。値を設定することもできます。真の場合はレイヤはフォーカスを受け取れます。偽の場合はレイヤはフォーカスを受け取れません。
	 */
	 property focusable {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 前方のフォーカスを受け取れるレイヤ
	 *
	 * @description フォーカスを受け取れるレイヤを前方検索します。該当するレイヤがなければ null になります。
	 */
	 property prevFocusable {
		 getter() { return value; }
	}
	/**
	 * 後方のフォーカスを受け取れるレイヤ
	 *
	 * @description フォーカスを受け取れるレイヤを後方検索します。該当するレイヤがなければ null になります。
	 */
	 property nextFocusable {
		 getter() { return value; }
	}
	/**
	 * フォーカスチェーンに参加するか
	 *
	 * @description フォーカスチェーンに参加するかどうかを表します。真を指定するとフォーカスチェーンに参加し、Layer.prevFocusable などに
	 * 		現れるようになったり、TAB キーなどでそのレイヤにフォーカスを移動したりできるように
	 * 		なります。偽を指定するとフォーカスチェーンには参加しませんが、フォーカスを Layer.focusメソッドなどで受け取ることはできます。
	 */
	 property joinFocusChain {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * フォーカスされているかどうか
	 *
	 * @description フォーカスされているかどうかを表します。真の場合はフォーカスされています。偽の場合はされていません。
	 */
	 property focused {
		 getter() { return value; }
	}
	/**
	 * 操作可能かどうか
	 *
	 * @description レイヤが操作可能かどうかを表します。値を設定することもできます。真の場合は操作可能で、フォーカスなどを受け取ることができます。偽の場合は操作不能で、フォーカスなどを受け取ることはできません。
	 */
	 property enabled {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * レイヤノードが操作可能かどうか
	 *
	 * @description レイヤノードが操作可能かどうかを表します。自分自身が操作不能だったり、親のレイヤの中に操作不能なレイヤがある場合は偽になります。それ以外の場合は真になります。
	 */
	 property nodeEnabled {
		 getter() { return value; }
	}
	/**
	 * 注視左端位置
	 *
	 * @description 注視左端位置を、表示座標におけるピクセル単位で表します。値を設定することもできます。
	 * @see Layer.setAttentionPos
	 * @see Layer.useAttention
	 */
	 property attentionLeft {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 注視上端位置
	 *
	 * @description 注視上端位置を、表示座標におけるピクセル単位で表します。値を設定することもできます。
	 * @see Layer.setAttentionPos
	 * @see Layer.useAttention
	 */
	 property attentionTop {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * 注視情報を使用するかどうか
	 *
	 * @description 注視情報を使用するかどうかを表します。値を設定することもできます。真が指定された場合は、そのレイヤの注視情報が使用されます。偽が指定された場合は、そのレイヤの親の注視情報が ( もしあれば ) 使用されます。
	 * @see Layer.setAttentionPos
	 * @see Layer.attentionLeft
	 * @see Layer.attentionTop
	 */
	 property useAttention {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * IMEモード
	 *
	 * @description IMEのモードを表します。値を設定することもできます。レイヤにフォーカスが設定されると、IMEはここで指定したモードに切り替わります。設定可能な値は以下の通りです。imDisable を指定すると、IMEは無効になります。IMEを使用した入力はできませんし、ユーザの操作でもIMEを有効にすることはできません。imClose を指定すると、IMEは無効になります。imDisableと異なり、ユーザの操作でIMEを有効にすることができます。imOpen を指定すると、IMEは有効になります。imDontCare を指定すると、IMEの有効/無効の状態は、前の状態を引き継ぎます。ユーザの操作によってIMEを有効にしたり無効にしたりすることができます。日本語入力においては、半角/全角文字をユーザに自由に入力させる場合の一般的なモードです。imSAlpha を指定すると、IMEは有効になり、半角アルファベット入力モードになります。imAlpha を指定すると、IMEは有効になり、全角アルファベット入力モードになります。imHira を指定すると、IMEは有効になり、ひらがな入力モードになります。imSKata を指定すると、IMEは有効になり、半角カタカナ入力モードになります。imKata を指定すると、IMEは有効になり、全角カタカナ入力モードになります。imChinese を指定すると、IMEは有効になり、2バイト中国語入力を受け付けるモードになります。日本語環境では使用できません。imSHanguel を指定すると、IMEは有効になり、1バイト韓国語入力を受け付けるモードになります。日本語環境では使用できません。imHanguel を指定すると、IMEは有効になり、2バイト韓国語入力を受け付けるモードになります。日本語環境では使用できません。未指定時は imDisable になります。
	 * @see Window.imeMode
	 */
	 property imeMode {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * onPaint イベントを呼ぶかどうか
	 *
	 * @description Layer.onPaint イベントを呼ぶかどうかを表します。値を設定することもできます。真を指定すると、次回の画面への描画の直前に onPaint イベントを呼ぶようになります。onPaint イベント
	 * 		が処理し終わるとこのプロパティは自動的に偽に戻されます。偽が指定されている状態では onPaint イベントは発生しません。Layer.update メソッドはこのプロパティを真に設定します。
	 */
	 property callOnPaint {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * フォント
	 *
	 * @description Layer.drawText メソッドで描画に使用するフォントを表す Font クラスの
	 * 		オブジェクトです。
	 */
	 property font {
		 getter() { return value; }
	}
	/**
	 * レイヤ名
	 *
	 * @description レイヤ名を表します。値を設定することもできます。このプロパティで設定した内容は、Layerクラスの動作には影響しません。
	 */
	 property name {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * メイン画像バッファポインタ
	 *
	 * @description メイン画像 ( 色とマスク(不透明度)の情報を含む 32bpp のビットマップ ) の画像バッファ左上隅へのポインタ
	 * 		を表します。このプロパティは、プラグインなどのために画像バッファへの直接のアクセスの手段を提供する
	 * 		ためにあります。整数型で返されますが、プラグインなどでは適切な型 ( const unsigned long * 等 ) にキャストして使って
	 * 		ください。このプロパティで得られたポインタには値を書き込まないでください。
	 * 		Layer.mainImageBufferForWrite で得られたポインタならば書き込むことができます。レイヤに画像が割り当てられていない場合は NULL (0) が返ります。画像のサイズは Layer.imageWidth と Layer.imageHeight プロパティが
	 * 		表しています。ポインタの計算方法は Layer.mainImageBufferPitch を参照してください。
	 * @see Layer.mainImageBufferForWrite
	 * @see Layer.mainImageBufferPitch
	 */
	 property mainImageBuffer {
		 getter() { return value; }
	}
	/**
	 * メイン画像バッファポインタ(書き込み用)
	 *
	 * @description メイン画像 ( 色とマスク(不透明度)の情報を含む 32bpp のビットマップ ) の画像バッファ左上隅へのポインタ
	 * 		を表します。このプロパティは、プラグインなどのために画像バッファへの直接のアクセスの手段を提供する
	 * 		ためにあります。整数型で返されますが、プラグインなどでは適切な型 ( unsigned long * 等 ) にキャストして使って
	 * 		ください。このプロパティで得られたポインタには Layer.mainImageBuffer と異なり、
	 * 		値を書き込むことができます。吉里吉里内部では全く同じ画像は複数のレイヤ間等で共有しますが、
	 * 		このプロパティを参照するとその共有状態を解除します。レイヤに画像が割り当てられていない場合は NULL (0) が返ります。画像のサイズは Layer.imageWidth と Layer.imageHeight プロパティが
	 * 		表しています。ポインタの計算方法は Layer.mainImageBufferPitch を参照してください。
	 * @see Layer.mainImageBuffer
	 * @see Layer.mainImageBufferPitch
	 */
	 property mainImageBufferForWrite {
		 getter() { return value; }
	}
	/**
	 * メイン画像バッファピッチ
	 *
	 * @description メイン画像 ( 色とマスク(不透明度)の情報を含む 32bpp のビットマップ ) の画像バッファのピッチ
	 * 		( 一つ下のスキャンラインまでのバイト数 ) を表します。このプロパティは、プラグインなどのために画像バッファへの直接のアクセスの手段を提供する
	 * 		ためにあります。tjs_uint32 が 32bit の整数型、tjs_uint8 が 8bit (1byte) の整数型として、画像位置 (x, y) への
	 * 		ポインタは C 言語で書くと以下のように計算することができます。( (tjs_uint32*)( (tjs_uint8*)mainImageBuffer + y*mainImageBufferPitch )) + xこのプロパティは、次のスキャンラインまでのピクセル数ではなく、バイト数を返すことに
	 * 		注意してください。この数値は画像横幅ぴったりに必要なバイト数よりも若干大きい場合があります。このプロパティは値が負になり得ますので注意してください。
	 * @see Layer.mainImageBuffer
	 * @see Layer.mainImageBufferForWrite
	 */
	 property mainImageBufferPitch {
		 getter() { return value; }
	}
	/**
	 * 領域画像バッファポインタ
	 *
	 * @description 領域画像 ( 領域の情報を含む 8bpp のビットマップ ) の画像バッファ左上隅へのポインタ
	 * 		を表します。このプロパティは、プラグインなどのために画像バッファへの直接のアクセスの手段を提供する
	 * 		ためにあります。整数型で返されますが、プラグインなどでは適切な型 ( const unsigned char * 等 ) にキャストして使って
	 * 		ください。このプロパティで得られたポインタには値を書き込まないでください。
	 * 		Layer.provinceImageBufferForWrite で得られたポインタならば書き込むことができます。画像が割り当てられていない場合は NULL (0) が返ります。画像が割り当てられていない場合は
	 * 		全域が領域番号 0 であると見なす必要があります。画像のサイズは Layer.imageWidth と Layer.imageHeight プロパティが
	 * 		表しています。ポインタの計算方法は Layer.provinceImageBufferPitch を参照してください。
	 * @see Layer.provinceImageBufferForWrite
	 * @see Layer.provinceImageBufferPitch
	 */
	 property provinceImageBuffer {
		 getter() { return value; }
	}
	/**
	 * 領域画像バッファポインタ(書き込み用)
	 *
	 * @description 領域画像 ( 領域の情報を含む 8bpp のビットマップ ) の画像バッファ左上隅へのポインタ
	 * 		を表します。このプロパティは、プラグインなどのために画像バッファへの直接のアクセスの手段を提供する
	 * 		ためにあります。整数型で返されますが、プラグインなどでは適切な型 ( unsigned char * 等 ) にキャストして使って
	 * 		ください。このプロパティで得られたポインタには Layer.provinceImageBuffer と異なり、
	 * 		値を書き込むことができます。吉里吉里内部では全く同じ画像は複数のレイヤ間等で共有しますが、
	 * 		このプロパティを参照するとその共有状態を解除します。レイヤに画像が割り当てられていない場合は自動的にこのプロパティを参照した時点で
	 * 		割り当てられ、全域が領域番号 0 で初期化されます。画像のサイズは Layer.imageWidth と Layer.imageHeight プロパティが
	 * 		表しています。ポインタの計算方法は Layer.provinceImageBufferPitch を参照してください。
	 * @see Layer.provinceImageBuffer
	 * @see Layer.provinceImageBufferPitch
	 */
	 property provinceImageBufferForWrite {
		 getter() { return value; }
	}
	/**
	 * 領域画像バッファピッチ
	 *
	 * @description 領域画像 ( 領域の情報を含む 8bpp のビットマップ ) の画像バッファのピッチ
	 * 		( 一つ下のスキャンラインまでのバイト数 ) を表します。このプロパティは、プラグインなどのために画像バッファへの直接のアクセスの手段を提供する
	 * 		ためにあります。tjs_uint8 が 8bit (1byte) の整数型として、画像位置 (x, y) への
	 * 		ポインタは C 言語で書くと以下のように計算することができます。(tjs_uint8*)provinceImageBuffer + y*provinceImageBufferPitch + xこのプロパティの数値は画像横幅ぴったりに必要なバイト数よりも若干大きい場合があります。このプロパティは値が負になり得ますので注意してください。
	 * @see Layer.provinceImageBuffer
	 * @see Layer.provinceImageBufferForWrite
	 */
	 property provinceImageBufferPitch {
		 getter() { return value; }
	}
	/**
	 * ヒント表示判定有無
	 *
	 * @description ヒント表示判定有無を表します。trueを設定するとこのレイヤではヒント判定が行われません。falseを設定すると判定が行われます。
	 * @see Window.onHintChanged
	 */
	 property ignoreHintSensing {
		 getter() { return value; }
		 setter( value ) {}
	}
};
