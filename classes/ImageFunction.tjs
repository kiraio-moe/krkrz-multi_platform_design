/**
 * @description The ImageFunction class is a class that manipulates images.
 * You cannot create objects from this class.
 */
class ImageFunction {
	/**
	 * Affine transformation arithmetic composition
	 *
	 * @param dst Specifies the Bitmap object to overlay.
	 * @param src Specifies the Bitmap object to overlay.
	 * @param A A parameter. The interpretation depends on the affine argument.
	 * @param B B parameter. The interpretation depends on the affine argument.
	 * @param C C parameter. The interpretation depends on the affine argument.
	 * @param D D parameter. The interpretation depends on the affine argument.
	 * @param E E parameter. The interpretation depends on the affine argument.
	 * @param F F parameter. The interpretation depends on the affine argument.
	 * @param srcrect Specifies the rectangle to overlay in the Rect object in pixels (at the image position of the overlay source Bitmap).
	 * When not specified, the entire target is applicable.
	 * @param cliprect Specifies the clipping rectangle in the Rect object (at the image position of the overlay destination Bitmap).
	 * Clipping is not performed when not specified.
	 * @param affine Specifies how to handle the following 6 arguments (A to F parameters).
	 * If true is specified, each of the six parameters will be interpreted as follows.
	 * A: a of 2D affine transformation matrix
	 * B: b of 2D affine transformation matrix
	 * C: c of 2D affine transformation matrix
	 * D: d of 2D affine transformation matrix
	 * E: tx of 2D affine transformation matrix
	 * F: ty of 2D affine transformation matrix
	 * By affine transformation, the image position (x, y) of the overlay source (however, the upper left corner of the overlay source rectangle is (0, 0)) is the image position (x', y) of the overlay destination by the following formula. Converted to y').
	 * x'= a * x + c * y + txy' = b * x + d * y + ty
	 * If false is specified, each of the six parameters will be interpreted as follows.
	 * A: X coordinate position (x0) of the point in the upper left corner of the copy source rectangle at the image position at the copy destination.
	 * B: Y coordinate position (y0) of the point in the upper left corner of the copy source rectangle at the image position at the copy destination.
	 * C: X coordinate position (x1) of the point in the upper right corner of the copy source rectangle at the image position at the copy destination.
	 * D: Y coordinate position (y1) of the point in the upper right corner of the copy source rectangle at the image position at the copy destination.
	 * E: X coordinate position (x2) of the point in the lower left corner of the copy source rectangle at the image position at the copy destination.
	 * F: Y coordinate position (y2) of the point in the lower left corner of the copy source rectangle at the image position at the copy destination.
	 * If false is specified, the overlay destination position (x3, y3) corresponding to the lower right corner of the overlay source is automatically calculated by the following formula.
	 * x3 = x1 --x0 + x2y3 = y1 --y0 + y2
	 * @param mode Specifies the operation mode.
	 *
	 * + If omPsNormal is specified, Photoshop compatible alpha compositing will be performed (not implemented in the current version).
	 * + If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is done (not implemented in the current version).
	 * + If omPsSubtractive is specified, Photoshop compatible burn (linear) compositing is performed (not implemented in the current version).
	 * + If omPsMultiplicative is specified, Photoshop compatible multiplication and composition will be performed (not implemented in the current version).
	 * + If omPsScreen is specified, Photoshop compatible screen composition will be performed (not implemented in the current version).
	 * + If omPsOverlay is specified, Photoshop compatible overlay composition will be performed (not implemented in the current version).
	 * + If omPsHardLight is specified, Photoshop compatible hard light composition will be performed (not implemented in the current version).
	 * + If omPsSoftLight is specified, Photoshop compatible softlight composition will be performed (not implemented in the current version).
	 * + If omPsColorDodge is specified, Photoshop compatible dodging color composition will be performed (not implemented in the current version).
	 * + If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed (not implemented in the current version).
	 * + If omPsColorBurn is specified, Photoshop compatible burn-in color composition is performed (not implemented in the current version).
	 * + If omPsLighten is specified, Photoshop compatible comparison (bright) composition will be performed (not implemented in the current version).
	 * + If omPsDarken is specified, Photoshop compatible comparison (dark) compositing will be performed (not implemented in the current version).
	 * + If omPsDifference is specified, Photoshop compatible absolute difference composition is performed (not implemented in the current version).
	 * + If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x or lower will be performed (not implemented in the current version).
	 * + If omPsExclusion is specified, Photoshop compatible exclusion composition is performed (not implemented in the current version).
	 * + If omAdditive is specified, additive synthesis will be performed (not implemented in the current version).
	 * + If omSubtractive is specified, subtractive synthesis will be performed (not implemented in the current version).
	 * + If omMultiplicative is specified, multiplication synthesis will be performed (not implemented in the current version).
	 * + If omDodge is specified, dodging synthesis will be performed (not implemented in the current version).
	 * + If omDarken is specified, comparison (dark) compositing will be done (not implemented in the current version).
	 * + If omLighten is specified, comparison (bright) composition will be performed (not implemented in the current version).
	 * + If omScreen is specified, screen multiplication composition will be performed (not implemented in the current version).
	 * + If omAlpha is specified, alpha synthesis will occur.
	 * + If omAddAlpha is specified, additive alpha composition is done. In this case, when face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 * + If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque. In this case, when face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 *
	 * @param face Specify the drawing method.
	 *
	 * + If dfAlpha is specified, the image is considered an image with an alpha channel and is drawn.
	 * + If dfAddAlpha is specified, the image is considered as an image with an additive alpha channel and is drawn.
	 * + If dfOpaque is specified, all images are considered completely opaque and will be drawn.
	 *
	 * @param opa Specifies the overlay opacity (0 to 255).
	 * @param type Specifies the type of affine transformation.
	 *
	 * + stNearest     : Nearest point method is used
	 * + stFastLinear  : Low precision linear interpolation is used (partially implemented)
	 * + stLinear      : Linear interpolation is used (not implemented)
	 * + stCubic       : 3D interpolation is used (not implemented)
	 *
	 * The speed is faster in the order of stNearest> stFastLinear> stLinear> stCubic, but the faster the speed, the lower the image quality.
	 * For stFastLinear, stLinear, and stCubic, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.
	 * If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).
	 * @param hda Specifies whether to protect the alpha channel.
	 * @description Computes the rectangle of the specified overlay source Bitmap while performing affine transformation at the overlay destination.
	 */
	function operateAffine( dst, src, A, B, C, D, E, F, srcrect=null, cliprect=null, affine, mode=omAlpha, face=dfAlpha, opa=255, type=stNearest, hda=false);

	/**
	 * Rectangle arithmetic composition
	 *
	 * @param dst Specifies the Bitmap object to overlay.
	 * @param dleft Specifies the leftmost position of the calculation destination rectangle in pixels (at the image position of the calculation destination Bitmap).
	 * @param dtop Specifies the top position of the calculation destination rectangle in pixels (at the image position of the calculation destination Bitmap).
	 * @param src Specifies the Bitmap object from which to calculate. If not specified, the entire target will be applied.
	 * @param srcrect Specifies the rectangle to be calculated in a pixel-by-pixel Rect object (at the image position of the source Bitmap).
	 * If not specified, the entire target will be applied.
	 * @param cliprect Specifies the clipping rectangle in the Rect object (at the image position of the overlay destination Bitmap).
	 * Clipping is not performed when not specified.
	 * @param mode Specifies the operation mode.
	 *
	 * + If omPsNormal is specified, Photoshop compatible alpha compositing is done.
	 * + If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is done.
	 * + If omPsSubtractive is specified, Photoshop compatible burn (linear) compositing is performed.
	 * + If omPsMultiplicative is specified, Photoshop compatible multiplication and composition will be performed.
	 * + If omPsScreen is specified, Photoshop compatible screen composition will be performed.
	 * + If omPsOverlay is specified, Photoshop compatible overlay compositing is done.
	 * + If omPsHardLight is specified, Photoshop compatible hard light composition will be performed.
	 * + If omPsSoftLight is specified, Photoshop compatible softlight compositing will be performed.
	 * + If omPsColorDodge is specified, Photoshop compatible dodge color composition will be performed.
	 * + If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed.
	 * + If omPsColorBurn is specified, Photoshop compatible burn-in color composition will be performed.
	 * + If omPsLighten is specified, Photoshop compatible comparison (bright) compositing is performed.
	 * + If omPsDarken is specified, Photoshop compatible comparison (dark) compositing is done.
	 * + If omPsDifference is specified, Photoshop compatible absolute difference composition is performed.
	 * + If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x and below is performed.
	 * + If omPsExclusion is specified, Photoshop compatible exclusion composition is performed.
	 * + If omAdditive is specified, additive synthesis is performed.
	 * + If omSubtractive is specified, subtractive synthesis will be performed.
	 * + If omMultiplicative is specified, multiplication synthesis is performed.
	 * + If omDodge is specified, dodging synthesis will be performed.
	 * + If omDarken is specified, comparative (dark) compositing is done.
	 * + If omLighten is specified, comparison (bright) composition will be performed.
	 * + If omScreen is specified, screen multiplication composition is performed.
	 * + If omAlpha is specified, alpha synthesis will occur.
	 * + If omAddAlpha is specified, additive alpha composition is done.
	 * + If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque.
	 * @param face Specify the drawing method.
	 *
	 * + If dfAlpha is specified, the image is considered an image with an alpha channel and is drawn.
	 * + If dfAddAlpha is specified, the image is considered as an image with an additive alpha channel and is drawn.
	 * + If dfOpaque is specified, all images are considered completely opaque and will be drawn.
	 *
	 * @param opa Specifies the intensity of the operation (0 to 255).
	 * @param hda Specifies whether to protect the alpha channel.
	 * @description Computes the rectangular part of the specified operation source Bitmap at the specified position of the operation destination Bitmap in the specified mode.
	 */
	function operateRect( dst, dleft, dtop, src, srcrect=null, cliprect=null, mode=omAuto, face=dfAlpha, opa=255, hda=false);

	/**
	 * Enlargement / reduction operation composition
	 *
	 * @param dst Specifies the Bitmap object to overlay.
	 * @param src Specifies the Bitmap object to overlay.
	 * @param dstrect Specifies the overlay rectangle in the Rect object in pixels (at the image position of the overlay Bitmap).
	 * When not specified, the entire target is applicable.
	 * @param srcrect Specifies the overlay rectangle in a pixel-by-pixel Rect object (at the image position of the overlay Bitmap).
	 * When not specified, the entire target is applicable.
	 * @param cliprect Specifies the clipping rectangle in the Rect object (at the image position of the overlay destination Bitmap).
	 * Clipping is not performed when not specified.
	 * @param mode Specifies the operation mode.
	 *
	 * + If omPsNormal is specified, Photoshop compatible alpha compositing will be performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omPsSubtractive is specified, Photoshop-compatible burn-in (linear) compositing is performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omPsMultiplicative is specified, Photoshop compatible multiplication and composition will be performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omPsScreen is specified, Photoshop compatible screen composition will be performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omPsOverlay is specified, Photoshop compatible overlay compositing is performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omPsHardLight is specified, Photoshop compatible hard light composition will be performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omPsSoftLight is specified, Photoshop compatible soft light composition will be performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omPsColorDodge is specified, Photoshop compatible dodge color composition is performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omPsColorBurn is specified, Photoshop-compatible burn-in color composition is performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omPsLighten is specified, Photoshop compatible comparison (bright) composition is performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omPsDarken is specified, Photoshop compatible comparison (dark) compositing is performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omPsDifference is specified, Photoshop compatible absolute value composition of the difference is performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x or lower is performed (implemented in 1.3 or later except stNearest and stFastLinear).
	 * + If omPsExclusion is specified, Photoshop compatible exclusion composition is performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omAdditive is specified, additive synthesis is performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omSubtractive is specified, subtractive synthesis will be performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omMultiplicative is specified, multiplication synthesis is performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omDodge is specified, dodging synthesis will be performed (implemented in 1.3 and later except stNearest and stFastLinear).
	 * + If omDarken is specified, comparison (dark) compositing is done (implemented outside of stNearest and stFastLinear in 1.3 and later).
	 * + If omLighten is specified, comparison (bright) composition is performed (implemented in 1.3 or later other than stNearest and stFastLinear).
	 * + If omScreen is specified, screen multiplication composition is performed (implemented in 1.3 and later other than stNearest and stFastLinear).
	 * + If omAlpha is specified, alpha synthesis will occur. If omAddAlpha is specified, additive alpha composition is done. In this case, when face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 * + If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque. In this case, when face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 *
	 * @param face Specify the drawing method.
	 *
	 * + If dfAlpha is specified, the image is considered an image with an alpha channel and is drawn.
	 * + If dfAddAlpha is specified, the image is considered as an image with an additive alpha channel and is drawn.
	 * + If dfOpaque is specified, all images are considered completely opaque and will be drawn.
	 *
	 * @param opa Specifies the intensity of the operation (0 to 255).
	 * @param type Specifies the scale type.
	 *
	 * + stNearest           : Nearest point method is used
	 * + stFastLinear        : Low precision linear interpolation is used (partially implemented)
	 * + stSemiFastLinear    : Fixed decimal linear interpolation is used (1.3+)
	 * + stLinear            : Linear interpolation is used (implementation changed after 1.3)
	 * + stFastCubic         : Fixed decimal 3D interpolation is used (1.3 or later)
	 * + stCubic             : 3D interpolation is used (implementation changed after 1.3)
	 * + stFastLanczos2      : Fixed decimal Lanczos interpolation range 4x4 is used (1.3+)
	 * + stLanczos2          : Lanczos interpolation range 4x4 is used (1.3 and above)
	 * + stFastLanczos3      : Fixed decimal Lanczos interpolation range 6x6 is used (1.3 and above)
	 * + stLanczos3          : Lanczos interpolation range 6x6 is used (1.3 and above)
	 * + stFastSpline16      : Fixed decimal spline interpolation 4x4 is used (1.3+)
	 * + stSpline16          : Spline interpolation 4x4 is used (1.3+)
	 * + stFastSpline36      : Fixed decimal spline interpolation 6x6 is used (1.3+)
	 * + stSpline36          : Spline interpolation 6x6 is used (1.3+)
	 * + stFastAreaAvg       : Fixed decimal area mean reduction is used. Cannot be expanded (1.3 or later)
	 * + stAreaAvg           : Area average reduction is used. Cannot be expanded (1.3 or later)
	 * + stFastGaussian      : Fixed decimal Gaussian interpolation 4x4 is used (1.3+)
	 * + stGaussian          : Gaussian interpolation 4x4 is used (1.3 or later)
	 * + stFastBlackmanSinc  : Fixed decimal Blackman-Sinc interpolation 8x8 is used (1.3+)
	 * + stBlackmanSinc      : Blackman-Sinc interpolation 8x8 is used (1.3+)
	 *
	 * The speed is faster in the order of stNearest> stFastLinear> stLinear> stCubic, but the faster the speed, the lower the image quality.
	 * The interpolation method after stCubic has sufficiently high image quality and can be said to be a difference in taste.
	 * However, the image quality will be blurry for Gaussian interpolation.
	 * The difference between stFastLinear and other linear interpolations (stSemiFastLinear and stLinear) is large when shrinking.
	 * While stFastLinear always refers to the surrounding 4 pixels, stSemiFastLinear and stLinear refer to and interpolate a range in which the influence range at 1x magnification is 4 pixels at the time of reduction, that is, a wider range of pixels. Higher image quality (algorithm is the original linear interpolation).
	 * For stFastLinear, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.
	 * If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).
	 * @param hda Specifies whether to protect the alpha channel.
	 * @param option Added in 1.3 and later. Sharpness during 3D interpolation.
	 * It currently has no meaning with other interpolation methods.
	 * Increasing the sharpness value in the positive direction will make it blurry, and increasing it in the negative direction will make it sharper.
	 * @description Computes the specified overlay source Bitmap rectangle to the overlay destination Bitmap rectangle.
	 * If the size of the overlay source rectangle and the overlay destination rectangle are different, enlargement or reduction is performed.
	 */
	function operateStretch( dst, src, dstrect=null, srcrect=null, cliprect=null, mode=omAuto, face=dfAlpha, opa=255, type=stNearest, hda=false, option=-1.0);

	/**
	 * Flip horizontal
	 *
	 * @param bmp Specifies the Bitmap object to invert.
	 * @param rect The area to be inverted is specified by the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @description Flip the image horizontally.
	 */
	function flipLR( bmp, rect=null);

	/**
	 * flip upside down
	 *
	 * @param bmp Specifies the Bitmap object to invert.
	 * @param rect The area to be inverted is specified by the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @description Flip the image upside down.
	 */
	function flipUD( bmp, rect=null);

	/**
	 * Gamma correction
	 *
	 * @param bmp Specifies the Bitmap object for gamma correction.
	 * @param rgamma Specify the gamma value of the red component (0.0 to 1.0 to 9.0).
	 * @param rfloor Specify the minimum output value (0 to 255) for the red component.
	 * @param rceil Specifies the maximum output value (0 to 255) for the red component.
	 * @param ggamma Specify the gamma value of the green component (0.0 to 1.0 to 9.0).
	 * @param gfloor Specifies the minimum output value (0 to 255) for the green component.
	 * @param gceil Specify the maximum output value (0 to 255) of the green component.
	 * @param bgamma Specify the gamma value of the blue component (0.0 to 1.0 to 9.0).
	 * @param bfloor Specifies the minimum output value (0 to 255) for the blue component.
	 * @param bceil Specify the maximum output value (0 to 255) of the blue component.
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap). When not specified, the entire target is applicable.
	 * @param isaddalpha Specifies whether it is in additive synthesis alpha format.
	 * @description Performs gamma correction on the image.
	 * If you specify 1.0 for the gamma value, the gamma curve becomes a straight line.
	 * The output minimum value and output maximum value specify the minimum and maximum values of the brightness of each component.
	 * You can invert the image by setting the highest value to a value lower than the lowest value.
	 * If isaddalpha is true, this method uses a special gamma correction routine for additive alpha synthesis.
	 * This routine performs gamma correction for the components corresponding to alpha synthesis in additive alpha synthesis, but does not perform gamma correction for the components corresponding to additive synthesis.
	 */
	function adjustGamma( bmp, rgamma=1.0, rfloor=0, rceil=255, ggamma=1.0, gfloor=0, gceil=255, bgamma=1.0, bfloor=0, bceil=255, cliprect=null, isaddalpha=false);

	/**
	 * Apply rectangular blur
	 *
	 * @param bmp Specifies a Bitmap object to blur the rectangle.
	 * @param xblur Specifies the range of horizontal blur.
	 * @param yblur Specifies the range of vertical blur.
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @param isalpha Specifies whether to have an alpha channel.
	 * @description Blur.
	 * The algorithm is "box blur".
	 * A rectangular blur is the average of the brightness of pixels in a "range" represented by two parameters, xblur and yblur.
	 * For example, if xblur = 10 yblur = 2, the brightness of the pixels in the rectangular range of -10 to 10 in the horizontal direction and -2 to 2 in the vertical direction is averaged around the target pixel, and that is the final result. It is the brightness of that pixel.
	 * The area of the range can be calculated by (xblur × 2 + 1) × (yblur × 2 + 1).
	 * In the current version, if this area is less than 256, the algorithm is faster than if the area is 256 or more.
	 * If isalpha is true, it uses a special algorithm for alpha compositing, which is a bit slower.
	 * If false, the algorithm will be faster.
	 */
	function doBoxBlur( bmp, xblur=1, yblur=1, cliprect=null, isalpha=true);

	/**
	 * Grayscale conversion
	 *
	 * @param bmp Specifies the Bitmap object to be grayscale converted.
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @description Converts the image to grayscale.
	 */
	function doGrayScale( bmp, cliprect=null);

	/**
	 * Rectangle translucent fill
	 *
	 * @param bmp Specifies the Bitmap object to fill.
	 * @param value Specify the fill color and value.
	 * This value has different meanings depending on the value of the face argument.
	 *
	 * + dfAlpha     : Specify the color in 0xRRGGBB format
	 * + dfAddAlpha  : Specify the color in 0xRRGGBB format
	 * + dfOpaque    : Specify the color in 0xRRGGBB format
	 * + dfMask      : Specify a mask (opacity) value (0 to 255)
	 *
	 * If you specify dfOpaque, the mask information is ignored.
	 * Also, if you specify dfMask, the color information remains the same.
	 * This argument is ignored for dfAlpha and if opa is negative.
	 * @param opa Specifies the opacity to fill (-255 to 0 to 255).
	 * This argument is ignored if the face value is dfMask or dfProvince (always completely opaque).
	 * Negative numbers are valid only if face is dfAlpha, in which case the value argument is ignored and the image is stripped of opacity (-255 makes the rectangle completely transparent).
	 * @param rect Specifies the rectangle to fill with a Rect object in pixels (at the image position).
	 * If not specified, the entire target will be applied.
	 * @param face Specify the drawing method.
	 *
	 * + If dfAlpha is specified, the image is considered an image with an alpha channel and is drawn.
	 * + If dfAddAlpha is specified, the image is considered as an image with an additive alpha channel and is drawn.
	 * + If dfOpaque is specified, all images are considered completely opaque and will be drawn.
	 *
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @description Fills the rectangle of the specified Bitmap image in the specified way.
	 * Unlike ImageFunction.fillRect, you can specify transparency to fill with translucency.
	 */
	function colorRect( bmp, value, opa=255, rect=null, face=dfAlpha, cliprect=null);

	/**
	 * Character drawing
	 *
	 * @param bmp Specifies the Bitmap object to draw the character.
	 * @param font Specify the font to draw with the Font object.
	 * @param x Specifies the x-coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param y Specifies the y coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param text Specify the character to draw.
	 * @param color Specifies the color of the characters to draw in the 0xRRGGBB format.
	 * @param opa Specifies the opacity (-255 to 0 to 255) of the characters to draw.
	 * Negative numbers are only valid if face is dfAlpha, in which case the opacity of the character shape will be removed (the smaller the value, the greater the effect).
	 * @param aa Specifies whether to perform antialiasing.
	 * If true is specified, antialiasing will be performed.
	 * If you specify false, it will not be done.
	 * @param face Specify the drawing method.
	 *
	 * + If dfAlpha is specified, the image is considered an image with an alpha channel and is drawn.
	 * + If dfAddAlpha is specified, the image is considered as an image with an additive alpha channel and is drawn.
	 * + If dfOpaque is specified, all images are considered completely opaque and will be drawn.
	 *
	 * @param shadowlevel Specifies the opacity of the shadow.
	 * The appropriate value will vary depending on the value of the shadowwidth argument.
	 * If you specify 0, no shadow is drawn.
	 * @param shadowcolor Specifies the shadow color in 0xRRGGBB format.
	 * @param shadowwidth Specifies the shadow width (blurring).
	 * 0 is the sharpest (no blur), and increasing the value will blur the shadow.
	 * @param shadowofsx Specifies the x-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @param shadowofsy Specifies the y-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @param hda Specifies whether to protect the alpha channel.
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @return Drawing area (Rect object)
	 * @description Draws a character in the Bitmap.
	 * If dfOpaque is specified for face, it depends on hda whether the mask to be drawn is destroyed or protected.
	 */
	function drawText( bmp, font, x, y, text, color, opa=255, aa=true, face=dfAlpha, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0, hda=false, cliprect=null);

	/**
	 * Character drawing
	 *
	 * @param bmp Specifies the Bitmap object to draw the character.
	 * @param x Specifies the x-coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param y Specifies the y coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param glyph Specifies the glyph to draw.
	 * @param color Specifies the color of the characters to draw in the 0xRRGGBB format.
	 * @param opa Specifies the opacity (-255 to 0 to 255) of the characters to draw.
	 * Negative numbers are only valid if face is dfAlpha, in which case the opacity of the character shape will be removed (the smaller the value, the greater the effect).
	 * @param aa Specifies whether to perform antialiasing.
	 * If true is specified, antialiasing will be performed.
	 * If you specify false, it will not be done.
	 * @param face Specify the drawing method.
	 *
	 * + If dfAlpha is specified, the image is considered an image with an alpha channel and is drawn.
	 * + If dfAddAlpha is specified, the image is considered as an image with an additive alpha channel and is drawn.
	 * + If dfOpaque is specified, all images are considered completely opaque and will be drawn.
	 *
	 * @param shadowlevel Specifies the opacity of the shadow.
	 * The appropriate value will vary depending on the value of the shadowwidth argument.
	 * If you specify 0, no shadow is drawn.
	 * @param shadowcolor Specifies the shadow color in 0xRRGGBB format.
	 * @param shadowwidth Specifies the shadow width (blurring).
	 * 0 is the sharpest (no blur), and increasing the value will blur the shadow.
	 * @param shadowofsx Specifies the x-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @param shadowofsy Specifies the y-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @param hda Specifies whether to protect the alpha channel.
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @return Drawing area (Rect object)
	 * @description Draw a glyph in the Bitmap.
	 * If dfOpaque is specified for face, it depends on hda whether the mask to be drawn is destroyed or protected.
	 * A glyph specifies an array of the form `glyph: Array [9] = [width, height, originx, originy, incx, incy, inc, bitmap (Octet), colors]`.
	 * If the glyph colors are omitted, it is considered to be 256 gradations.
	 */
	function drawGlyph( bmp, x, y, glyph, color, opa=255, aa=true, face=dfAlpha, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0, hda=false, cliprect=null);

	/**
	 * Rectangle fill
	 *
	 * @param bmp Specifies the Bitmap object to fill.
	 * @param value Specify the fill color and value.
	 * This value depends on the value of isalpha.
	 *
	 * + true   : Specify the opacity and color in the 0xAARRGGBB format. Both the main and the mask are filled.
	 * + false  : Specify the color in 0xRRGGBB format.
	 *
	 * @param rect Specifies the rectangle to fill with a Rect object in pixels (at the image position).
	 * If not specified, the entire target will be applied.
	 * @param isalpha Specifies whether to have an alpha channel.
	 * @param cliprect Specify the clipping area with the Rect object (at the image position of the Bitmap).
	 * When not specified, the entire target is applicable.
	 * @description Fills the rectangle of the specified Bitmap image in the specified way.
	 */
	function fillRect( bmp, value, rect=null, isalpha=true, cliprect=null);


	/**
	 * Image copy using 9 path (multi-platform version or later)
	 *
	 * @param dst Copy destination Bitmap
	 * @param src Copy source Bitmap
	 * @return Margin information
	 * @description 9 Make an image copy using path (slice).
	 * The margin information returned is an object of class Rect.
	 * Draw text etc. within this margin.
	 */
	function copy9Patch( dst:Bitmap, src:Bitmap ):Rect;
};
