/**
 * @description Canvas is a class that provides drawing functions.
 * When you create a Window, the property canvas is created automatically.
 * When using it, use the canvas property of this Window.
 */
class Canvas {

	/**
	 * Clear color specification / Screen clear color before drawing processing
	 */
	property clearColor;

	
	/**
	 * Clear the entire drawing area
	 * @param argb Clear color (cleared by clearColor property if not specified)
	 */
	function clear(argb:int);

	/**
	 * Capture the entire current drawing content in Bitmap / Texture / Offscreen
	 * @description Bitmap size corrected to screen size
	 * Not changed for Texture / Offscreen
	 * @param dest Capture destination Bitmap / Texture / Offscreen
	 * @param front Specify whether to capture from the front buffer or from the back buffer. true for front, false for back
	 */
	function capture(dest,front:bool=true);

	/**
	 * Drawing target specification
	 * @description Offscreen class can be specified.
	 * Direct drawing by specifying null / void.
	 */
	property renderTarget;

	/**
	 * Specify drawing composition mode
	 * @description bmDisable, bmOpaque, bmAlpha, bmAdd, bmAddWithAlpha can be specified.
	 * If you need a blending method that is not here, write a shader.
	 */
	property blendMode;

	/** Drawing matrix specification
	 * @description (Matrix32 class)
	 */
	property matrix;

	/**
	 * Save the state of matrix and clip (stack)
	 */
	function save();

	/**
	 * Restore the state of matrix and clip (stack)
	 */
	function restore();

	/**
	 * Fill with color
	 * @description The XY coordinates are specified by matrix.
	 * @param width Fill range width
	 * @param height Fill range height
	 * @param colors Vertex color ARGB of 4 vertices. Single color for single numerical value, 4 vertices individually specified for array
	 * @param shader Fill shader. When null, it is filled with defaultFillShader
	 */
	function fill( width:int, height:int, colors=0xffffffff, shader=null );

	/**
	 * Mesh drawing
	 * @description The mesh (VertexBinder: vertex information) must be associated with the shader (set in the properties) before calling.
	 * Texture information should be associated as well.
	 * After calling, cancel (= void) the information associated with shader.
	 * @param shader Specify the shader associated with the texture and vertex information
	 * @param count Number of vertices to draw
	 * @param primitiveType Designation such as triangle
	 * @param offset Offset to start drawing in the vertex array
	 */
 	function drawMesh( shader:ShaderProgram, count:int, primitiveType:int=VertexBuffer.ptTriangles, offset:int=0 );

 	/**
 	 * Version using index buffer for mesh drawing
	 * @description The mesh (VertexBinder: vertex information) must be associated with the shader (set in the properties) before calling.
	 * Texture information should be associated as well.
	 * After calling, cancel (= void) the information associated with shader.
	 * @param shader Specify the shader associated with the texture and vertex information
	 * @param index Specify the index buffer
	 * @param count Number of indexes to draw
	 * @param primitiveType Designation such as triangle
 	 */
 	function drawMesh( shader:ShaderProgram, index:VertexBinder, count:int, primitiveType:int=VertexBuffer.ptTriangles );

	/**
	 * Draw a single texture
	 * @description It is drawn with the defaultShader.
	 * The position, scaling, and rotation are specified by matrix.
	 * It doesn't matter if you specify the Offscreen class as well as the Texture class for the texture.
	 * If you specify an Offscreen class, it is assumed that the Offscreen class has been removed from the renderTarget (so that it does not cycle).
	 * @param texture Specifies the texture to use for drawing
	 */
	function drawTexture( texture:Texture );

	/**
	 * Draw one texture by specifying a shader
	 * @description The position, scaling, and rotation are specified by matrix.
	 * It doesn't matter if you specify the Offscreen class as well as the Texture class for the texture.
	 * If you specify an Offscreen class, it is assumed that the Offscreen class has been removed from the renderTarget (so that it does not cycle).
	 * @param texture Specifies the texture to use for drawing
	 * @param shader Specifies the shader to use for drawing
	 */
	function drawTexture( texture:Texture, shader:ShaderProgram );

	/**
	 * Draw two textures by specifying a shader
	 * @description The position, scaling, and rotation are specified by matrix.
	 * It doesn't matter if you specify the Offscreen class as well as the Texture class for the texture.
	 * If you specify an Offscreen class, it is assumed that the Offscreen class has been removed from the renderTarget (so that it does not cycle).
	 * @param texture Specifies the texture to use for drawing
	 * @param texture2 Specifies the second texture to use for drawing
	 * @param shader Specifies the shader to use for drawing
	 */
	function drawTexture( texture:Texture, texture2:Texture, shader:ShaderProgram );

	/**
	 * Draw 3 textures by specifying shader
	 * @description The position, scaling, and rotation are specified by matrix.
	 * It doesn't matter if you specify the Offscreen class as well as the Texture class for the texture.
	 * If you specify an Offscreen class, it is assumed that the Offscreen class has been removed from the renderTarget (so that it does not cycle).
	 * @param texture Specifies the texture to use for drawing
	 * @param texture2 Specifies the second texture to use for drawing
	 * @param texture3 Specifies the third texture to use for drawing
	 * @param shader Specifies the shader to use for drawing
	 *
	 * @description In the case of OpenGL ES 2.0, the maximum number of textures is 8, and in 3.0, the maximum number is 16 on the vertex side and 16 on the fragment side, so you can still add them, but for the time being, up to 3 are defined.
	 * In the future, we will make a version that passes textures in an array, and we will consider dealing with 4 or more sheets there.
	 */
	function drawTexture( texture:Texture, texture2:Texture, texture3:Texture, shader:ShaderProgram );

	/**
	 * Draw a part of the texture
	 * @param rect Rectangular area to draw in the texture
	 * @param texture Texture to draw
	 * @description It is drawn with the defaultShader.
	 */
	function drawTextureAtlas( rect:Rect, texture:Texture );

	/**
	 * Draw a part of the texture (with shader specified)
	 * @param rect Rectangular area to draw in the texture
	 * @param texture Texture to draw
	 * @param shader Shader used for drawing
	 */
	function drawTextureAtlas( rect:Rect, texture:Texture, shader:ShaderProgram );

	/**
	 * Drawing using 9patch
	 * @description The Texture used for drawing must have 9patch information loaded.
	 * Only the Texture class can be specified.
	 * @param texture Texture to draw
	 * @param width Width to draw
	 * @param height Height to draw
	 * @param shader Shader used for drawing. Optional.
	 * @return Returns margin information.
	 */
	function draw9Patch( txture:Texture, width:int, height:int, shader:ShaderProgram=null ):Rect;

	/**
	 * Default shader used for drawing textures (shader when only one texture is passed in drawTexture)
	 * @description You can set it, but basically you don't need to change it.
	 * Inserting void will return to the built-in initial default shader.
	 */
	property defaultShader;
	
	/**
	 * Default shader used when filling
	 * @description You can set it, but basically you don't need to change it.
	 * Inserting void will return to the built-in initial default shader.
	 */
	property defaultFillShader;

	/**
	 * Drawing area width
	 * @description Basically, it matches the client area, and there is a period (1 frame) that temporarily shifts from window resizing to redrawing.
	 */
	property width;
	/**
	 * Drawing area height
	 * @description Basically, it matches the client area, and there is a period (1 frame) that temporarily shifts from window resizing to redrawing.
	 */
	property height;

	/**
	 * Rectangle Rect class for clipping
	 * @description It can be called with canvas.clipRect.set (l, t, r, b); etc.
	 * Enable / disable can be set with enableClipRect
	 */
	property clipRect;

	/**
	 * Setting whether to clip with a rectangle
	 * @description When true, clipped by clipRect property
	 */
	property enableClipRect;

	/**
	 * Setting whether to perform front and back culling
	 * @description If true, do, false, do not, default is false.
	 */
	property enableCulling;

	/**
	 * Flash drawing
	 * @description It is used when replacing the renderTarget that you want to reflect the drawing.
	 * If you swap renderTargets during onDraw, flush is called internally, so no explicit call is needed.
	 */
	function flush();

	/**
	 * Text drawing (not implemented)
	 * @param font font
	 * @param x X position
	 * @param y Y position
	 * @param text text
	 * @param color Color specification
	 */
	function drawText(font:Font, x:int, y:int, text:string, color:int);
};

