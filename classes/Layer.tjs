/**
 * @description The Layer class is a class for managing layers.
 */
class Layer {
	/**
	 * Building a Layer object
	 *
	 * @param window Specifies the window (an object of the Window class) that will own this layer.
	 * Once the window is determined, it cannot be changed.
	 * @param parent Specifies the layer that will be the parent of this layer. If null is specified, it will be the primary layer.
	 * There can only be one primary layer in a window, and it is the parent layer of all layers that must exist when using layers.
	 * However, some drawing devices (configurable in Window.drawDevice) allow windows to have multiple primary layers.
	 * The parent of the layer can be changed with the Layer.parent property.
	 * @description Build an object of Layer class. The Layer class is built in a hidden state.
	 */
	function Layer( window, parent);

	/**
	 * The layer was clicked
	 *
	 * @param x The x-coordinate value (in the layer's display coordinates) where the layer was clicked.
	 * @param y The y-coordinate value (in the layer's display coordinates) where the layer was clicked.
	 * @description Occurs when a layer is clicked.
	 * @see Layer.onMouseDown
	 * @see Layer.onDoubleClick
	 */
	event onClick( x, y);

	/**
	 * The layer was double-clicked
	 *
	 * @param x The x-coordinate value (in the layer's display coordinates) where the layer was double-clicked.
	 * @param y The y-coordinate value (in the layer's display coordinates) where the layer was double-clicked.
	 * @description Occurs when a layer is double-clicked.
	 * @see Layer.onClick
	 */
	event onDoubleClick( x, y);

	/**
	 * Mouse button pressed
	 *
	 * @param x The x-coordinate value (in the layer's display coordinates) where the mouse button was pressed.
	 * @param y The value of the y coordinate (in the layer's display coordinates) where the mouse button was pressed.
	 * @param button The pressed mouse button.
	 * It can be one of the following values:
	 *
	 * + mbLeft    : The left mouse button was pressed
	 * + mbMiddle  : The middle mouse button was pressed
	 * + mbRight   : Right mouse button pressed
	 * + mbX1      : Mouse side key 1st button pressed
	 * + mbX2      : Mouse side key 2nd button pressed
	 *
	 * @param shift This is the state of the shift key that was pressed at the same time when the mouse button was pressed.
	 * It is a combination of the following values by bit OR.
	 *
	 * + ssAlt     : The ALT key was pressed
	 * + ssShift   : The SHIFT key was pressed
	 * + ssCtrl    : CTRL key was pressed
	 *
	 * @description Occurs when the mouse button is pressed.
	 * @see Layer.onClick
	 */
	event onMouseDown( x, y, button, shift);

	/**
	 * Mouse button released
	 *
	 * @param x The x-coordinate value (in the layer's display coordinates) where the mouse button is released.
	 * @param y The y-coordinate value (in the layer's display coordinates) where the mouse button is released.
	 * @param button The released mouse button.
	 * It can be one of the following values:
	 *
	 * + mbLeft    : Left mouse button released
	 * + mbMiddle  : The middle mouse button was released
	 * + mbRight   : The right mouse button was released
	 * + mbX1      : Mouse side key 1st button released
	 * + mbX2      : Mouse side key 2nd button released
	 *
	 * @param shift This is the state of the shift key that was pressed at the same time when the mouse button was released.
	 * It is a combination of the following values by bit OR.
	 *
	 * + ssAlt     : The ALT key was pressed
	 * + ssShift   : The SHIFT key was pressed
	 * + ssCtrl    : CTRL key was pressed
	 *
	 * @description Occurs when the mouse button is released.
	 */
	event onMouseUp( x, y, button, shift);

	/**
	 * The mouse has moved
	 *
	 * @param x The x-coordinate (in the layer's display coordinates) value of where the mouse was moved.
	 * @param y The y-coordinate value (in the layer's display coordinates) where the mouse was moved.
	 * @param shift This is the state of shift keys and mouse buttons that were pressed at the same time when the mouse was moving.
	 * It is a combination of the following values by bit OR.
	 *
	 * + ssAlt     : The ALT key was pressed
	 * + ssShift   : The SHIFT key was pressed
	 * + ssCtrl    : CTRL key was pressed
	 * + ssLeft    : The left mouse button was pressed
	 * + ssMiddle  : The middle mouse button was pressed
	 * + ssRight   : The right mouse button was pressed
	 *
	 * @description Occurs when the mouse moves.
	 */
	event onMouseMove( x, y, shift);

	/**
	 * The mouse came in
	 *
	 * @description Occurs when the mouse enters the area of the layer.
	 * @see Layer.onMouseLeave
	 */
	event onMouseEnter( );

	/**
	 * The mouse came out
	 *
	 * @description Occurs when the mouse exits the area of the layer.
	 * @see Layer.onMouseEnter
	 */
	event onMouseLeave( );

	/**
	 * Mouse wheel rotated
	 *
	 * @param shift This is the state of shift keys and mouse buttons that were pressed at the same time when the mouse was moving.
	 * It is a combination of the following values by bit OR.
	 *
	 * + ssAlt     : The ALT key was pressed
	 * + ssShift   : The SHIFT key was pressed
	 * + ssCtrl    : CTRL key was pressed
	 * + ssLeft    : The left mouse button was pressed
	 * + ssMiddle  : The middle mouse button was pressed
	 * + ssRight   : The right mouse button was pressed
	 *
	 * @param delta The angle of rotation of the wheel.
	 * If it is turned upward (the direction opposite to the user), it will be a positive value, and if it is turned downward (the direction toward the user), it will be a negative value.
	 * The minimum amount is usually 120.
	 * @param x The x-coordinate (in the layer's display coordinates) value of where the wheel was rotated.
	 * @param y The y-coordinate value (in the layer's display coordinates) where the wheel was rotated.
	 * @description Occurs when the mouse wheel rotates.
	 * This event, like the keyboard event, only fires on the layer that has focus.
	 */
	event onMouseWheel( shift, delta, x, y);

	/**
	 * The key was pressed
	 *
	 * @param key The value of the virtual key code of the pressed key.
	 * @param shift This is the state of shift-type keys and mouse buttons that were pressed at the same time when the keys were pressed.
	 * It is a combination of the following values by bit OR.
	 *
	 * + ssAlt     : The ALT key was pressed
	 * + ssShift   : The SHIFT key was pressed
	 * + ssCtrl    : CTRL key was pressed
	 * + ssLeft    : The left mouse button was pressed
	 * + ssMiddle  : The middle mouse button was pressed
	 * + ssRight   : The right mouse button was pressed
	 *
	 * Also, if the keyboard is pressed for a long time and key repeat occurs, the following values are also combined.
	 *
	 * + ssRepeat  : Key repeat occurred
	 *
	 * @param process If you pass false to this argument when calling onKeyDown of the parent class, the parent class will not do the default processing for that key (such as moving focus).
	 * @description Occurs when a key is pressed.
	 */
	event onKeyDown( key, shift, process=true);

	/**
	 * The key was released
	 *
	 * @param key The value of the virtual key code for the released key.
	 * @param shift This is the state of shift keys and mouse buttons that were pressed at the same time when the keys were released.
	 * It is a combination of the following values by bit OR.
	 *
	 * + ssAlt     : The ALT key was pressed
	 * + ssShift   : The SHIFT key was pressed
	 * + ssCtrl    : CTRL key was pressed
	 * + ssLeft    : The left mouse button was pressed
	 * + ssMiddle  : The middle mouse button was pressed
	 * + ssRight   : The right mouse button was pressed
	 *
	 * @param process If you pass false to this argument when calling onKeyUp of the parent class, the parent class will not do the default processing for that key (such as moving focus).
	 * @description Occurs when the key is released.
	 */
	event onKeyUp( key, shift, process=true);

	/**
	 * Characters have been entered
	 *
	 * @param key The entered character.
	 * @param process If you pass false to this argument when calling onKeyPress of the parent class, the parent class will not do the default processing for that key (such as moving focus).
	 * @description Occurs when characters are entered.
	 * Unlike Layer.onKeyDown, onKeyDown handles virtual keycodes, whereas this event handles the characters themselves.
	 * This event does not occur if the key pressed is a key that has nothing to do with the character (such as a function key).
	 */
	event onKeyPress( key, process=true);

	/**
	 * collision detection
	 *
	 * @param x The x coordinate (within the display coordinates of the layer) of the position where collision detection is performed.
	 * @param y The y coordinate (within the display coordinates of the layer) at the position where collision detection is performed.
	 * @param hit As a result of the hit judgment, if it is hit, it will be true, and if it is not, it will be false.
	 * Pass the collision result to this argument of the superclass event of the same name.
	 * @description Called when a collision detection (hit test) is performed on a point in the layer.
	 * For the result of the collision detection, pass the result of the collision detection to the third argument of this event of the superclass (pass the first argument and the second argument as they are).
	 * As a result of collision detection, if it hits, the mouse message becomes opaque and processed in that layer.
	 * If not hit, it will be transparent and the mouse message will be processed in a deeper layer.
	 * This event is called after the collision detection performed by Layer.hitThreshold and Layer.hitType determines that it is "hit".
	 * Therefore, this event will not be called if the Layer.hitThreshold or Layer.hitType determines that it is "not hit".
	 */
	event onHitTest( x, y, hit);

	/**
	 * Lost focus
	 *
	 * @param focused A layer object with a new focus.
	 * @description Called when a layer loses focus.
	 */
	event onBlur( focused);

	/**
	 * Got focus
	 *
	 * @param focused A layer object that has lost focus.
	 * @param direction True if the focus is changed by a backward search of the focus, false if it is done by a forward search of the focus.
	 * @description Called when the layer gets focus.
	 */
	event onFocus( focused, direction);

	/**
	 * Node becomes inoperable
	 *
	 * @description Called when a layer becomes inoperable because the Layer.enabled property of that layer or a layer above it (parent-child relationship) has changed.
	 */
	event onNodeDisabled( );

	/**
	 * The node is now operational
	 *
	 * @description Called when a layer becomes operational because the Layer.enabled property of that layer or a layer above it (parent-child relationship) has changed.
	 */
	event onNodeEnabled( );

	/**
	 * Search forward for focusable layers
	 *
	 * @param layer A layer object that receives focus. Specify as an argument when calling the method with the same name in the parent class.
	 * If you pass null, it will be treated as no focusable layer.
	 * @description This event occurs when performing a forward search for a focusable layer.
	 * When specifying the layer that receives focus, specify that layer in the argument of the event with the same name in the superclass.
	 */
	event onSearchPrevFocusable( layer);

	/**
	 * Search backwards for focusable layers
	 *
	 * @param layer A layer object that receives focus.
	 * Specify as an argument when calling the method with the same name in the parent class.
	 * If you pass null, it will be treated as no focusable layer.
	 * @description This event occurs when performing a backward search for a focusable layer.
	 * When specifying the layer that receives focus, specify that layer in the argument of the event with the same name in the superclass.
	 */
	event onSearchNextFocusable( layer);

	/**
	 * Immediately before receiving focus
	 *
	 * @param layer A layer object that receives focus.
	 * Normally this is passed, but you can have the focus passed to that layer by specifying a different layer object when calling the event of the same name in the superclass.
	 * @param blurred A layer object that loses focus.
	 * @param direction True if the focus is changed by a backward search of the focus, false if it is done by a forward search of the focus.
	 * @description This event occurs just before receiving focus.
	 * When specifying the layer that receives the focus, that layer can be specified in the first argument of the event with the same name in the superclass.
	 */
	event onBeforeFocus( layer, blurred, direction);

	/**
	 * When drawn
	 *
	 * @description Called just before the layer is actually drawn in the window.
	 * This event is only called when the Layer.callOnPaint property is true, and Layer.callOnPaint is automatically set to false after the event has finished executing.
	 * @see Layer.update
	 */
	event onPaint( );

	/**
	 * The transition is over
	 *
	 * @param dest The layer object to transition to (usually this) is passed.
	 * @param src The layer object from which the transition is made is passed.
	 * It can be null depending on the type of transition.
	 * @description Called when the transition is over.
	 */
	event onTransitionCompleted( dest, src);

	/**
	 * The screen was touched
	 *
	 * @param x The x-coordinate (in client coordinates) value of the touched position.
	 * @param y The y-coordinate (in client coordinates) value of the touched position.
	 * @param cx The number of horizontal pixels that the finger is in contact with.
	 * Always 1 if the device does not support it.
	 * @param cy The number of vertical pixels that the finger is in contact with.
	 * Always 1 if the device does not support it.
	 * @param id Touch ID.
	 * At the time of multi-touch, a unique value is set for each position, and the position can be identified by this ID.
	 * @description Occurs when the touch panel is touched.
	 * This event occurs when the X, Y coordinates are in this layer.
	 */
	event onTouchDown( x, y, cx, cy, id);

	/**
	 * Your finger was released from the screen
	 *
	 * @param x The x-coordinate (in client coordinates) value of the separated position.
	 * @param y The y-coordinate (in client coordinates) value of the separated position.
	 * @param cx The number of horizontal pixels that the finger is in contact with.
	 * Always 1 if the device does not support it.
	 * @param cy The number of vertical pixels that the finger is in contact with.
	 * Always 1 if the device does not support it.
	 * @param id Touch ID.
	 * At the time of multi-touch, a unique value is set for each position, and the position can be identified by this ID.
	 * @description Occurs when the finger is released from the touch panel.
	 * This event occurs when the X, Y coordinates are in this layer.
	 * However, unlike the mouse, it is determined by the current coordinates, so it may not be the same as the layer where onTouchDown occurred.
	 */
	event onTouchUp( x, y, cx, cy, id);

	/**
	 * The finger has moved
	 *
	 * @param x The x-coordinate (in client coordinates) value of the touch position.
	 * @param y The y-coordinate (in client coordinates) value of the touch position.
	 * @param cx The number of horizontal pixels that the finger is in contact with.
	 * Always 1 if the device does not support it.
	 * @param cy The number of vertical pixels that the finger is in contact with.
	 * Always 1 if the device does not support it.
	 * @param id Touch ID.
	 * At the time of multi-touch, a unique value is set for each position, and the position can be identified by this ID.
	 * @description It occurs when the finger touching on the touch panel moves.
	 * This event occurs when the X, Y coordinates are in this layer.
	 * However, unlike the mouse, it is determined by the current coordinates, so it may not be the same as the layer where onTouchDown occurred.
	 */
	event onTouchMove( x, y, cx, cy, id);

	/**
	 * Enlarged operation
	 *
	 * @param startdistance The pixel distance when multi-touch is started.
	 * @param currentdistance The pixel distance of the touch when the event occurs.
	 * @param cx The x-coordinate (in client coordinates) value of the center position.
	 * @param cy The y-coordinate (in client coordinates) value of the center position.
	 * @param flag Multi-touch status flag.
	 *
	 * + 0x01     : It is set to the first event when multi-touch is started.
	 *
	 * @description It occurs when the enlargement operation is performed by multi-touch on the touch panel.
	 * This event occurs on the layer with focus.
	 */
	event onTouchScaling( startdistance, currentdistance, cx, cy, flag);

	/**
	 * Rotated
	 *
	 * @param startangle The radian angle when multi-touch is started.
	 * @param currentangle The radian angle of the touch when an event occurs.
	 * @param distance The pixel distance of the touch when the event occurs.
	 * @param cx The x-coordinate (in client coordinates) value of the center position.
	 * @param cy The y-coordinate (in client coordinates) value of the center position.
	 * @param flag Multi-touch status flag.
	 *
	 * + 0x01     : It is set to the first event when multi-touch is started.
	 *
	 * @description Occurs when rotating on the touch panel by multi-touch.
	 * This event occurs on the layer with focus.
	 */
	event onTouchRotate( startangle, currentangle, distance, cx, cy, flag);

	/**
	 * Multi-touch state changed
	 *
	 * @description Occurs when the multi-touch state starts, moves, or moves away.
	 * Coordinate information can be obtained with the Window.touchPointCount property and the Window.getTouchPoint method.
	 * This event occurs on the layer with focus.
	 * @see Window.getTouchPoint
	 * @see Window.touchPointCount
	 */
	event onMultiTouch( );

	/**
	 * Move to the front of the specified layer
	 *
	 * @param layer Moves to the front of the layer specified here.
	 * Only sibling layers (layers with the same parent) can be specified.
	 * @description Moves to the front of the specified layer in the overlay order.
	 * This method sets the Layer.absoluteOrderMode property to false.
	 */
	function moveBefore( layer);

	/**
	 * Move to the back of the specified layer
	 *
	 * @param layer Moves to the back of the layer specified here.
	 * Only sibling layers (layers with the same parent) can be specified.
	 * @description Moves to the back of the specified layer in the overlay order.
	 * This method sets the Layer.absoluteOrderMode property to false.
	 */
	function moveBehind( layer);

	/**
	 * Move to the back
	 *
	 * @description In the stacking order, it moves to the back of the sibling layers (layers with the same parent).
	 * Executing this method sets the Layer.absoluteOrderMode property of the parent layer to false.
	 * @see Layer.order
	 * @see Layer.absolute
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToFront
	 */
	function bringToBack( );

	/**
	 * Move to the front
	 *
	 * @description In the stacking order, it moves to the front of the sibling layers (layers with the same parent).
	 * Executing this method sets the Layer.absoluteOrderMode property of the parent layer to false.
	 * @see Layer.order
	 * @see Layer.absolute
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToBack
	 */
	function bringToFront( );

	/**
	 * Image loading
	 *
	 * @param image Specify the image storage to read.
	 * If there is an image storage with _m added to the storage name (excluding the extension) specified here, it will be read as a mask (opacity) image.
	 * If there is an image storage with _p added to the storage name (excluding the extension) specified here, it will be read as an area image.
	 * @param colorkey Specify the color key (transparent color) of the image to be imported.
	 * If you specify a color in the 0xRRGGBB format, that color is used as the color key. If you specify clPalIdx plus an arbitrary palette index, the palette index becomes transparent (for images of 256 colors or less).
	 * If you specify clAdapt, the most used color in the top line of the image is automatically made transparent.
	 * If you specify clAlphaMat plus a number that represents a color in the 0xRRGGBB format, the image is overlaid on top of that color using an alpha blend (ltAlpha method).
	 * For example, (clAlphaMat + 0xffffff) will overlay the imported image on top of the white color.
	 * All images will be opaque (note that all images will be opaque, but no tag information will be changed in this mode).
	 * @return Dictionary array of tag information
	 * @description Load the image into the layer.
	 * This method changes the image size of the layer, but does not change the display size of the layer unless the image size is smaller than the display size of the layer.
	 * As a return value, a dictionary array of tag information (information about the image itself, such as the layer type and display position of the image) is returned.
	 * Be careful not to confuse it with the meaning of "tag" in KAG.
	 * If the image has no tag information, null will be returned. In the current version, tag information can only be in PNG, TLG5 / 6 format.
	 * See Image Format Converter for the information available.
	 */
	function loadImages( image, colorkey=clNone);

	/**
	 * Loading area image
	 *
	 * @param image Specifies the image storage to read as an area image.
	 * @description Load the area image of the layer.
	 * Other images will remain as they are.
	 * An exception will be thrown if the image you are trying to load is different from the image size of the layer.
	 */
	function loadProvinceImage( image);

	/**
	 * Get the color of the main image
	 *
	 * @param x Specifies the x coordinate (in the image coordinates of the layer) to get the color.
	 * @param y Specifies the y coordinate (in the image coordinates of the layer) to get the color.
	 * @return 0xRRGGBB format color number
	 * @description Layer Gets the color at any position in the main image (the image that retains the color).
	 * An exception is thrown if you specify an invalid (out of range) position as the image coordinates.
	 */
	function getMainPixel( x, y);

	/**
	 * Main image color settings
	 *
	 * @param x Specifies the x coordinate (in the image coordinates of the layer) for which you want to set the color.
	 * @param y Specifies the y coordinate (in the image coordinates of the layer) to set the color.
	 * @param color Specify the color to be set in the 0xRRGGBB format.
	 * @description Layer Sets the color at any position on the main image (the image that retains the color).
	 * An exception is thrown if you specify an invalid (out of range) position as the image coordinates.
	 */
	function setMainPixel( x, y, color);

	/**
	 * Get the value of the mask image
	 *
	 * @param x Specifies the x coordinate (in the image coordinates of the layer) for which you want to get the value.
	 * @param y Specifies the y coordinate (in the image coordinates of the layer) for which you want to get the value.
	 * @return Mask image value (0 to 255)
	 * @description Gets the value (0 to 255) at any position in the layer mask image (the image that retains opacity).
	 * An exception is thrown if you specify an invalid (out of range) position as the image coordinates.
	 */
	function getMaskPixel( x, y);

	/**
	 * Setting the value of the mask image
	 *
	 * @param x Specifies the x coordinate (in the image coordinates of the layer) for which you want to set the value.
	 * @param y Specify the y coordinate (in the image coordinates of the layer) for which you want to set the value.
	 * @param value Specify the value to be set (0 to 255).
	 * @description Set a value (0 to 255) at any position on the layer mask image (the image that retains opacity).
	 * An exception is thrown if you specify an invalid (out of range) position as the image coordinates.
	 */
	function setMaskPixel( x, y, value);

	/**
	 * Get the value of the area image
	 *
	 * @param x Specifies the x coordinate (in the image coordinates of the layer) for which you want to get the value.
	 * @param y Specifies the y coordinate (in the image coordinates of the layer) for which you want to get the value.
	 * @return Area image value (0 to 255)
	 * @description Layer Area Gets the value (0 to 255) at any position in the image.
	 * An exception is thrown if you specify an invalid (out of range) position as the image coordinates.
	 */
	function getProvincePixel( x, y);

	/**
	 * Setting the value of the area image
	 *
	 * @param x Specifies the x coordinate (in the image coordinates of the layer) for which you want to set the value.
	 * @param y Specify the y coordinate (in the image coordinates of the layer) for which you want to set the value.
	 * @param value Specify the value to be set (0 to 255).
	 * @description Layer Area Set a value (0 to 255) at any position in the image.
	 * An exception is thrown if you specify an invalid (out of range) position as the image coordinates.
	 */
	function setProvincePixel( x, y, value);

	/**
	 * Get the layer at the specified position
	 *
	 * @param x Specify the x-coordinate of the position of the layer you want to acquire in pixels on the display coordinates.
	 * The display coordinates of the layer that executes this method are used (not the display coordinates on the primary layer).
	 * @param y Specify the y coordinate of the position of the layer you want to acquire in pixel units on the display coordinates.
	 * The display coordinates of the layer that executes this method are used (not the display coordinates on the primary layer).
	 * @param exclude_self Specifies whether to exclude itself from the layer search.
	 * If you specify false, your own layer is also included in the search.
	 * If you specify true, your own layer is excluded from the search and treated as if it did not exist.
	 * If this argument is omitted, false is assumed.
	 * @param get_disabled Specifies whether to get objects for layers that are disabled.
	 * If false is specified, null is returned if a layer that is disabled (for example, the Layer.enabled property is false) is in the specified position.
	 * If true is specified, if an invalid layer is in the specified position, that layer object is returned.
	 * If this argument is omitted, false is assumed.
	 * @return The layer object that was in the specified position.
	 * Null is returned if there is no layer at the specified position.
	 * @description Returns the layer object at the position indicated by x, y.
	 * The collision detection uses the same mechanism as the normal mouse event collision detection.
	 * In other words, the specified position is viewed from the front in the layer stacking order, and the layer corresponding to the hit judgment is returned first.
	 * You can exclude the layer that executes this method from the search by specifying true with the exclude_self argument.
	 * @see Layer.hitType
	 * @see Layer.hitThreshold
	 * @see Layer.onHitTest
	 */
	function getLayerAt( x, y, exclude_self=false, get_disabled=false);

	/**
	 * Cancel mouse event capture
	 *
	 * @description Cancels mouse event capture.
	 * Mouse event capture is a function that exclusively sends mouse events to the layer where the mouse button was first pressed until the mouse button is released.
	 * This method removes this feature and returns you to normal mouse event processing.
	 * When you execute this method, mouse capture of layers belonging to the same window is canceled even if the layer that executes the method and the layer that is being captured are different.
	 * This method does nothing if it is not in the capture state.
	 */
	function releaseCapture( );

	/**
	 * Layer display position setting
	 *
	 * @param left Specifies the leftmost position of the layer (in display coordinates of the parent layer) in pixels.
	 * This value can also be obtained and set with the Layer.left property.
	 * @param top Specifies the top position of the layer (in display coordinates of the parent layer) in pixels.
	 * This value can also be obtained and set with the Layer.top property.
	 * @param width Specifies the width of the layer in pixels.
	 * This value can also be obtained and set with the Layer.width property.
	 * If this argument and height argument are omitted, the position can only be changed by the left and top arguments.
	 * @param height Specifies the height of the layer in pixels.
	 * This value can also be obtained and set with the Layer.height property.
	 * If this argument and width argument are omitted, the position can only be changed by the left and top arguments.
	 * @description Set the display position of the layer.
	 */
	function setPos( left, top, width=void, height=void);

	/**
	 * Drawing clip rectangle settings
	 *
	 * @param left Specifies the left edge position (in image coordinates of the layer) of the drawing clip rectangle in pixels.
	 * This value can also be obtained and set with the Layer.clipLeft property.
	 * @param top Specifies the top position of the drawing clip rectangle (in the image coordinates of the layer) in pixels.
	 * This value can also be obtained and set with the Layer.clipTop property.
	 * @param width Specifies the width of the drawing clip rectangle in pixels.
	 * This value can also be obtained and set with the Layer.clipWidth property.
	 * @param height Specifies the vertical width of the drawing clip rectangle in pixels.
	 * This value can also be obtained and set with the Layer.clipHeight property.
	 * @description Sets the drawing clip rectangle for the layer. Drawing on the layer is restricted to the inside of this drawing clip rectangle (the part outside the rectangle is not drawn).
	 * However, some methods, such as Layer.flipLR and Layer.flipUD, are not affected by the drawing clip rectangle.
	 * By default, the clip rectangle is set to the entire layer image area (it can be drawn on the entire layer).
	 * The drawing clip rectangle returns to its default value when the image is loaded, the image size is changed, or the display type of the layer is changed.
	 * You can also call this method with no arguments to restore the drawing clip rectangle to its default value.
	 */
	function setClip( left, top, width=void, height=void);

	/**
	 * Layer display size setting
	 *
	 * @param width Specifies the display width of the layer in pixels.
	 * This value can also be obtained and set with the Layer.width property.
	 * @param height Specifies the vertical width of the layer display in pixels.
	 * This value can also be obtained and set with the Layer.height property.
	 * @description Sets the display size of the layer.
	 */
	function setSize( width, height);

	/**
	 * Match the layer display size to the image size
	 *
	 * @description Make the display size of the layer the same as the image size.
	 * Resizing the image Many operations do not change the display size, but you can use this method to make the display size the same as the image size.
	 */
	function setSizeToImageSize( );

	/**
	 * Layer image offset setting
	 *
	 * @param left Specifies the left edge position (x offset) of the image to display on the layer, in pixels.
	 * This value can also be obtained and set with the Layer.imageLeft property.
	 * @param top Specifies the top edge position (y offset) of the image to display on the layer, in pixels.
	 * This value can also be obtained and set with the Layer.imageTop property.
	 * @description Specifies the layer image offset.
	 * The layer image size can be larger than the layer display size, but not all can be displayed, so you will have to specify the display offset with this method and the Layer.imageLeft and Layer.imageTop properties.
	 * The offset can be 0 or a negative number.
	 */
	function setImagePos( left, top);

	/**
	 * Layer image size setting
	 *
	 * @param width Specifies the width of the layer image in pixels.
	 * This value can also be obtained and set with the Layer.imageWidth property.
	 * @param height Specifies the vertical width of the layer image in pixels.
	 * This value can also be obtained and set with the Layer.imageHeight property.
	 * @description Specifies the layer image size.
	 * When the size is increased, the display size of the layer is not changed, but when the size is reduced, the display size of the layer is also reduced.
	 */
	function setImageSize( width, height);

	/**
	 * Unsharing the main image
	 *
	 * @param copy Specifies whether to copy the original image when unsharing.
	 * If true is specified, the original image will be copied. If false is specified, the original image will not be copied and the content of the image will be undefined.
	 * @description Forcibly cancels the sharing state of the layer image.
	 * Kirikiri When you copy an entire image to another layer with assignImages etc., the same image will be shared without actually copying the image buffer.
	 * Normally, this sharing state is automatically released just before you try to make changes to the image, but you can force it to be released with this method.
	 * If you specify false for the copy argument, the image is unshared, but the original image is not guaranteed to be inherited (the content of the image is undefined), but the unsharing is done faster. can do.
	 * Since it is not necessary to inherit the original image when rewriting the entire image of the layer, it may be more efficient to call this method with false specified in advance before drawing.
	 * This method does nothing if the image is not shared.
	 */
	function independMainImage( copy=true);

	/**
	 * Canceling sharing of area images
	 *
	 * @param copy Specifies whether to copy the original image when unsharing.
	 * If true is specified, the original image will be copied.
	 * If false is specified, the original image will not be copied and the content of the image will be undefined.
	 * @description Forcibly cancels the sharing state of the area image.
	 * Kirikiri When you copy an entire image to another layer with assignImages etc., the same image will be shared without actually copying the image buffer.
	 * Normally, this sharing state is automatically released just before you try to make changes to the image, but you can force it to be released with this method.
	 * If you specify false for the copy argument, the image is unshared, but the original image is not guaranteed to be inherited (the content of the image is undefined), but the unsharing is done faster. can do.
	 * Since it is not necessary to inherit the original image when rewriting the entire image of the layer, it may be more efficient to call this method with false specified in advance before drawing.
	 * This method does nothing if the image is not shared.
	 */
	function independProvinceImage( copy=true);

	/**
	 * Rectangle fill
	 *
	 * @param left Specifies the left edge position of the fill rectangle in pixels (at the image position).
	 * @param top Specifies the top position of the rectangle to fill in pixels (at the image position).
	 * @param width Specifies the width of the rectangle to fill in pixels (at the image position).
	 * @param height Specifies the height of the rectangle to fill, in pixels (at the image position).
	 * @param value Specify the fill color and value.
	 * This value depends on the value of the Layer.face property.
	 *
	 * + dfAlpha (Or dfBoth)      : Specify the opacity and color in the 0xAARRGGBB format. Both the main and the mask are filled.
	 * + dfAddAlpha               : Specify the opacity and color in the 0xAARRGGBB format. Both the main and the mask are filled.
	 * + dfOpaque (Or dfMain)     : Specify the color in 0xRRGGBB format. When the Layer.holdAlpha property is true, only the main is filled and the mask remains. When false, it accepts opacity and color specifications in 0xAARRGGBB format, as with dfAlpha and dfAddAlpha, and fills both the main and mask.
	 * + dfMask                   : Specify a mask (opacity) value (0 to 255). Only the mask is filled and the main remains.
	 * + dfProvince               : Specify a region value (0 to 255). Only the area is filled.
	 *
	 * @description Fills the rectangle of the specified layer image in the specified way.
	 */
	function fillRect( left, top, width, height, value);

	/**
	 * Rectangle translucent fill
	 *
	 * @param left Specifies the left edge position of the fill rectangle in pixels (at the image position).
	 * @param top Specifies the top position of the rectangle to fill in pixels (at the image position).
	 * @param width Specifies the width of the rectangle to fill in pixels (at the image position).
	 * @param height Specifies the height of the rectangle to fill, in pixels (at the image position).
	 * @param value Specify the fill color and value.
	 * This value depends on the value of the Layer.face property.
	 *
	 * + dfAlpha (Or dfBoth)           : Specify the color in 0xRRGGBB format
	 * + dfAddAlpha                    : Specify the color in 0xRRGGBB format
	 * + dfOpaque (Or dfMain)          : Specify the color in 0xRRGGBB format
	 * + dfMask                        : Specify a mask (opacity) value (0 to 255)
	 * + dfProvince                    : Specify a region value (0 to 255) If you specify dfOpaque, the mask information is ignored (whether the mask information is retained or destroyed depends on the Layer.holdAlpha property). Also, if you specify dfMask, the color information remains the same. This argument is ignored for dfAlpha and if opa is negative.
	 *
	 * @param opa Specifies the opacity to fill (-255 to 0 to 255).
	 * This argument is ignored if the value of the Layer.face property is dfMask or dfProvince (always completely opaque).
	 * Negative numbers are valid only if Layer.face is dfAlpha, in which case the value argument is ignored and the image is stripped of opacity (-255 makes the rectangle completely transparent). ..
	 * @description Fills the rectangle of the specified layer image in the specified way.
	 * Unlike Layer.fillRect, you can specify transparency to fill with translucency.
	 */
	function colorRect( left, top, width, height, value, opa=255);

	/**
	 * Character drawing
	 *
	 * @param x Specifies the x-coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param y Specifies the y coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param text Specify the character to draw.
	 * @param color Specifies the color of the characters to draw in the 0xRRGGBB format.
	 * @param opa Specifies the opacity (-255 to 0 to 255) of the characters to draw.
	 * Negative numbers are only valid if Layer.face is dfAlpha, which removes the opacity of the character shape (the smaller the value, the greater the effect).
	 * @param aa Specifies whether to perform antialiasing.
	 * If true is specified, antialiasing will be performed.
	 * If you specify false, it will not be done.
	 * @param shadowlevel Specifies the opacity of the shadow.
	 * The appropriate value will vary depending on the value of the shadowwidth argument.
	 * If you specify 0, no shadow is drawn.
	 * @param shadowcolor Specifies the shadow color in 0xRRGGBB format.
	 * @param shadowwidth Specifies the shadow width (blurring).
	 * 0 is the sharpest (no blur), and increasing the value will blur the shadow.
	 * @param shadowofsx Specifies the x-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @param shadowofsy Specifies the y-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @description Draws characters on the layer.
	 * It can only be drawn if the Layer.face is dfAlpha (or dfBoth), dfAddAlpha, or dfOpaque (or dfMain).
	 * If you specify dfOpaque (or dfMain), it depends on the Layer.holdAlpha property whether the mask to which it is drawn is destroyed or protected.
	 * The font specified in Layer.font is used.
	 */
	function drawText( x, y, text, color, opa=255, aa=true, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0);

	/**
	 * Character drawing
	 *
	 * @param x Specifies the x-coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param y Specifies the y coordinate (at the image position) of the origin where the character drawing starts, in pixels.
	 * @param glyph Specifies the glyph to draw.
	 * @param color Specifies the color of the characters to draw in the 0xRRGGBB format.
	 * @param opa Specifies the opacity (-255 to 0 to 255) of the characters to draw.
	 * Negative numbers are only valid if face is dfAlpha, in which case the opacity of the character shape will be removed (the smaller the value, the greater the effect).
	 * @param aa Specifies whether to perform antialiasing.
	 * If true is specified, antialiasing will be performed.
	 * If you specify false, it will not be done.
	 * @param shadowlevel Specifies the opacity of the shadow.
	 * The appropriate value will vary depending on the value of the shadowwidth argument.
	 * If you specify 0, no shadow is drawn.
	 * @param shadowcolor Specifies the shadow color in 0xRRGGBB format.
	 * @param shadowwidth Specifies the shadow width (blurring).
	 * 0 is the sharpest (no blur), and increasing the value will blur the shadow.
	 * @param shadowofsx Specifies the x-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @param shadowofsy Specifies the y-coordinate value of the shadow position, in pixels.
	 * If you specify 0, the shadow is drawn directly below.
	 * @description Draw a glyph on the layer.
	 * A glyph specifies an array of the form glyph: Array [9] = [width, height, originx, originy, incx, incy, inc, bitmap (Octet), colors].
	 * If the glyph colors are omitted, it is considered to be 256 gradations.
	 */
	function drawGlyph( x, y, glyph, color, opa=255, aa=true, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0);

	/**
	 * Rectangle copy
	 *
	 * @param dleft Specifies the left edge position of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param dtop Specifies the top position of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param src Specifies the layer object to copy from.
	 * You can also specify an object of the Bitmap class.
	 * @param sleft Specifies the left edge position of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param stop Specifies the top position of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param swidth Specifies the width of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param sheight Specifies the height of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @description Copies the rectangular part of the specified copy source layer to the specified position of your layer.
	 * The image that is copied depends on the value of the Layer.face property of the destination layer (the layer that executes the method).
	 *
	 * + dfAlpha (Or dfBoth)     : The main image and mask image are copied
	 * + dfAddAlpha              : The main image and mask image are copied
	 * + dfOpaque (Or dfMain)    : If the Layer.holdAlpha property is true, only the main image will be copied (the mask image will not be copied). If false, the main image and mask image will be copied
	 * + dfMask                  : Only the mask image is copied (the main image is not copied)
	 * + dfProvince              : Only the area image is copied (mask image and main image are not copied) The Layer.face property of the source layer is ignored. This method is not affected by Layer.holdAlpha (in the case of dfAlpha and dfAddAlpha, the mask image is also copied regardless of holdAlpha).
	 */
	function copyRect( dleft, dtop, src, sleft, stop, swidth, sheight);

	/**
	 * Image copy using 9 path
	 *
	 * @param src Specifies the layer object to copy from.
	 * You can also specify an object of Bitmap class.
	 * @return Margin information
	 * @description 9 Make an image copy using path (slice).
	 * The margin information returned is an object of class Rect.
	 */
	function copy9Patch( src);

	/**
	 * Copy the image with the layers superimposed
	 *
	 * @param dleft Specifies the left edge position of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param dtop Specifies the top position of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param src Specifies the layer object to copy from.
	 * @param sleft Specifies the left edge position of the rectangle to copy, in pixels (at the display position of the source layer).
	 * @param stop Specifies the top position of the rectangle to copy, in pixels (at the display position of the source layer).
	 * @param swidth Specifies the width of the rectangle to copy, in pixels (at the display position of the source layer).
	 * @param sheight Specifies the vertical width of the rectangle to copy, in pixels (at the display position of the source layer).
	 * @description Superimposes the specified rectangular part of the specified copy source layer including the child layer, and copies the resulting image to the specified position of your own layer.
	 * This method is not affected by the Layer.face property of the source or destination layer.
	 * .
	 */
	function piledCopy( dleft, dtop, src, sleft, stop, swidth, sheight);

	/**
	 * Rectangle arithmetic composition
	 *
	 * @param dleft Specifies the left edge position of the calculation destination rectangle in pixels (at the image position of the calculation destination layer).
	 * @param dtop Specifies the top position of the calculation destination rectangle in pixels (at the image position of the calculation destination layer).
	 * @param src Specify the layer object from which the operation is performed.
	 * You can also specify an object of the Bitmap class.
	 * @param sleft Specifies the left edge position of the rectangle to be calculated, in pixels (at the image position of the calculation source layer).
	 * @param stop Specifies the top position of the rectangle to be calculated, in pixels (at the image position of the calculation source layer).
	 * @param swidth Specifies the width of the rectangle to be calculated, in pixels (at the image position of the calculation source layer).
	 * @param sheight Specifies the vertical width of the rectangle to be calculated, in pixels (at the image position of the calculation source layer).
	 * @param mode Specifies the operation mode.
	 *
	 * + If omAuto is specified, the operation type is automatically determined according to the Layer.type property of the operation source layer.
	 * + If omPsNormal is specified, Photoshop compatible alpha compositing is done.
	 * + If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is done.
	 * + If omPsSubtractive is specified, Photoshop compatible burn (linear) compositing is performed.
	 * + If omPsMultiplicative is specified, Photoshop compatible multiplication and composition will be performed.
	 * + If omPsScreen is specified, Photoshop compatible screen composition will be performed.
	 * + If omPsOverlay is specified, Photoshop compatible overlay compositing is done.
	 * + If omPsHardLight is specified, Photoshop compatible hard light composition will be performed.
	 * + If omPsSoftLight is specified, Photoshop compatible softlight compositing will be performed.
	 * + If omPsColorDodge is specified, Photoshop compatible dodge color composition will be performed.
	 * + If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed.
	 * + If omPsColorBurn is specified, Photoshop compatible burn-in color composition will be performed.
	 * + If omPsLighten is specified, Photoshop compatible comparison (bright) compositing is performed.
	 * + If omPsDarken is specified, Photoshop compatible comparison (dark) compositing is done.
	 * + If omPsDifference is specified, Photoshop compatible absolute difference composition is performed.
	 * + If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x and below is performed.
	 * + If omPsExclusion is specified, Photoshop compatible exclusion composition is performed.
	 * + If omAdditive is specified, additive synthesis is performed.
	 * + If omSubtractive is specified, subtractive synthesis will be performed.
	 * + If omMultiplicative is specified, multiplication synthesis is performed.
	 * + If omDodge is specified, dodging synthesis will be performed.
	 * + If omDarken is specified, comparative (dark) compositing is done.
	 * + If omLighten is specified, comparison (bright) composition will be performed.
	 * + If omScreen is specified, screen multiplication composition is performed.
	 * + If omAlpha is specified, alpha synthesis will occur.
	 * + If omAddAlpha is specified, additive alpha composition is done.
	 * + If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque.
	 *
	 * @param opa Specifies the intensity of the operation (0 to 255).
	 * @description Computes the rectangular part of the specified calculation source layer at the specified position of your layer in the specified mode.
	 * The value of the Layer.face property of the calculation destination layer (which executes the method) and the calculation source layer is ignored.
	 * If omAuto is specified for mode, the operation type is automatically determined according to the Layer.type property of the operation source layer.
	 */
	function operateRect( dleft, dtop, src, sleft, stop, swidth, sheight, mode=omAuto, opa=255);

	/**
	 * Enlargement / reduction copy
	 *
	 * @param dleft Specifies the left edge position of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param dtop Specifies the top position of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param dwidth Specifies the width of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param dheight Specifies the height of the destination rectangle in pixels (at the image position of the destination layer).
	 * @param src Specifies the layer object to copy from.
	 * You can also specify an object of the Bitmap class.
	 * @param sleft Specifies the left edge position of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param stop Specifies the top position of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param swidth Specifies the width of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param sheight Specifies the height of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param type Specifies the scale type.
	 *
	 * + stNearest           : Nearest point method is used
	 * + stFastLinear        : Low precision linear interpolation is used (partially implemented)
	 * + stSemiFastLinear    : Fixed decimal linear interpolation is used
	 * + stLinear            : Linear interpolation is used
	 * + stFastCubic         : Fixed decimal 3D interpolation is used
	 * + stCubic             : 3D interpolation is used
	 * + stFastLanczos2      : Fixed decimal Lanczos interpolation range 4x4 is used
	 * + stLanczos2          : Lanczos interpolation range 4x4 is used
	 * + stFastLanczos3      : Fixed decimal Lanczos interpolation range 6x6 is used
	 * + stLanczos3          : Lanczos interpolation range 6x6 is used
	 * + stFastSpline16      : Fixed decimal spline interpolation 4x4 is used
	 * + stSpline16          : Spline interpolation 4x4 is used
	 * + stFastSpline36      : Fixed decimal spline interpolation 6x6 is used
	 * + stSpline36          : Spline interpolation 6x6 is used
	 * + stFastAreaAvg       : Fixed decimal area mean reduction is used. Cannot be expanded
	 * + stAreaAvg           : Area average reduction is used. Cannot be expanded
	 * + stFastGaussian      : Fixed decimal Gaussian interpolation 4x4 is used
	 * + stGaussian          : Gaussian interpolation 4x4 is used
	 * + stFastBlackmanSinc  : Fixed decimal Blackman-Sinc interpolation 8x8 is used
	 * + stBlackmanSinc      : Blackman-Sinc interpolation 8x8 is used
	 *
	 * The speed is faster in the order of stNearest> stFastLinear> stLinear> stCubic, but the faster the speed, the lower the image quality.
	 * The interpolation method after stCubic has sufficiently high image quality and can be said to be a difference in taste.
	 * However, the image quality will be blurry for Gaussian interpolation.
	 * The difference between stFastLinear and other linear interpolations (stSemiFastLinear and stLinear) is large when shrinking.
	 * While stFastLinear always refers to the surrounding 4 pixels, stSemiFastLinear and stLinear refer to and interpolate a range in which the influence range at 1x magnification is 4 pixels at the time of reduction, that is, a wider range of pixels. Higher image quality (algorithm is the original linear interpolation).
	 * For stFastLinear, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.
	 * If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).
	 * @param option Sharpness during 3D interpolation.
	 * It currently has no meaning with other interpolation methods.
	 * Increasing the sharpness value in the positive direction will make it blurry, and increasing it in the negative direction will make it sharper.
	 * @description Copies the rectangle of the specified source layer to the rectangle of the destination (layer that executes the method).
	 * If the copy source rectangle and the copy destination rectangle are different in size, they will be enlarged or reduced.
	 * In the current version, linear interpolation is effective when stFastLinear is specified when the Layer.face property of the layer to be overlaid (which executes the method) is dfAlpha (or dfBoth) or dfAddAlpha.
	 * Linear interpolation is also possible when the Layer.face property is dfOpaque and the Layer.holdAlpha property is false.
	 * Also, in the current version, the specification of stLinear or stCubic is valid only when the destination rectangle does not extend beyond the layer without horizontal / vertical inversion.
	 * If the Layer.face property of the layer to which you want to overlay (execute the method) is dfAlpha (or dfBoth) or dfAddAlpha, both the main image and the mask image are copied.
	 * For dfOpaque (or dfMain), only the main image is copied when the Layer.holdAlpha property is true, and both the main image and the mask image are copied when false.
	 */
	function stretchCopy( dleft, dtop, dwidth, dheight, src, sleft, stop, swidth, sheight, type=stNearest, option=-1.0);

	/**
	 * Enlargement / reduction operation composition
	 *
	 * @param dleft Specifies the left edge position of the overlay destination rectangle in pixels (at the image position of the overlay destination layer).
	 * @param dtop Specifies the top position of the overlay rectangle in pixels (at the image position of the overlay layer).
	 * @param dwidth Specifies the width of the overlay rectangle in pixels (at the image position of the overlay layer).
	 * @param dheight Specifies the vertical width of the overlay destination rectangle in pixels (at the image position of the overlay destination layer).
	 * @param src Specifies the layer object to overlay.
	 * You can also specify an object of the Bitmap class.
	 * @param sleft Specifies the left edge position of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param stop Specifies the top position of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param swidth Specifies the width of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param sheight Specifies the vertical width of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param mode Specifies the operation mode.
	 *
	 * + If omAuto is specified, the operation type is automatically determined according to the Layer.type property of the operation source layer.
	 * + If omPsNormal is specified, Photoshop compatible alpha compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omPsSubtractive is specified, Photoshop compatible burn-in (linear) compositing is performed (implemented other than stNearest and stFastLinear).
	 * + If omPsMultiplicative is specified, Photoshop compatible multiplication composition is performed (implemented other than stNearest and stFastLinear).
	 * + If omPsScreen is specified, Photoshop compatible screen composition will be performed (implemented other than stNearest and stFastLinear).
	 * + If omPsOverlay is specified, Photoshop compatible overlay compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omPsHardLight is specified, Photoshop compatible hard light composition will be performed (implemented other than stNearest and stFastLinear).
	 * + If omPsSoftLight is specified, Photoshop compatible soft light composition will be performed (implemented other than stNearest and stFastLinear).
	 * + If omPsColorDodge is specified, Photoshop compatible dodge color composition is performed (implemented other than stNearest and stFastLinear).
	 * + If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed (implemented outside of stNearest and stFastLinear).
	 * + If somPsColorBurn is specified, Photoshop compatible burn-in color composition is performed (implemented other than stNearest and stFastLinear).
	 * + If omPsLighten is specified, Photoshop compatible comparison (bright) compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omPsDarken is specified, Photoshop compatible comparison (dark) compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omPsDifference is specified, Photoshop compatible absolute difference composition is done (implemented outside of stNearest and stFastLinear).
	 * + If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x and below is performed (implemented other than stNearest and stFastLinear).
	 * + If omPsExclusion is specified, Photoshop compatible exclusion composition is performed (implemented other than stNearest and stFastLinear).
	 * + If omAdditive is specified, additive synthesis is performed (implemented outside of stNearest and stFastLinear).
	 * + If omSubtractive is specified, subtractive synthesis will be performed (implemented outside of stNearest and stFastLinear).
	 * + If omMultiplicative is specified, multiplication composition is performed (implemented other than stNearest and stFastLinear).
	 * + If omDodge is specified, dodging compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omDarken is specified, comparison (dark) compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omLighten is specified, comparison (bright) compositing is done (implemented outside of stNearest and stFastLinear).
	 * + If omScreen is specified, screen multiplication composition is performed (implemented other than stNearest and stFastLinear).
	 * + If omAlpha is specified, alpha synthesis will occur.
	 * + If omAddAlpha is specified, additive alpha composition is done. In this case, when the destination Layer.face property is dfOpaque and the Layer.holdAlpha property is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 * + If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque. In this case, when the destination Layer.face property is dfOpaque and the Layer.holdAlpha property is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 *
	 * @param opa Specifies the intensity of the operation (0 to 255).
	 * @param type Specifies the scale type.
	 *
	 * + stNearest           : Nearest point method is used
	 * + stFastLinear        : Low precision linear interpolation is used (partially implemented)
	 * + stSemiFastLinear    : Fixed decimal linear interpolation is used (1.3+)
	 * + stLinear            : Linear interpolation is used (implementation changed after 1.3)
	 * + stFastCubic         : Fixed decimal 3D interpolation is used (1.3 or later)
	 * + stCubic             : 3D interpolation is used (implementation changed after 1.3)
	 * + stFastLanczos2      : Fixed decimal Lanczos interpolation range 4x4 is used (1.3+)
	 * + stLanczos2          : Lanczos interpolation range 4x4 is used (1.3 and above)
	 * + stFastLanczos3      : Fixed decimal Lanczos interpolation range 6x6 is used (1.3 and above)
	 * + stLanczos3          : Lanczos interpolation range 6x6 is used (1.3 and above)
	 * + stFastSpline16      : Fixed decimal spline interpolation 4x4 is used (1.3+)
	 * + stSpline16          : Spline interpolation 4x4 is used (1.3+)
	 * + stFastSpline36      : Fixed decimal spline interpolation 6x6 is used (1.3+)
	 * + stSpline36          : Spline interpolation 6x6 is used (1.3+)
	 * + stFastAreaAvg       : Fixed decimal area mean reduction is used. Cannot be expanded (1.3 or later)
	 * + stAreaAvg           : Area average reduction is used. Cannot be expanded (1.3 or later)
	 * + stFastGaussian      : Fixed decimal Gaussian interpolation 4x4 is used (1.3+)
	 * + stGaussian          : Gaussian interpolation 4x4 is used (1.3 or later)
	 * + stFastBlackmanSinc  : Fixed decimal Blackman-Sinc interpolation 8x8 is used (1.3+)
	 * + stBlackmanSinc      : Blackman-Sinc interpolation 8x8 is used (1.3+)
	 *
	 * The speed is faster in the order of stNearest> stFastLinear> stLinear> stCubic, but the faster the speed, the lower the image quality.
	 * The interpolation method after stCubic has sufficiently high image quality and can be said to be a difference in taste.
	 * However, the image quality will be blurry for Gaussian interpolation. The difference between stFastLinear and other linear interpolations (stSemiFastLinear and stLinear) is large when shrinking.
	 * While stFastLinear always refers to the surrounding 4 pixels, stSemiFastLinear and stLinear refer to and interpolate a range in which the influence range at 1x magnification is 4 pixels at the time of reduction, that is, a wider range of pixels. Higher image quality (algorithm is the original linear interpolation).
	 * For stFastLinear, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.
	 * If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).
	 * @param option Sharpness during 3D interpolation.
	 * It currently has no meaning with other interpolation methods.
	 * Increasing the sharpness value in the positive direction will make it blurry, and increasing it in the negative direction will make it sharper.
	 * @description Computes the rectangle of the specified overlay source layer to the rectangle of the overlay destination (layer that executes the method).
	 * If the size of the overlay source rectangle and the overlay destination rectangle are different, enlargement or reduction is performed.
	 * If omAuto is specified for mode, the operation type is automatically determined according to the Layer.type property of the operation source layer.
	 */
	function operateStretch( dleft, dtop, dwidth, dheight, src, sleft, stop, swidth, sheight, mode=omAuto, opa=255, type=stNearest, option=-1.0);

	/**
	 * Affine transformation copy
	 *
	 * @param src Specifies the layer object to copy from.
	 * You can also specify an object of the Bitmap class.
	 * @param sleft Specifies the left edge position of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param stop Specifies the top position of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param swidth Specifies the width of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param sheight Specifies the height of the rectangle to copy, in pixels (at the image position of the source layer).
	 * @param affine Specifies how to handle the following 6 arguments (A to F parameters).
	 * If true is specified, each of the six parameters will be interpreted as follows.
	 *
	 * + A   : 2D affine transformation matrix a
	 * + B   : 2D affine transformation matrix b
	 * + C   : 2D affine transformation matrix c
	 * + D   : D of 2D affine transformation matrix
	 * + E   : 2D affine transformation matrix tx
	 * + F   : 2D affine transformation matrix ty
	 *
	 * By affine transformation, the copy source image position (x, y) (however, the upper left corner of the copy source rectangle is (0, 0)) is the copy destination image position (x', y') by the following formula. Will be converted to.
	 * x'= a * x + c * y + tx
	 * y'= b * x + d * y + ty
	 * If false is specified, each of the six parameters will be interpreted as follows.
	 * These parameters can also be specified as real numbers.
	 *
	 * + A   : X coordinate position (x0) of the point in the upper left corner of the copy source rectangle at the image position at the copy destination
	 * + B   : Y coordinate position (y0) of the point in the upper left corner of the copy source rectangle at the image position at the copy destination
	 * + C   : X coordinate position (x1) of the point in the upper right corner of the copy source rectangle at the image position at the copy destination
	 * + D   : Y coordinate position (y1) of the point in the upper right corner of the copy source rectangle at the image position at the copy destination
	 * + E   : X coordinate position (x2) of the point in the lower left corner of the copy source rectangle at the image position at the copy destination
	 * + F   : Y coordinate position (y2) of the point in the lower left corner of the copy source rectangle at the image position at the copy destination
	 *
	 * If false is specified, the copy destination position (x3, y3) corresponding to the lower right corner of the copy source is automatically calculated by the following formula.
	 * x3 = x1-x0 + x2
	 * y3 = y1 --y0 + y2
	 * @param A A parameter.
	 * The interpretation depends on the affine argument.
	 * @param B B parameter.
	 * The interpretation depends on the affine argument.
	 * @param C C parameter.
	 * The interpretation depends on the affine argument.
	 * @param D D parameter.
	 * The interpretation depends on the affine argument.
	 * @param E E parameter.
	 * The interpretation depends on the affine argument.
	 * @param F F parameter.
	 * The interpretation depends on the affine argument.
	 * @param type Specifies the type of affine transformation.
	 *
	 * + stNearest     : Nearest point method is used
	 * + stFastLinear  : Low precision linear interpolation is used (partially implemented)
	 * + stLinear      : Linear interpolation is used (not implemented)
	 * + stCubic       : 3D interpolation is used (not implemented)
	 *
	 * For stFastLinear, stLinear, and stCubic, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.
	 * If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).
	 * @param clear Specifies whether to clear the periphery of the affine-transformed image of the transfer destination layer with the color and transparency indicated by the Layer.neutralColor property.
	 * If true is specified, it will be cleared, and if this argument is omitted or false is passed, it will not be cleared.
	 * The area to be cleared can also be limited with the Layer.setClip method.
	 * If you use this clear function, it is a waste of clearing the overwritten area (the part that is overwritten by affine transformation in the cleared place) when overwriting and transferring the image by affine transformation after clearing the transfer destination layer once. Can be omitted.
	 * @description Copies the rectangle of the specified source layer while converting it to the copy destination (layer that executes the method).
	 * The affine argument allows you to choose whether to specify a two-dimensional affine transformation matrix as the transformation parameter or to specify the transformed point directly.
	 * In the current version, linear interpolation is effective when stFastLinear is specified when the Layer.face property of the layer to be overlaid (which executes the method) is dfAlpha (or dfBoth) or dfAddAlpha.
	 * Linear interpolation is also possible when the Layer.face property is dfOpaque and the Layer.holdAlpha property is false.
	 * If the Layer.face property of the layer to which you want to overlay (execute the method) is dfAlpha (or dfBoth) or dfAddAlpha, both the main image and the mask image are copied.
	 * If the Layer.face property of the layer to be overlaid (executes the method) is dfOpaque (or dfMain), only the main image is copied when the Layer.holdAlpha property is true, and the main image and mask are false. Both images are copied.
	 * The transformation by the two-dimensional affine transformation matrix is defined as follows, with the origin (0, 0) at the upper left of the copy source rectangle.
	 * Two-dimensional affine transformations allow you to scale, rotate, shear, translate, flip, or transform any combination of these.
	 * In the method that performs 2D affine transformation, the transformation can be specified by directly specifying each vertex after transformation instead of the 2D affine matrix, but even in this case, transformation that cannot be defined by 2D affine transformation should be performed. You can not.
	 * For affine transformations, pixels are considered to have a size of 1.0 x 1.0.
	 * That is, the pixel at position (0, 0) is considered to be in the range (-0.5, -0.5)-(0.5, 0.5).
	 */
	function affineCopy( src, sleft, stop, swidth, sheight, affine, A, B, C, D, E, F, type=stNearest, clear=false);

	/**
	 * Affine transformation arithmetic composition
	 *
	 * @param src Specifies the layer object to overlay.
	 * You can also specify an object of the Bitmap class.
	 * @param sleft Specifies the left edge position of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param stop Specifies the top position of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param swidth Specifies the width of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param sheight Specifies the vertical width of the overlay rectangle in pixels (at the image position of the overlay source layer).
	 * @param affine Specifies how to handle the following 6 arguments (A to F parameters).
	 * If true is specified, each of the six parameters will be interpreted as follows.
	 *
	 * + A   : 2D affine transformation matrix a
	 * + B   : 2D affine transformation matrix b
	 * + C   : 2D affine transformation matrix c
	 * + D   : D of 2D affine transformation matrix
	 * + E   : 2D affine transformation matrix tx
	 * + F   : 2D affine transformation matrix ty
	 *
	 * By affine transformation, the image position (x, y) of the overlay source (however, the upper left corner of the overlay source rectangle is (0, 0)) is the image position (x', y) of the overlay destination by the following formula. Converted to y').
	 * x'= a * x + c * y + tx
	 * y'= b * x + d * y + ty
	 * If false is specified, each of the six parameters will be interpreted as follows.
	 *
	 * + A   : X coordinate position (x0) of the point in the upper left corner of the copy source rectangle at the image position at the copy destination
	 * + B   : Y coordinate position (y0) of the point in the upper left corner of the copy source rectangle at the image position at the copy destination
	 * + C   : X coordinate position (x1) of the point in the upper right corner of the copy source rectangle at the image position at the copy destination
	 * + D   : Y coordinate position (y1) of the point in the upper right corner of the copy source rectangle at the image position at the copy destination
	 * + E   : X coordinate position (x2) of the point in the lower left corner of the copy source rectangle at the image position at the copy destination
	 * + F   : Y coordinate position (y2) of the point in the lower left corner of the copy source rectangle at the image position at the copy destination
	 *
	 * If false is specified, the overlay destination position (x3, y3) corresponding to the lower right corner of the overlay source is automatically calculated by the following formula.
	 * x3 = x1-x0 + x2
	 * y3 = y1 --y0 + y2
	 * @param A A parameter.
	 * The interpretation depends on the affine argument.
	 * @param B B parameter.
	 * The interpretation depends on the affine argument.
	 * @param C C parameter.
	 * The interpretation depends on the affine argument.
	 * @param D D parameter.
	 * The interpretation depends on the affine argument.
	 * @param E E parameter.
	 * The interpretation depends on the affine argument.
	 * @param F F parameter.
	 * The interpretation depends on the affine argument.
	 * @param mode Specifies the operation mode.
	 *
	 * + If omAuto is specified, the operation type is automatically determined according to the Layer.type property of the operation source layer.
	 * + If omPsNormal is specified, Photoshop compatible alpha compositing will be performed (not implemented in the current version).
	 * + If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is done (not implemented in the current version).
	 * + If omPsSubtractive is specified, Photoshop compatible burn (linear) compositing is performed (not implemented in the current version).
	 * + If omPsMultiplicative is specified, Photoshop compatible multiplication and composition will be performed (not implemented in the current version).
	 * + If omPsScreen is specified, Photoshop compatible screen composition will be performed (not implemented in the current version).
	 * + If omPsOverlay is specified, Photoshop compatible overlay composition will be performed (not implemented in the current version).
	 * + If omPsHardLight is specified, Photoshop compatible hard light composition will be performed (not implemented in the current version).
	 * + If omPsSoftLight is specified, Photoshop compatible softlight composition will be performed (not implemented in the current version).
	 * + If omPsColorDodge is specified, Photoshop compatible dodging color composition will be performed (not implemented in the current version).
	 * + If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed (not implemented in the current version).
	 * + If omPsColorBurn is specified, Photoshop compatible burn-in color composition is performed (not implemented in the current version).
	 * + If omPsLighten is specified, Photoshop compatible comparison (bright) composition will be performed (not implemented in the current version).
	 * + If omPsDarken is specified, Photoshop compatible comparison (dark) compositing will be performed (not implemented in the current version).
	 * + If omPsDifference is specified, Photoshop compatible absolute difference composition is performed (not implemented in the current version).
	 * + If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x or lower will be performed (not implemented in the current version).
	 * + If omPsExclusion is specified, Photoshop compatible exclusion composition is performed (not implemented in the current version).
	 * + If omAdditive is specified, additive synthesis will be performed (not implemented in the current version).
	 * + If omSubtractive is specified, subtractive synthesis will be performed (not implemented in the current version).
	 * + If omMultiplicative is specified, multiplication synthesis will be performed (not implemented in the current version).
	 * + If omDodge is specified, dodging synthesis will be performed (not implemented in the current version).
	 * + If omDarken is specified, comparison (dark) compositing will be done (not implemented in the current version).
	 * + If omLighten is specified, comparison (bright) composition will be performed (not implemented in the current version).
	 * + If omScreen is specified, screen multiplication composition will be performed (not implemented in the current version).
	 * + If omAlpha is specified, alpha synthesis will occur.
	 * + If omAddAlpha is specified, additive alpha composition is done. In this case, when the destination Layer.face property is dfOpaque and the Layer.holdAlpha property is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 * + If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque. In this case, when the destination Layer.face property is dfOpaque and the Layer.holdAlpha property is false, linear interpolation is possible by specifying stFastLinear in the type argument.
	 * @param opa Specifies the overlay opacity (0 to 255).
	 * @param type Specifies the type of affine transformation.
	 *
	 * + stNearest     : Nearest point method is used
	 * + stFastLinear  : Low precision linear interpolation is used (partially implemented)
	 * + stLinear      : Linear interpolation is used (not implemented)
	 * + stCubic       : 3D interpolation is used (not implemented)
	 *
	 * The speed is faster in the order of stNearest> stFastLinear> stLinear> stCubic, but the faster the speed, the lower the image quality.
	 * For stFastLinear, stLinear, and stCubic, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.
	 * If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).
	 * @description Computes the rectangle of the specified overlay source layer while performing affine transformation to the overlay destination (layer that executes the method).
	 * See also Layer.affineCopy for affine transformations.
	 * If omAuto is specified for mode, the operation type is automatically determined according to the Layer.type property of the operation source layer.
	 */
	function operateAffine( src, sleft, stop, swidth, sheight, affine, A, B, C, D, E, F, mode=omAuto, opa=255, type=stNearest);

	/**
	 * Apply rectangular blur
	 *
	 * @param xblur Specifies the range of horizontal blur.
	 * @param yblur Specifies the range of vertical blur.
	 * @description Blur.
	 * The algorithm is "box blur".
	 * A rectangular blur is the average of the brightness of pixels in a "range" represented by two parameters, xblur and yblur.
	 * For example, if xblur = 10 yblur = 2, the brightness of the pixels in the rectangular range of -10 to 10 in the horizontal direction and -2 to 2 in the vertical direction is averaged around the target pixel, and that is the final result. It is the brightness of that pixel.
	 * The area of the range can be calculated by (xblur  2 + 1)  (yblur  2 + 1).
	 * In the current version, if this area is less than 256, the algorithm is faster than if the area is 256 or more.
	 * If the Layer.face property is dfAlpha, it will be a bit slower as it uses a special algorithm for alpha compositing.
	 * For dfAddAlpha and other drawing methods, the algorithm is faster.
	 */
	function doBoxBlur( xblur=1, yblur=1);

	/**
	 * Gamma correction
	 *
	 * @param rgamma Specify the gamma value of the red component (0.0 to 1.0 to 9.0).
	 * @param rfloor Specify the minimum output value (0 to 255) for the red component.
	 * @param rceil Specifies the maximum output value (0 to 255) for the red component.
	 * @param ggamma Specify the gamma value of the green component (0.0 to 1.0 to 9.0).
	 * @param gfloor Specifies the minimum output value (0 to 255) for the green component.
	 * @param gceil Specify the maximum output value (0 to 255) of the green component.
	 * @param bgamma Specify the gamma value of the blue component (0.0 to 1.0 to 9.0).
	 * @param bfloor Specifies the minimum output value (0 to 255) for the blue component.
	 * @param bceil Specify the maximum output value (0 to 255) of the blue component.
	 * @description Performs gamma correction on the image.
	 * If you specify 1.0 for the gamma value, the gamma curve becomes a straight line.
	 * The output minimum value and output maximum value specify the minimum and maximum values of the brightness of each component.
	 * You can invert the image by setting the highest value to a value lower than the lowest value.
	 * This method references the Layer.face property.
	 * If this is dfAddAlpha, this method uses a special gamma correction routine for additive alpha synthesis.
	 * This routine performs gamma correction for the components corresponding to alpha synthesis in additive alpha synthesis, but does not perform gamma correction for the components corresponding to additive synthesis.
	 */
	function adjustGamma( rgamma=1.0, rfloor=0, rceil=255, ggamma=1.0, gfloor=0, gceil=255, bgamma=1.0, bfloor=0, bceil=255);

	/**
	 * Grayscale conversion
	 *
	 * @description Converts the image to grayscale.
	 */
	function doGrayScale( );

	/**
	 * Flip horizontal
	 *
	 * @description Flip the image horizontally.
	 * This method is not affected by the drawing clip rectangle, such as by the Layer.setClip method (always inverts the entire layer image).
	 * It is also unaffected by the Layer.face and Layer.holdAlpha properties.
	 */
	function flipLR( );

	/**
	 * flip upside down
	 *
	 * @description Flip the image upside down.
	 * This method is not affected by the drawing clip rectangle, such as by the Layer.setClip method (always inverts the entire layer image).
	 * It is also unaffected by the Layer.face and Layer.holdAlpha properties.
	 */
	function flipUD( );

	/**
	 * Layer image representation format conversion
	 *
	 * @param from Specify the drawing method type to be converted.
	 * @description Converts the format of layer images.
	 * This method converts the image representation format between "types that have different layer image representation formats but can be represented in the same way", such as ltAlpha (dfAlpha) and ltAddAlpha (dfAddAlpha).
	 * For example, if you change the layer type displayed by ltAlpha to ltAddAlpha as it is, it will not be displayed properly because the alpha channel and color information are handled differently.
	 * Therefore, you need to use this method to convert from dfAlpha to dfAddAlpha.
	 * Note that in this method, the image representation format of the conversion destination corresponds to the drawing method specified by the Layer.face property (not the layer type specified by Layer.type, but the drawing method. ).
	 * In the from argument, specify the drawing method (constant starting with df; see Layer.face) corresponding to the image representation format of the conversion source.
	 * You cannot specify dfAuto for the from argument.
	 * Currently supported conversions are dfAlpha  dfAddAlpha and dfAddAlpha  dfAlpha conversions. In dfAddAlpha  dfAlpha, color information may be lost due to conversion.
	 * This method is unaffected by the drawing clip rectangle (always the entire layer image is affected).
	 */
	function convertType( from);

	/**
	 * Image update
	 *
	 * @param left Specifies the left edge position of the rectangle to update, in pixels in display coordinates.
	 * @param top Specifies the top position of the rectangle to update, in pixels in display coordinates.
	 * @param width Specifies the width of the rectangle to update, in pixels in display coordinates.
	 * @param height Specifies the vertical width of the rectangle to update, in pixels in display coordinates.
	 * @description This method forces the layer to be drawn on the screen.
	 * The screen is automatically updated when a drawing method is executed, but this method can be used to force drawing on the screen.
	 * If you omit all the arguments, the entire layer will be redrawn.
	 * This method sets the Layer.callOnPaint property to true.
	 * No matter how many times this method is executed, the screen drawing will occur only once (cached) until it is actually drawn on the screen.
	 */
	function update( left, top, width, height);

	/**
	 * Specifying the mouse cursor position
	 *
	 * @param x Specifies the x-coordinate value (in the display coordinates of this layer) for the mouse cursor, in pixels.
	 * This value can also be set / retrieved with the Layer.cursorX property.
	 * @param y Specifies the y coordinate value of the mouse cursor (in the display coordinates of this layer) in pixels.
	 * This value can also be set / retrieved with the Layer.cursorX property.
	 * @description Specifies the position of the mouse cursor.
	 */
	function setCursorPos( x, y);

	/**
	 * Focus setting
	 *
	 * @param direction The value passed to the direction argument of the Layer.onBeforeFocus and Layer.onFocus events.
	 * @description Specifies the focus on the layer.
	 * Keyboard input is possible when the layer receives focus.
	 */
	function focus( direction=true);

	/**
	 * Set focus on the previous layer
	 *
	 * @return Newly focused layer object
	 * @description Search forward for a layer that can be focused, and if a layer is found, focus on that layer.
	 */
	function focusPrev( );

	/**
	 * Set focus on the back layer
	 *
	 * @return Newly focused layer object
	 * @description Search backwards for focusable layers, and if found, focus on that layer.
	 */
	function focusNext( );

	/**
	 * Make it modal
	 *
	 * @description Set the mode for the layer. When you set the mode (modally), only the child layers of that layer can receive focus and mouse messages.
	 * .
	 */
	function setMode( );

	/**
	 * Release the modal state
	 *
	 * @description Cancels the modal state set in Layer.setMode.
	 */
	function removeMode( );

	/**
	 * Designation of gaze position
	 *
	 * @param left Specifies the x-coordinate value (in the display coordinates of this layer) in pixels.
	 * This value can also be set / obtained with the Layer.attentionLeft property.
	 * @param top Specifies the x-coordinate value (in the display coordinates of this layer) in pixels.
	 * This value can also be set / obtained with the Layer.attentionTop property.
	 * @description Specify the gaze position.
	 * The gaze position is usually set to the position of the caret (a bar that blinks with a text editor to indicate the character input position from the keyboard).
	 * IME unconfirmed characters are displayed at this gaze position.
	 * @see Layer.useAttention
	 */
	function setAttentionPos( left, top);

	/**
	 * Start of transition
	 *
	 * @param name Specify the transition name.
	 * By default,'crossfade','universal', and'scroll' are defined.
	 * @param withchildren Whether the child layer also transitions with it.
	 * If true is specified, the transition will be made for each child layer.
	 * If false is specified, only the layer that executes the method will transition.
	 * @param transsrc Specify the layer to switch to.
	 * Some transitions may not need to be specified (for example, transitions by themselves).
	 * @param options Specifies transition options in a dictionary array.
	 * The options you need depend on the type of transition.
	 * Regardless of the type of transition, the options that can be specified in common are the'selfupdate'member and the'callback' member.
	 * If the'selfupdate'member is true, KiriKiri will not automatically update the screen.
	 * In this case, he has to update the screen with the Layer.update method etc. on the program side as appropriate.
	 * This feature is useful if you want the transition drawing to be perfectly synchronized with the program drawing.
	 * If you specify a TJS2 method in the'callback'member, that method will be called each time the drawing is actually done.
	 * This method (callback method) should return a'tick' value of 0 or greater.
	 * Many transitions are based on the'tick'value, which is the actual time in milliseconds, but by implementing this callback method to return any tick, the transition's transition You can rewind the effect at any point, fast forward in the middle, and control the transition regardless of the actual time.
	 * Many transitions consider the value specified in the optional'time'member to be the end of the transition.
	 * So, for example, you can specify an appropriate value such as 1000 for the option'time', and in this callback method he will return a value less than 1000 to display the transition at any stage. You will be able to do it.
	 * Also, for many transitions, the transition will stop when the'tick' value reaches the value specified by the optional'time', so if you don't want to stop the transition, the value specified by'time' Always specify a value less than or equal to.
	 * @description Start the transition.
	 * When children = true, the transition has a parent-child tree structure that is exactly the same as the transition source specified in transsrc at the end.
	 * If children = false, only the layer from which the transition is made and the layer that executed the method (the layer to which the transition is made) are swapped.
	 * Please note that in both cases, the tree structure is replaced.
	 * This method returns immediately after initiating a transition.
	 */
	function beginTransition( name, withchildren=true, transsrc=null, options=%[ ]);

	/**
	 * Stop the transition
	 *
	 * @description Stop the transition in progress.
	 */
	function stopTransition( );

	/**
	 * Copy of image
	 *
	 * @param src Specify the copy source layer.
	 * @description Copies the main image, mask image, and area image of the layer specified by src.
	 * The image size will be the same as the image size of the copy source layer.
	 * No other information will be copied.
	 * This method takes almost no execution time because copying is actually just a state where "the same image is shared by two or more layers".
	 */
	function assignImages( src);

	/**
	 * Save image
	 *
	 * @param name Specify the storage name to save.
	 * @param type Specify the image format to save as a character string.
	 * The following formats can be specified in the current version.
	 *
	 * + "bmp" or "bmp32" : It is a 32bpp BMP. It also saves the alpha channel (mask).
	 * + "bmp24" : It is a 24bpp BMP. The alpha channel (mask) is not saved.
	 * + "bmp8" : 8bpp BMP. The alpha channel (mask) is not saved. The image is reduced in color using 4x4 organized dithering with a fixed palette of 252 colors.
	 * + "jpg" : It's JPEG. The alpha channel (mask) is not saved. Images are saved with 90% quality.
	 * + "jpg###" : It's JPEG. The alpha channel (mask) is not saved. The image will be saved with the quality specified by ###. "jpg010" is 10%, "jpg100" is 100%, and "jpg080" is 80%.
	 * + "png" : 32bpp PNG. It also saves the alpha channel (mask).
	 * + "png24" : 24bpp PNG. The alpha channel (mask) is not saved.
	 * + "tlg5" : It is a 32bpp TLG5. It also saves the alpha channel (mask).
	 * + "tlg524" : It is a 24bpp TLG5. The alpha channel (mask) is not saved.
	 * + "tlg6" : It is a 32bpp TLG6. It also saves the alpha channel (mask).
	 * + "tlg624" : It is a 24bpp TLG6. The alpha channel (mask) is not saved.
	 * @description Saves the file in the storage (file) specified by name in the image format specified by type.
	 * Only layer images are saved, area images cannot be saved.
	 */
	function saveLayerImage( name, type="bmp");

	/**
	 * Copy image to Bitmap
	 *
	 * @param dest Specifies the destination Bitmap object.
	 * @description Copies the layer's main image to the Bitmap object specified by dest.
	 * The image size will be the same as the image size of the copy source layer.
	 * This method takes almost no execution time because copying is actually just a state where "the same image is shared by two or more layers".
	 * @see Layer.copyFromBitmapToMainImage
	 */
	function copyToBitmapFromMainImage( dest);

	/**
	 * Copy image from Bitmap
	 *
	 * @param src Specifies the Bitmap object to copy from.
	 * @description Copies an image from the Bitmap object specified in src to the layer's main image.
	 * The image size will be the same as the image size of the source Bitmap object.
	 * This method takes almost no execution time because copying is actually just a state where "the same image is shared by two or more layers".
	 * @see Layer.copyToBitmapFromMainImage
	 */
	function copyFromBitmapToMainImage( src);

	/**
	 * Parent layer
	 *
	 * @description Represents a parent layer object.
	 * You can also set the value.
	 * If you set a value, it will be a child of that layer.
	 * You cannot be a child of a layer that belongs to a different window or a different primary layer, or a child of yourself or your descendants.
	 */
	 property parent {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Child layer array
	 *
	 * @description Represents an array object that contains child layers.
	 * Even if you write a value to the array obtained here, or delete or add an item, it will not be reflected in the actual layer state.
	 * Think of it as read-only.
	 */
	 property children {
		 getter() { return value; }
	}
	/**
	 * relative position
	 *
	 * @description Represents the ranking among sibling layers with the same parent.
	 * The smaller the value, the deeper it is displayed.
	 * You can change the ranking among sibling layers by setting a value. Setting the value sets the Layer.absoluteOrderMode property of the parent layer to false.
	 * @see Layer.absolute
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToBack
	 * @see Layer.bringToFront
	 */
	 property order {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Absolute position
	 *
	 * @description Represents the stacking order between sibling layers with the same parent.
	 * The smaller the value, the deeper it is displayed.
	 * Unlike the Layer.order property, the values do not have to be consecutive between the same siblings.
	 * You can change the ranking among sibling layers by setting a value.
	 * Setting the value sets the Layer.absoluteOrderMode property of the parent layer to true.
	 * @see Layer.order
	 * @see Layer.absoluteOrderMode
	 * @see Layer.bringToBack
	 * @see Layer.bringToFront
	 */
	 property absolute {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether it is in absolute position mode
	 *
	 * @description Represents the superposition order mode of the child layers that report directly to it.
	 * You can also set the value.
	 * If you specify false, it becomes a relative position specification, and the Layer.order property shows the order.
	 * If true is specified, it will be an absolute position specification, and the Layer.absolute property will represent its rank.
	 * @see Layer.order
	 * @see Layer.absolute
	 * @see Layer.bringToBack
	 * @see Layer.bringToFront
	 */
	 property absoluteOrderMode {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether it is visible
	 *
	 * @description Indicates whether it is visible or not.
	 * You can also set the value.
	 * If you specify false, it will be invisible.
	 * If you specify true, it will be visible.
	 */
	 property visible {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Do you want to cache
	 *
	 * @description Indicates whether to cache.
	 * You can also set the value.
	 * In the case of setting to cache, you will have an image in which you and all child layers are overlapped in advance, and unless you or the child layer is changed after that, you and the child layer will be overlapped. Does not perform image operations on (automatically reconfigures the cache if changed). If the setting is not cached, the superposition operation is performed every time the screen is updated. By default, it is not cached, but it is automatically cached during transitions (although this property does not represent the presence or absence of caches that are automatically enabled, such as during transitions).
	 * If you know that there is no change in the image or state of a layer's image and its child layers, and the screen rewrites frequently, caching that layer will improve overall performance.
	 */
	 property cached {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether the node is visible
	 *
	 * @description Indicates whether the node is visible.
	 * If any of the parent layers is invisible, it will be false.
	 * True if all parent layers are visible.
	 */
	 property nodeVisible {
		 getter() { return value; }
	}
	/**
	 * Neutral color
	 *
	 * @description Represents the neutral color of the layer in 0xAARRGGBB format.
	 * You can also set the value.
	 * The layer's neutral color is set to that type of neutral color when you change the Layer.type property.
	 * Neutral color is the default value that fills the expanded area when the size of the layer image is expanded.
	 * By setting the value, you can specify the initial color when the size of the layer image is expanded.
	 */
	 property neutralColor {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether the layer has an image
	 *
	 * @description Indicates whether the layer has an image.
	 * You can also set the value.
	 * If you specify true, the layer will have an image.
	 * This is the default.
	 * If you specify false, the image of the layer is released and the layer has no image.
	 * Setting the Layer.type property resets hasImage to true.
	 * If the layer does not have an image and the Layer.type is ltOpaque, the layer will appear as fully filled with Layer.neutralColor.
	 * Other types are treated as completely transparent.
	 * Layers with this property false are considered to be entirely opaque (fully transparent) if Layer.hitType is htMask.
	 * Also, you cannot manipulate drawing or fonts.
	 * Layers with this property fake usually combine multiple child layers and use themselves as layers that are only transparent.
	 * .
	 */
	 property hasImage {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Opacity
	 *
	 * @description Represents the opacity of a layer.
	 * You can set the value.
	 * The value is an integer from 0 to 255, and the larger the value, the more opaque the display.
	 */
	 property opacity {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Window object
	 *
	 * @description Represents the window object that holds this layer.
	 */
	 property window {
		 getter() { return value; }
	}
	/**
	 * Whether it is the primary layer
	 *
	 * @description Indicates whether it is the primary layer.
	 * The primary layer is a layer that has no parent and is the layer that is displayed at the back.
	 */
	 property isPrimary {
		 getter() { return value; }
	}
	/**
	 * Leftmost position
	 *
	 * @description Specifies the left edge position of the layer, in pixels, in the display coordinates of the parent layer.
	 * You can also set the value.
	 * @see Layer.setPos
	 */
	 property left {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Top position
	 *
	 * @description Specifies the top layer position, in pixels, in the display coordinates of the parent layer.
	 * You can also set the value.
	 * @see Layer.setPos
	 */
	 property top {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Width
	 *
	 * @description Specifies the display width of the layer in pixels.
	 * You can also set the value.
	 * @see Layer.setSize
	 */
	 property width {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Vertical width
	 *
	 * @description Specifies the display height of the layer in pixels.
	 * You can also set the value.
	 * @see Layer.setSize
	 */
	 property height {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Layer image left edge offset
	 *
	 * @description Specifies the left edge of the layer display offset in pixels.
	 * You can also set the value.
	 * @see Layer.setImagePos
	 */
	 property imageLeft {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Layer image top offset
	 *
	 * @description Specifies the top edge of the layer's display offset in pixels.
	 * You can also set the value.
	 * @see Layer.setImagePos
	 */
	 property imageTop {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Image width
	 *
	 * @description Specifies the width of the layer's image in pixels.
	 * You can also set the value.
	 * @see Layer.setImageSize
	 */
	 property imageWidth {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Image height
	 *
	 * @description Specifies the vertical width of the layer's image in pixels.
	 * You can also set the value.
	 * @see Layer.setSize
	 */
	 property imageHeight {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Drawing clip rectangle left edge position
	 *
	 * @description Specifies the left edge of the drawing clip rectangle in pixels.
	 * You can also set the value.
	 * @see Layer.setClip
	 */
	 property clipLeft {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Top position of drawing clip rectangle
	 *
	 * @description Specifies the top edge of the drawing clip rectangle in pixels.
	 * You can also set the value.
	 * @see Layer.setClip
	 */
	 property clipTop {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Drawing clip rectangle width
	 *
	 * @description Specifies the width of the drawing clip rectangle in pixels.
	 * You can also set the value.
	 * @see Layer.setClip
	 */
	 property clipWidth {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Drawing clip rectangle vertical width
	 *
	 * @description Specifies the vertical width of the drawing clip rectangle in pixels.
	 * You can also set the value.
	 * @see Layer.setClip
	 */
	 property clipHeight {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Layer display type
	 *
	 * @description Represents the display type of a layer.
	 * You can also set the value.
	 *
	 * + Specifying ltOpaque or ltCoverRect disables pixel-by-pixel alpha blending. Both ltCoverRect and ltOpaque have the same meaning. If the Layer.opacity property is 255, it will appear as a completely opaque rectangle. The mask image is ignored. A suitable drawing method for this type (specified in Layer.face) is dfOpaque.
	 * + Specifying ltAlpha or ltTransparent enables pixel-by-pixel alpha blending. Both ltTransparent and ltAlpha have the same meaning. The mask image is used for transparency. A suitable drawing method for this type is dfAlpha.
	 * + Specifying ltAddAlpha enables pixel-by-pixel additive alpha blending. A suitable drawing method for this type is dfAddAlpha.
	 * + If you specify ltAdditive, additive synthesis is performed. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 * + If you specify ltSubtractive, subtractive synthesis is performed. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 * + If you specify ltMultiplicative, multiplication synthesis is performed. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 * + If ltDodge is specified, dodging synthesis will be performed. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 * + Specify ltDarken for comparative (dark) compositing. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 * + If you specify ltLighten, comparison (bright) composition is performed. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 * + If you specify ltScreen, screen multiplication composition is performed. The mask image is ignored. A suitable drawing method for this type is dfOpaque.
	 *
	 * See Graphics Systems for other layer display types.
	 * @see Layer.face
	 */
	 property type {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Drawing method
	 *
	 * @description Indicates the drawing method for the layer.
	 * You can also set the value.
	 *
	 * + If you specify dfAlpha or dfBoth, the image is considered as an image with an alpha channel and is drawn. The same is true for dfBoth and dfAlpha. The corresponding layer types for this drawing method are ltTransparent or ltAlpha.
	 * + If you specify dfAddAlpha, the image is considered as an image with an additive alpha channel and is drawn. The layer type that corresponds to this drawing method is ltAddAlpha.
	 * + If you specify dfOpaque or dfMain, all images on the layer are considered completely opaque and are drawn. The layer type that corresponds to this drawing method is a layer type that performs arithmetic / logical operations such as ltOpaque or ltCoverRect, or ltAdditive.
	 * + If dfMask is specified, the mask image (alpha channel) will be drawn.
	 * + If dfProvince is specified, the area image will be drawn.
	 * + If you specify dfAuto, the drawing method is automatically determined according to the current Layer.type property.
	 *
	 * The drawing method of the layer immediately after it is created is dfAuto.
	 * Not all methods can be manipulated depending on the value of this property.
	 * @see Layer.type
	 */
	 property face {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether to protect the alpha channel
	 *
	 * @description Specifies whether to protect the alpha channel in drawing.
	 * You can also set the value. The default is false.
	 * For some drawing operations, this property allows you to specify whether to keep the alpha channel (mask image) of the image when the Layer.face property is dfOpaque.
	 * For many methods, fake this property for faster drawing.
	 * If the Layer.type is neither ltAlpha nor ltAddAlpha, the alpha channel of the image is not used and it is safe to set this property to false.
	 * However, if this property is false, the alpha channel will be destroyed.
	 * The following methods are not affected by this property.
	 *
	 * + Layer.loadImages
	 * + Layer.loadProvinceImage
	 * + Layer.setMainPixel
	 * + Layer.setMaskPixel
	 * + Layer.setProvincePixel
	 * + Layer.piledCopy
	 * + Layer.adjustGamma(Alpha channel is always protected)
	 * + Layer.doGrayScale(Alpha channel is always protected)
	 * + Layer.flipLR
	 * + Layer.flipUD
	 * + Layer.assignImages
	 *
	 * The following methods are affected by this property.
	 *
	 * + Layer.copyRect
	 * + Layer.stretchCopy
	 * + Layer.affineCopy
	 * + Layer.fillRect
	 * + Layer.colorRect
	 * + Layer.drawText
	 * + Layer.operateRect
	 * + Layer.operateStretch
	 * + Layer.operateAffine
	 */
	 property holdAlpha {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Did the image change?
	 *
	 * @description Indicates whether the image of the layer has changed.
	 * You can also set the value.
	 * It is automatically set to true when you draw on the layer's image or resize the layer's image.
	 * If you set this property to false, it will be true if the layer's image changes, so you can tell if the layer's image has changed.
	 * This property itself does not affect the behavior of the layer.
	 */
	 property imageModified {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Collision detection type
	 *
	 * @description Represents the type of mouse event collision detection.
	 * You can also set the value.
	 * If htProvince is specified, mouse events will be received only in non-zero areas in the area image.
	 * If you specify htMask, you will only receive mouse events if the mask (opacity) image value is greater than or equal to the value specified by the Layer.hitThreshold property.
	 * Mouse events that are not received are processed in a deeper layer.
	 * The initial state is htMask.
	 */
	 property hitType {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Threshold value for collision detection
	 *
	 * @description Represents the position of the mouse event collision detection formula.
	 * You can also set the value.
	 * This property is valid only when the Layer.hitType property is htMask, and a mouse message will be received if the mask (opacity) image value is greater than or equal to the value specified in this property.
	 * Specify 0 to receive all mouse messages.
	 * If you specify 256, all mouse messages will not be received.
	 * The initial state is 16.
	 */
	 property hitThreshold {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Mouse cursor
	 *
	 * @description Represents a layer's mouse cursor.
	 * You can also set the value.
	 * The mouse cursor can be a mouse cursor constant starting with cr, or a storage name for a mouse cursor with a .cur extension or an animated mouse cursor with a .ani extension.
	 */
	 property cursor {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Mouse cursor x position
	 *
	 * @description Represents the x-coordinate value of the layer's mouse cursor in pixels in display coordinates. You can also set the value. When setting a value, simply setting the cursorX property does not move the mouse cursor.
	 * The mouse cursor will then move when you set the cursorY property.
	 * @see Layer.setCursorPos
	 */
	 property cursorX {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Mouse cursor y position
	 *
	 * @description Represents the y coordinate value of the layer's mouse cursor in pixels in display coordinates.
	 * You can also set the value.
	 * When setting a value, simply setting the cursorX property does not move the mouse cursor.
	 * The mouse cursor will then move when you set the cursorY property.
	 * @see Layer.setCursorPos
	 */
	 property cursorY {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Tips
	 *
	 * @description Represents a layer hint string.
	 * You can also set the value.
	 * Hint The string is the string that appears near the mouse cursor when you hover the mouse cursor over the layer a bit.
	 * If you do not want the hint to be displayed, specify an empty string.
	 * @see Layer.showParentHint
	 */
	 property hint {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Do you want to take over the hint of the parent layer?
	 *
	 * @description Indicates whether to inherit the hint of the parent layer.
	 * You can also set the value.
	 * If true, if the Layer.hint property is an empty string, it will go back to the parent layer and display the hint of the layer with the hint as it is.
	 * If the Layer.hint property is not an empty string, it will be displayed.
	 * If false, the Layer.hint property will show it if it is not an empty string, and will not show hints if it is an empty string.
	 */
	 property showParentHint {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether to receive focus
	 *
	 * @description Indicates whether or not the focus can be received.
	 * You can also set the value.
	 * If true, the layer will receive focus.
	 * If false, the layer will not receive focus.
	 */
	 property focusable {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Layer that can receive forward focus
	 *
	 * @description Search forward for layers that can receive focus.
	 * If there is no corresponding layer, it will be null.
	 */
	 property prevFocusable {
		 getter() { return value; }
	}
	/**
	 * Layer that can receive rear focus
	 *
	 * @description Search backwards for layers that can receive focus.
	 * If there is no corresponding layer, it will be null.
	 */
	 property nextFocusable {
		 getter() { return value; }
	}
	/**
	 * Whether to join the focus chain
	 *
	 * @description Indicates whether to join the focus chain.
	 * If you specify true, it will join the focus chain and appear in Layer.prevFocusable etc., or you can move the focus to that layer with the TAB key etc.
	 * If you specify false, it will not join the focus chain, but you can receive the focus with the Layer.focus method.
	 */
	 property joinFocusChain {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether it is in focus
	 *
	 * @description Indicates whether it is in focus.
	 * If true, it is in focus.
	 * If it is false, it is not.
	 */
	 property focused {
		 getter() { return value; }
	}
	/**
	 * Whether it can be operated
	 *
	 * @description Indicates whether the layer can be manipulated.
	 * You can also set the value. If true, it can be manipulated and can receive focus, etc.
	 * If it is false, it cannot be operated and cannot receive focus.
	 */
	 property enabled {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether the layer node can be operated
	 *
	 * @description Indicates whether the layer node can be operated.
	 * It is false if you are inoperable or if some of the parent layers are inoperable.
	 * Otherwise it will be true.
	 */
	 property nodeEnabled {
		 getter() { return value; }
	}
	/**
	 * Gaze left end position
	 *
	 * @description The position of the left end of the gaze is expressed in pixels in the display coordinates.
	 * You can also set the value.
	 * @see Layer.setAttentionPos
	 * @see Layer.useAttention
	 */
	 property attentionLeft {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Gaze upper end position
	 *
	 * @description The position of the upper end of the gaze is expressed in pixels in the display coordinates.
	 * You can also set the value.
	 * @see Layer.setAttentionPos
	 * @see Layer.useAttention
	 */
	 property attentionTop {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether to use gaze information
	 *
	 * @description Indicates whether to use gaze information.
	 * You can also set the value.
	 * If true is specified, the gaze information for that layer is used.
	 * If false is specified, the gaze information of the layer's parent (if any) is used.
	 * @see Layer.setAttentionPos
	 * @see Layer.attentionLeft
	 * @see Layer.attentionTop
	 */
	 property useAttention {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * IME mode
	 *
	 * @description Represents the IME mode. You can also set the value.
	 * When the layer is in focus, the IME switches to the mode specified here.
	 * The values that can be set are as follows.
	 *
	 * + Specifying imDisable disables the IME. IME cannot be used for input, and IME cannot be enabled by user operation.
	 * + Specifying imClose disables the IME. Unlike imDisable, IME can be enabled by user operation.
	 * + If you specify imOpen, IME is enabled.
	 * + If imDontCare is specified, the enabled / disabled state of the IME inherits the previous state. You can enable or disable the IME by user interaction. In Japanese input, this is a general mode for allowing the user to freely enter half-width / full-width characters.
	 * + If imSAlpha is specified, IME will be enabled and the half-width alphabet input mode will be set.
	 * + If you specify imAlpha, IME is enabled and you are in full-width alphabet input mode.
	 * + If you specify imHira, IME is enabled and you are in hiragana input mode.
	 * + If imSKata is specified, IME will be enabled and the half-width katakana input mode will be set.
	 * + If imKata is specified, IME will be enabled and the full-width Katakana input mode will be set.
	 * + If imChinese is specified, IME will be enabled and the mode will accept double-byte Chinese input. It cannot be used in a Japanese environment.
	 * + If imSHanguel is specified, the IME will be enabled and the mode will accept 1-byte Korean input. It cannot be used in a Japanese environment.
	 * + If imHanguel is specified, the IME will be enabled and the mode will accept 2-byte Korean input. It cannot be used in a Japanese environment.
	 *
	 * If not specified, imDisable will be set.
	 * @see Window.imeMode
	 */
	 property imeMode {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether to call the onPaint event
	 *
	 * @description Indicates whether to call the Layer.onPaint event.
	 * You can also set the value.
	 * If true is specified, the onPaint event will be called immediately before drawing on the next screen.
	 * This property is automatically set back to false when the onPaint event has finished processing.
	 * The onPaint event does not occur when false is specified.
	 * The Layer.update method sets this property to true.
	 */
	 property callOnPaint {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * font
	 *
	 * @description An object of the Font class that represents the font used for drawing with the Layer.drawText method.
	 */
	 property font {
		 getter() { return value; }
	}
	/**
	 * Layer name
	 *
	 * @description Represents a layer name.
	 * You can also set the value.
	 * The contents set in this property do not affect the operation of the Layer class.
	 */
	 property name {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Main image buffer pointer
	 *
	 * @description Represents a pointer to the upper left corner of the image buffer for the main image (a 32bpp bitmap containing color and mask (opacity) information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * It is returned as an integer type, but for plugins etc., cast it to an appropriate type (const unsigned long * etc.) and use it.
	 * Do not write a value to the pointer obtained by this property.
	 * Any pointer obtained by Layer.mainImageBufferForWrite can be written.
	 * Returns NULL (0) if no image has been assigned to the layer.
	 * The size of the image is represented by the Layer.imageWidth and Layer.imageHeight properties.
	 * See Layer.mainImageBufferPitch for how to calculate the pointer.
	 * @see Layer.mainImageBufferForWrite
	 * @see Layer.mainImageBufferPitch
	 */
	 property mainImageBuffer {
		 getter() { return value; }
	}
	/**
	 * Main image buffer pointer (for writing)
	 *
	 * @description Represents a pointer to the upper left corner of the image buffer for the main image (a 32bpp bitmap containing color and mask (opacity) information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * It is returned as an integer type, but for plugins etc., cast it to an appropriate type (unsigned long * etc.) and use it.
	 * Unlike Layer.mainImageBuffer, you can write a value to the pointer obtained by this property.
	 * Inside Kirikiri, the exact same image is shared between multiple layers, etc., but if you refer to this property, the shared state will be canceled.
	 * Returns NULL (0) if no image has been assigned to the layer.
	 * The size of the image is represented by the Layer.imageWidth and Layer.imageHeight properties.
	 * See Layer.mainImageBufferPitch for how to calculate the pointer.
	 * @see Layer.mainImageBuffer
	 * @see Layer.mainImageBufferPitch
	 */
	 property mainImageBufferForWrite {
		 getter() { return value; }
	}
	/**
	 * Main image buffer pitch
	 *
	 * @description Represents the pitch (in bytes down to the next scanline) of the image buffer of the main image (a 32-bpp bitmap containing color and mask (opacity) information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * Assuming that tjs_uint32 is a 32-bit integer type and tjs_uint8 is an 8-bit (1byte) integer type, the pointer to the image position (x, y) can be calculated as follows when written in C language.
	 * ((tjs_uint32 *) ((tjs_uint8 *) mainImageBuffer + y * mainImageBufferPitch)) + x
	 * Note that this property returns the number of bytes, not the number of pixels until the next scanline.
	 * This number may be slightly larger than the exact number of bytes required for the width of the image.
	 * Note that this property can have a negative value.
	 * @see Layer.mainImageBuffer
	 * @see Layer.mainImageBufferForWrite
	 */
	 property mainImageBufferPitch {
		 getter() { return value; }
	}
	/**
	 * Area image buffer pointer
	 *
	 * @description Represents a pointer to the upper left corner of the image buffer for a region image (an 8bpp bitmap containing region information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * It is returned as an integer type, but for plugins etc., cast it to an appropriate type (const unsigned char * etc.) and use it.
	 * Do not write a value to the pointer obtained by this property.
	 * Any pointer obtained by Layer.provinceImageBufferForWrite can be written.
	 * Returns NULL (0) if no image has been assigned.
	 * If no image is assigned, the entire area should be considered area number 0.
	 * The size of the image is represented by the Layer.imageWidth and Layer.imageHeight properties.
	 * See Layer.provinceImageBufferPitch for how to calculate the pointer.
	 * @see Layer.provinceImageBufferForWrite
	 * @see Layer.provinceImageBufferPitch
	 */
	 property provinceImageBuffer {
		 getter() { return value; }
	}
	/**
	 * Area image buffer pointer (for writing)
	 *
	 * @description Represents a pointer to the upper left corner of the image buffer for a region image (an 8bpp bitmap containing region information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * It is returned as an integer type, but for plugins etc., cast it to an appropriate type (unsigned char * etc.) and use it.
	 * Unlike Layer.provinceImageBuffer, you can write a value to the pointer obtained by this property.
	 * Inside Kirikiri, the exact same image is shared between multiple layers, etc., but if you refer to this property, the shared state will be canceled.
	 * If no image is assigned to the layer, it will be automatically assigned when this property is referenced, and the entire area will be initialized with area number 0.
	 * The size of the image is represented by the Layer.imageWidth and Layer.imageHeight properties.
	 * See Layer.provinceImageBufferPitch for how to calculate the pointer.
	 * @see Layer.provinceImageBuffer
	 * @see Layer.provinceImageBufferPitch
	 */
	 property provinceImageBufferForWrite {
		 getter() { return value; }
	}
	/**
	 * Area image buffer pitch
	 *
	 * @description Represents the pitch (number of bytes down to the next scanline) of the image buffer of a region image (an 8bpp bitmap containing region information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * As tjs_uint8 is an 8-bit (1byte) integer type, the pointer to the image position (x, y) can be calculated as follows when written in C language.
	 * (tjs_uint8 *) provideImageBuffer + y * proveinceImageBufferPitch + x
	 * The number for this property may be slightly larger than the exact number of bytes required for the width of the image.
	 * Note that this property can have a negative value.
	 * @see Layer.provinceImageBuffer
	 * @see Layer.provinceImageBufferForWrite
	 */
	 property provinceImageBufferPitch {
		 getter() { return value; }
	}
	/**
	 * Hint display judgment presence / absence
	 *
	 * @description Hint Indicates the presence or absence of display judgment.
	 * If set to true, no hint judgment will be performed on this layer.
	 * If false is set, the judgment will be made.
	 * @see Window.onHintChanged
	 */
	 property ignoreHintSensing {
		 getter() { return value; }
		 setter( value ) {}
	}
};
