/**
 * @description The Bitmap class is a class that holds image information.
 */
class Bitmap {
	/**
	 * Build default Bitmap object
	 *
	 * @description Build an object of class Bitmap. Initially, the width and height are 32 pixels.
	 */
	function Bitmap();

	/**
	 * Building a sized Bitmap object
	 *
	 * @param width Specifies the width of the image.
	 * @param height Specifies the height of the image.
	 * @param bpp Specifies the number of bits for each pixel in the image. Specify either 32 or 8.
	 * @description Builds an object of class Bitmap with the specified size.
	 */
	function Bitmap( width, height, bpp=32);

	/**
	 * Building a Bitmap object with a specified file
	 *
	 * @param filename Specify the file name of the image.
	 * @param colorkey Specify the color key. The value is the same as Layer.loadImages.
	 * @description Build an object of class Bitmap from a file.
	 */
	function Bitmap( filename, colorkey=clNone);

	/**
	 * Asynchronous read completed
	 *
	 * @param meta This is the tag information of the loaded image.
	 * @param async Whether it was loaded asynchronously. If the image data is in the cache, this event will occur during Bitmap.loadAsync execution.
	 * @param error Whether or not an error occurred when reading the image.
	 * @param message This is an error message. If an error occurs, an error message will be passed.
	 * @description Occurs when asynchronous reading is complete.
	 * The imported image can be copied to the Layer with Layer.copyFromBitmapToMainImage.
	 * Since the reading process is asynchronous, the layer that passes the image may already be disabled when the reading is complete.
	 * If you want to access other objects in this event, please check if they are disabled.
	 * Alternatively, please do not invalidate the target object until this event is completed.
	 * @see Bitmap.loadAsync
	 * @see Layer.copyFromBitmapToMainImage
	 */
	event onLoaded( meta, async, error, message);

	/**
	 * Get pixel value
	 *
	 * @param x Specifies the x-coordinate value to get, in pixels.
	 * @param y Specifies the y coordinate value to get, in pixels.
	 * @return Pixel value
	 * @description Gets the pixel value of the image.
	 * @see Bitmap.setPixel
	 */
	function getPixel( x, y);

	/**
	 * Pixel value setting
	 *
	 * @param x Specifies the x-coordinate value to set in pixels.
	 * @param y Specifies the y coordinate value to set in pixels.
	 * @param value Specify the pixel value to set.
	 * @description Sets the pixel value of the image.
	 * @see Bitmap.getPixel
	 */
	function setPixel( x, y, value);

	/**
	 * Get the alpha value of a pixel
	 *
	 * @param x Specifies the x-coordinate value to get, in pixels.
	 * @param y Specifies the y coordinate value to get, in pixels.
	 * @return Pixel alpha value
	 * @description Gets the alpha value of the pixels in the image.
	 * @see Bitmap.setMaskPixel
	 */
	function getMaskPixel( x, y);

	/**
	 * Get the alpha value of a pixel
	 *
	 * @param x Specifies the x-coordinate value to set in pixels.
	 * @param y Specifies the y coordinate value to set in pixels.
	 * @param value Specifies the alpha value of the pixel to set.
	 * @description Sets the alpha value of the pixels in the image.
	 * @see Bitmap.getMaskPixel
	 */
	function setMaskPixel( x, y, value);

	/**
	 * Unshare images
	 *
	 * @param copy Specifies whether to copy the original image when unsharing. If true is specified, the original image will be copied. If you specify false, the original image is not copied and the image
	 * The content is undefined.
	 * .
	 * @description Forcibly cancels the shared state of the image.
	 * Kirikiri When you copy an entire image with assignImages etc., it will share the same image without actually copying the image buffer.
	 * Normally, this sharing state is automatically released just before you try to make changes to the image, but you can force it to be released with this method.
	 * If you specify false for the copy argument, the image is unshared, but the original image is not guaranteed to be inherited (the content of the image is undefined), but the unsharing is done faster. can do.
	 * When rewriting the entire image, it is not necessary to inherit the original image, so it may be more efficient to call this method with false specified in advance before drawing.
	 * This method does nothing if the image is not shared.
	 */
	function independ( copy=true);

	/**
	 * Image size setting
	 *
	 * @param width Specifies the width of the image in pixels. This value can also be obtained and set with the Bitmap.width property.
	 * @param height Specifies the vertical width of the image in pixels. This value can also be obtained and set with the Bitmap.height property.
	 * @description Specify the image size.
	 */
	function setSize( width, height);

	/**
	 * Copy of image
	 *
	 * @param src Specifies the Bitmap object to copy from.
	 * @description Make a copy of the image.
	 * This method takes almost no execution time because copying is actually just a state where "the same image is shared by two or more objects".
	 */
	function copyFrom( src);

	/**
	 * Save image
	 *
	 * @param name Specify the storage name to save.
	 * @param type Specify the image format to save as a character string.
	 * The following formats can be specified in the current version.
	 * Her BMP of "bmp" or "bmp32" 32bpp. It also saves the alpha channel (mask).
	 * "bmp24" 24bpp BMP. The alpha channel (mask) is not saved.
	 * "bmp8" 8bpp BMP. The alpha channel (mask) is not saved. The image is reduced in color using 4x4 organized dithering with a fixed palette of 252 colors.
	 * "jpg" JPEG. The alpha channel (mask) is not saved. Images are saved with 90% quality.
	 * "jpg ###" JPEG. The alpha channel (mask) is not saved. The image will be saved with the quality specified by ###. "jpg010" is 10%, "jpg100" is 100%, and "jpg080" is 80%.
	 * "png" 32bpp PNG. It also saves the alpha channel (mask).
	 * "png24" 24bpp PNG. The alpha channel (mask) is not saved.
	 * "tlg5" 32bpp TLG5. It also saves the alpha channel (mask).
	 * "tlg524" 24bpp TLG5. The alpha channel (mask) is not saved.
	 * "tlg6" 32bpp TLG6. It also saves the alpha channel (mask).
	 * "tlg624" 24bpp TLG6. The alpha channel (mask) is not saved.
	 * @param meta For TLG format, specify the tag information to be saved in dictionary format. For other formats, specify additional options (1.3.0 or later). The options that can be specified can be obtained with getSaveOption.
	 * @description Saves the file in the storage (file) specified by name in the image format specified by type.
	 * @see Bitmap.getSaveOption
	 */
	function save( name, type="bmp", meta=null);

	/**
	 * Image loading
	 *
	 * @param image Specify the image storage to read.
	 * @param colorkey Specify the color key (transparent color) of the image to be imported.
	 * If you specify a color in the 0xRRGGBB format, that color is used as the color key.
	 * If you specify clPalIdx plus an arbitrary palette index, the palette index becomes transparent (for images of 256 colors or less).
	 * If you specify clAdapt, the most used color in the top line of the image is automatically made transparent.
	 * If you specify clAlphaMat plus a number that represents a color in the 0xRRGGBB format, the image is overlaid on top of that color using an alpha blend (ltAlpha method).
	 * For example, (clAlphaMat + 0xffffff) will overlay the imported image on top of the white color.
	 * All images will be opaque (note that all images will be opaque, but no tag information will be changed in this mode).
	 * @return Dictionary array of tag information
	 * @description Load the image. As a return value, a dictionary array of tag information (information about the image itself, such as the layer type and display position of the image) is returned. If the image has no tag information, null will be returned. In the current version, tag information can only be in PNG, TLG5 / 6 format. See Image Format Converter for the information available.
	 */
	function load( image, colorkey=clNone);

	/**
	 * Asynchronous loading of images
	 *
	 * @param image Specify the image storage to read.
	 * Please note that the file name specified here will include the extension.
	 * If there is no extension, the file cannot be found and an error will occur.
	 * @description Load images asynchronously.
	 * You can receive the completion of loading at Bitmap.onLoaded.
	 * You can check whether it is being read asynchronously with Bitmap.loading.
	 * During asynchronous loading, an exception will be thrown if you access a member other than Bitmap.loading.
	 * Also check the description of Bitmap.onLoaded.
	 * @see Bitmap.onLoaded
	 * @see Bitmap.loading
	 * @see Layer.copyFromBitmapToMainImage
	 */
	function loadAsync( image);

	/**
	 * Reading image information (1.3.0 or later)
	 *
	 * @param image Specify the image storage to read.
	 * Please note that the file name specified here will include the extension.
	 * If there is no extension, the file cannot be found and an error will occur.
	 * @return Dictionary array of information
	 * @description Reads only image information.
	 * Since the image is not read, it can be read at high speed when you want to get only the information.
	 * The width and height of the returned dictionary are mandatory, and other information depends on the image format.
	 */
	function loadHeader( image);

	/**
	 * Image save Additional information acquisition (1.3.0 or later)
	 *
	 * @param type Specify the image format. The specification method is the same format as the save method.
	 * @return Dictionary array of additional information
	 * @description Gets additional information that can be specified when saving an image.
	 * @see Bitmap.save
	 */
	function getSaveOption( type);

	/**
	 * Image width
	 *
	 * @description Specifies the width of the image in pixels.
	 * You can also set the value.
	 * @see Bitmap.setSize
	 */
	 property width {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Image height
	 *
	 * @description Specifies the vertical width of the image in pixels.
	 * You can also set the value.
	 * @see Bitmap.setSize
	 */
	 property height {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Image buffer pointer
	 *
	 * @description Represents a pointer to the upper left corner of the image buffer for an image (a 32bpp bitmap containing color and mask (opacity) information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * It is returned as an integer type, but for plugins etc., cast it to an appropriate type (const unsigned long * etc.) and use it.
	 * Do not write a value to the pointer obtained by this property.
	 * Any pointer obtained by Bitmap.bufferForWrite can be written.
	 * The size of the image is represented by the Bitmap.width and Bitmap.height properties.
	 * See Bitmap.bufferPitch for how to calculate pointers.
	 * @see Bitmap.bufferForWrite
	 * @see Bitmap.bufferPitch
	 */
	 property buffer {
		 getter() { return value; }
	}
	/**
	 * Image buffer pointer (for writing)
	 *
	 * @description Represents a pointer to the upper left corner of the image buffer for an image (a 32bpp bitmap containing color and mask (opacity) information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * It is returned as an integer type, but for plugins etc., cast it to an appropriate type (unsigned long * etc.) and use it.
	 * Unlike Bitmap.buffer, you can write a value to the pointer obtained by this property.
	 * Inside Kirikiri, the exact same image is shared among multiple objects, but if you refer to this property, the shared state will be canceled.
	 * The size of the image is represented by the Bitmap.width and Bitmap.height properties.
	 * See Bitmap.bufferPitch for how to calculate pointers.
	 * @see Bitmap.buffer
	 * @see Bitmap.bufferPitch
	 */
	 property bufferForWrite {
		 getter() { return value; }
	}
	/**
	 * Image buffer pitch
	 *
	 * @description Represents the pitch (in bytes down to the next scanline) of the image buffer of an image (a 32-bpp bitmap containing color and mask (opacity) information).
	 * This property is there to provide a means of direct access to the image buffer for plugins etc.
	 * Assuming that tjs_uint32 is a 32-bit integer type and tjs_uint8 is an 8-bit (1byte) integer type, the pointer to the image position (x, y) can be calculated as follows when written in C language.
	 * ((tjs_uint32 *) ((tjs_uint8 *) buffer + y * bufferPitch)) + x
	 * Note that this property returns the number of bytes, not the number of pixels until the next scanline.
	 * This number may be slightly larger than the exact number of bytes required for the width of the image.
	 * Note that this property can have a negative value.
	 * @see Bitmap.buffer
	 * @see Bitmap.bufferForWrite
	 */
	 property bufferPitch {
		 getter() { return value; }
	}
	/**
	 * Confirmation during asynchronous reading
	 *
	 * @description Indicates whether asynchronous reading is in progress.
	 * When this value is true, asynchronous reading is in progress.
	 * Note that an exception will be thrown if you access another member during asynchronous read.
	 * @see Bitmap.buffer
	 * @see Bitmap.bufferPitch
	 */
	 property loading {
		 getter() { return value; }
	}
};
