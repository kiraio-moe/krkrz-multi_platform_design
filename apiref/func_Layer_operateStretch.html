<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="api.css" type="text/css" rel="stylesheet" title="APIStandard style for reference" />
<title>operateStretch - Enlargement / reduction operation composition</title>
</head>
<body>
<h1><span class="fheader"><a name="top" id="top">Layer.operateStretch</a></span></h1><div class="para">
<dl>
<dt>Function/Meaning</dt>
<dd><p>Enlargement / reduction operation composition</p>
</dd>
<dt>Type</dt>
<dd><a class="jump" href="class_Layer.html">Layerclass</a>method of</dd>
<dt>Syntax</dt>
<dd><span class="funcdecl">operateStretch(<span class="arg">dleft</span>, <span class="arg">dtop</span>, <span class="arg">dwidth</span>, <span class="arg">dheight</span>, <span class="arg">src</span>, <span class="arg">sleft</span>, <span class="arg">stop</span>, <span class="arg">swidth</span>, <span class="arg">sheight</span>, <span class="arg">mode</span><span class="defarg">=<span class="defargval">omAuto</span></span>, <span class="arg">opa</span><span class="defarg">=<span class="defargval">255</span></span>, <span class="arg">type</span><span class="defarg">=<span class="defargval">stNearest</span></span>, <span class="arg">option</span><span class="defarg">=<span class="defargval">1</span></span>)</span></dd>
<dt>Arguments</dt>
<dd><table rules="all" frame="box" cellpadding="3" summary="operateStretchArguments of">
<tr><td valign="top"><span class="argname">dleft</span></td>
<td><p>Specifies the left edge position of the overlay destination rectangle in pixels (at the image position of the overlay destination layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">dtop</span></td>
<td><p>Specifies the top position of the overlay rectangle in pixels (at the image position of the overlay layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">dwidth</span></td>
<td><p>Specifies the width of the overlay rectangle in pixels (at the image position of the overlay layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">dheight</span></td>
<td><p>Specifies the vertical width of the overlay destination rectangle in pixels (at the image position of the overlay destination layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">src</span></td>
<td><p>Specifies the layer object to overlay.<br />
You can also specify an object of the Bitmap class.</p>
</td></tr>
<tr><td valign="top"><span class="argname">sleft</span></td>
<td><p>Specifies the left edge position of the overlay rectangle in pixels (at the image position of the overlay source layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">stop</span></td>
<td><p>Specifies the top position of the overlay rectangle in pixels (at the image position of the overlay source layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">swidth</span></td>
<td><p>Specifies the width of the overlay rectangle in pixels (at the image position of the overlay source layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">sheight</span></td>
<td><p>Specifies the vertical width of the overlay rectangle in pixels (at the image position of the overlay source layer).</p>
</td></tr>
<tr><td valign="top"><span class="argname">mode</span></td>
<td><p>Specifies the operation mode.</p>

<ul>
<li>If omAuto is specified, the operation type is automatically determined according to the Layer.type property of the operation source layer.</li>
<li>If omPsNormal is specified, Photoshop compatible alpha compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omPsAdditive is specified, Photoshop compatible dodging (linear) compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omPsSubtractive is specified, Photoshop compatible burn-in (linear) compositing is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsMultiplicative is specified, Photoshop compatible multiplication composition is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsScreen is specified, Photoshop compatible screen composition will be performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsOverlay is specified, Photoshop compatible overlay compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omPsHardLight is specified, Photoshop compatible hard light composition will be performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsSoftLight is specified, Photoshop compatible soft light composition will be performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsColorDodge is specified, Photoshop compatible dodge color composition is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsColorDodge5 is specified, dodge color composition compatible with Photoshop version 5.x and below will be performed (implemented outside of stNearest and stFastLinear).</li>
<li>If somPsColorBurn is specified, Photoshop compatible burn-in color composition is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsLighten is specified, Photoshop compatible comparison (bright) compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omPsDarken is specified, Photoshop compatible comparison (dark) compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omPsDifference is specified, Photoshop compatible absolute difference composition is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omPsDifference5 is specified, absolute value composition of the difference compatible with Photoshop version 5.x and below is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omPsExclusion is specified, Photoshop compatible exclusion composition is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omAdditive is specified, additive synthesis is performed (implemented outside of stNearest and stFastLinear).</li>
<li>If omSubtractive is specified, subtractive synthesis will be performed (implemented outside of stNearest and stFastLinear).</li>
<li>If omMultiplicative is specified, multiplication composition is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omDodge is specified, dodging compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omDarken is specified, comparison (dark) compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omLighten is specified, comparison (bright) compositing is done (implemented outside of stNearest and stFastLinear).</li>
<li>If omScreen is specified, screen multiplication composition is performed (implemented other than stNearest and stFastLinear).</li>
<li>If omAlpha is specified, alpha synthesis will occur.</li>
<li>If omAddAlpha is specified, additive alpha composition is done. In this case, when the destination Layer.face property is dfOpaque and the Layer.holdAlpha property is false, linear interpolation is possible by specifying stFastLinear in the type argument.</li>
<li>If omOpaque is specified, the alpha information in src is ignored and src is always considered completely opaque. In this case, when the destination Layer.face property is dfOpaque and the Layer.holdAlpha property is false, linear interpolation is possible by specifying stFastLinear in the type argument.</li>
</ul>
</td></tr>
<tr><td valign="top"><span class="argname">opa</span></td>
<td><p>Specifies the intensity of the operation (0 to 255).</p>
</td></tr>
<tr><td valign="top"><span class="argname">type</span></td>
<td><p>Specifies the scale type.</p>

<ul>
<li>stNearest           : Nearest point method is used</li>
<li>stFastLinear        : Low precision linear interpolation is used (partially implemented)</li>
<li>stSemiFastLinear    : Fixed decimal linear interpolation is used (1.3+)</li>
<li>stLinear            : Linear interpolation is used (implementation changed after 1.3)</li>
<li>stFastCubic         : Fixed decimal 3D interpolation is used (1.3 or later)</li>
<li>stCubic             : 3D interpolation is used (implementation changed after 1.3)</li>
<li>stFastLanczos2      : Fixed decimal Lanczos interpolation range 4x4 is used (1.3+)</li>
<li>stLanczos2          : Lanczos interpolation range 4x4 is used (1.3 and above)</li>
<li>stFastLanczos3      : Fixed decimal Lanczos interpolation range 6x6 is used (1.3 and above)</li>
<li>stLanczos3          : Lanczos interpolation range 6x6 is used (1.3 and above)</li>
<li>stFastSpline16      : Fixed decimal spline interpolation 4x4 is used (1.3+)</li>
<li>stSpline16          : Spline interpolation 4x4 is used (1.3+)</li>
<li>stFastSpline36      : Fixed decimal spline interpolation 6x6 is used (1.3+)</li>
<li>stSpline36          : Spline interpolation 6x6 is used (1.3+)</li>
<li>stFastAreaAvg       : Fixed decimal area mean reduction is used. Cannot be expanded (1.3 or later)</li>
<li>stAreaAvg           : Area average reduction is used. Cannot be expanded (1.3 or later)</li>
<li>stFastGaussian      : Fixed decimal Gaussian interpolation 4x4 is used (1.3+)</li>
<li>stGaussian          : Gaussian interpolation 4x4 is used (1.3 or later)</li>
<li>stFastBlackmanSinc  : Fixed decimal Blackman-Sinc interpolation 8x8 is used (1.3+)</li>
<li>stBlackmanSinc      : Blackman-Sinc interpolation 8x8 is used (1.3+)</li>
</ul>

<p>The speed is faster in the order of stNearest> stFastLinear> stLinear> stCubic, but the faster the speed, the lower the image quality.<br />
The interpolation method after stCubic has sufficiently high image quality and can be said to be a difference in taste.<br />
However, the image quality will be blurry for Gaussian interpolation. The difference between stFastLinear and other linear interpolations (stSemiFastLinear and stLinear) is large when shrinking.<br />
While stFastLinear always refers to the surrounding 4 pixels, stSemiFastLinear and stLinear refer to and interpolate a range in which the influence range at 1x magnification is 4 pixels at the time of reduction, that is, a wider range of pixels. Higher image quality (algorithm is the original linear interpolation).<br />
For stFastLinear, stRefNoClip can be additionally specified by bitwise OR, in which case it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize the color.<br />
If this is not specified, the out-of-range color will not refer to the closest pixel in the range, even if there is room around the source bitmap. It is considered a color).</p>
</td></tr>
<tr><td valign="top"><span class="argname">option</span></td>
<td><p>Sharpness during 3D interpolation.<br />
It currently has no meaning with other interpolation methods.<br />
Increasing the sharpness value in the positive direction will make it blurry, and increasing it in the negative direction will make it sharper.</p>
</td></tr>
</table></dd>
<dt>Return value</dt>
<dd>None (void)</dd>
<dt>Explanation</dt>
<dd><p>Computes the rectangle of the specified overlay source layer to the rectangle of the overlay destination (layer that executes the method).<br />
If the size of the overlay source rectangle and the overlay destination rectangle are different, enlargement or reduction is performed.<br />
If omAuto is specified for mode, the operation type is automatically determined according to the Layer.type property of the operation source layer.</p>
</dd>
</dl>
</div>
</body>
</html>
