/**
 * @description The System class is a class for acquiring and setting information about KiriKiri itself and the environment in which KiriKiri is running.
 * You cannot create objects from this class.
 */
class System {
	/**
	 * Asynchronous termination of Kirikiri
	 *
	 * @param code Specifies the exit code of the process
	 * @description Kirikiri is finished.
	 * Calling this method does not immediately terminate KiriKiri.
	 * It ends when control returns from all event handlers to Kirikiri.
	 */
	function terminate( code=0);

	/**
	 * Kirikiri's synchronization ends
	 *
	 * @param code Specifies the exit code of the process
	 * @description Kirikiri is finished.
	 * This method, unlike System.terminate, terminates when called.
	 * Therefore, this method never returns.
	 */
	function exit( code=0);

	/**
	 * Add Continuous Handler
	 *
	 * @param callback Specify the function to be the handler.
	 * @description Register a Continuous Handler.
	 * Continuous handlers are event handlers that are called "as often as possible".
	 * If there is nothing else to do, Kirikiri keeps calling her Continuous Handler.
	 * If another event occurs, that will be given priority.
	 * However, if the command line option -contfreq specifies the frequency of calls, it follows.
	 */
	function addContinuousHandler( callback);

	/**
	 * Delete Continuous Handler
	 *
	 * @param callback Specify the hand function.
	 * @description Delete the Continuous handler.
	 */
	function removeContinuousHandler( callback);

	/**
	 * Display message
	 *
	 * @param text Specify the message to display.
	 * @param caption Specifies the string that will be the caption for the window.
	 * @description Displays a window to show the message to the user.
	 * Windows are displayed modally (that is, no other window can be manipulated while they are displayed).
	 * It appears as a toast on Android and returns immediate control.
	 * Also, caption has no meaning.
	 */
	function inform( text, caption="");

	/**
	 * Get tick count
	 *
	 * @return The tick count (64-bit integer) is returned.
	 * @description The tick count is a number that counts up every 1/1000 second.
	 * You can use this method to get the tick count at two time points and take the difference to know the time difference between the two time points.
	 */
	function getTickCount( );

	/**
	 * [Windows *] Get key status
	 *
	 * @param code Specifies the virtual keycode for which you want to get the state.
	 * @return True if the key is pressed, false if not pressed.
	 * @description Gets whether the key corresponding to the key code specified by code is pressed when this method is called.
	 * For Android, false is always returned.
	 */
	function getKeyState( code);

	/**
	 * [Windows *] Run files / programs
	 *
	 * @param target Specify the file or software to execute.
	 * If a file is specified, the program associated with it will be launched.
	 * @param param Specifies the parameters to pass to the software to run.
	 * If you specify a file in the target argument, omit this argument or specify an empty string.
	 * @return If the execution succeeds, it returns true, and if it fails, it returns false.
	 * @description Executes the file or software specified by target.
	 * Nothing happens on Android.
	 */
	function shellExecute( target, param="");

	/**
	 * [Windows +] Loading the registry
	 *
	 * @param key Specifies the registry key to load.
	 * @return If the execution succeeds, the registry value is returned, and if it fails, void is returned.
	 * @description Reads the Windows registry specified by key.
	 * The registry key can start with the following root key name:
	 * HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSHKEY_PERFORMANCE_DATA HKEY_DYN_DATA
	 * For example, you can specify the following string for key.
	 * HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows \ CurrentVersion \ Uninstall \ hoeg \ installdir
	 * Only numbers and single strings can be read.
	 * If it is a number, it returns an integer type result, and if it is a character string, it returns a character string type result.
	 */
	function readRegValue( key);

	/**
	 * Get command line options
	 *
	 * @param name Specify the command line option name to get.
	 * Add a'-'(hyphen) first (eg'-nosplash').
	 * @return If a command line option is specified, its value is returned, otherwise void is returned.
	 * @description Command line options must be passed to Kirikiri in the form -name = value or -name.
	 * In the former case, value is returned as the value, and in the former case,'yes' is returned as the value.
	 * @see System.setArgument
	 */
	function getArgument( name);

	/**
	 * Setting command line options
	 *
	 * @param name Specify the command line option name to be set. Start with a'-' (hyphen) (eg'-contfreq').
	 * @param value Specify the value to be set. (Example: '60').
	 * @description Dynamically set command line options.
	 * Not all command line options are configurable.
	 * See Command Line Options for configurable command line options.
	 * Do not change options that are not marked as dynamically changeable here.
	 * This method does not check whether the option can be changed dynamically, the existence of the option, the validity of the value, etc.
	 * Be careful when setting the value.
	 * @see System.getArgument
	 */
	function setArgument( name, value );

	/**
	 * Getting the actual color of a color constant
	 *
	 * @param color Specify a color constant (see List of Color Constants).
	 * If you specify a color in the normal 0xRRGGBB format, the value is returned as is.
	 * @return Returns the actual color represented by the specified color constant in 0xRRGGBB format.
	 * @description Converts a color constant to the actual color and returns it in 0xRRGGBB format.
	 */
	function toActualColor( color );

	/**
	 * [Windows +] Double boot check
	 *
	 * @param key Specify the key string to perform the check. If the same key string was specified for this method by another running Kirikiri, false is returned.
	 * Consider that you can basically use only the same characters in the key string as the TJS variable naming convention.
	 * The key string must be unique enough.
	 * @return If Kirikiri, which already has the same key string, is running, false is returned, otherwise true is returned.
	 * @description If another Kirikiri with the same key string is running, false is returned, otherwise true is returned.
	 * It is used to prevent double startup.
	 */
	function createAppLock( key );

	/**
	 * UUID string generation
	 *
	 * @return The generated UUID string is returned in the format "e8b2a2b5-5ceb-4f75-a08b-1f1bdfdca4f1" (each alphanumeric character except hyphen is a hexadecimal digit).
	 * @description Generates and returns a UUID string. This method generates a 128-bit UUID (universal unique identifier) generated based on a random bit string.
	 * The UUID generation algorithm implemented in Kirikiri picks up environmental noise to some extent and generates a random bit string, but it is not recommended to use it for applications that require a high degree of security.
	 * However, it is considered "very very likely not to overlap" with his other UUIDs.
	 */
	function createUUID();

	/**
	 * Change message assignment
	 *
	 * @param id Specifies the message ID to assign.
	 * @param msg Specifies the message to assign to the ID specified by id.
	 * @return Returns true if the ID exists and the message assignment is successful, false otherwise.
	 * @description Change the message assignment. Kirikiri You can change the built-in message to another message with this method.
	 * Usually, it is described in the message map file (see How to start).
	 * To get a list of configurable IDs and the messages currently assigned to them, run "Create Message Map File".
	 */
	function assignMessage( id, msg);

	/**
	 * Compact memory
	 *
	 * @param level Specify the level. Specifying clIdle does the same thing as compactification, which occurs when the system is idle (the system is relatively inactive).
	 * The current version features his TJS2 garbage collection.
	 *
	 * + If you specify clDeactivate, it does the same compactification that occurs when Kirikiri becomes inactive (when other applications become active). The current version clears the temporary image buffer for layer operations, the layer cache, the XP3 archive segment (storage fragment) cache, and the automatic search path cache.
	 * + If you specify clMinimize, it does the same compactification that occurs when Kirikiri is minimized. In the current version, the drawing character cache and image cache are cleared.
	 * + If clAll is specified, all of the above compactifications will be performed.
	 *
	 * The level of compactification increases in the order of clIdle <clDeactivate <clMinimize <clAll.
	 * Specifying a higher level also results in the compactification that is done at the lower levels.
	 * For example, running clDeactivate also does what clIdle does.
	 * If the argument is omitted, clAll is assumed to be specified.
	 * @description Makes the memory compact.
	 * Compactification is the process of reducing memory usage by releasing unused memory and memory for various caches.
	 * Kirikiri does this automatically, so you don't usually have to worry too much, but you can use this method if you want to force it to be done on the program side.
	 */
	function doCompact( level=clAll);

	/**
	 * Loading images into cache
	 *
	 * @param storages Pass the image storage name you want to cache as an array (Object of Array class).
	 * The one written earlier has priority.
	 * Kirikiri manages the cache using the character string specified in the first argument of Layer.loadImages as a key, so to make the cache meaningful, the image storage name specified here is Layer.loadImages. Must be the same as the one specified in the first argument of.
	 * @param limitbytes Specifies the cache capacity limit to use in calling this method, in bytes.
	 * Specify 0 to use all cache. If you specify a positive number, it will try to use the cache up to that number of bytes.
	 * If you specify a negative number, the current cache limit (System.graphicCacheLimit) plus that number (but actually subtracted because it adds a "negative number") is used as the limit.
	 * If the result is a limit of 0 or negative, this method exits without doing anything.
	 * For example, if you specify -2 * 1024 * 1024, he is considered to have specified the current cache limit minus 2MB.
	 * This is useful if you want to leave some room in the cache.
	 * @param timeout Specifies the timeout (time limit) in ms. If you specify 0, there is no limit.
	 * This method will stop loading subsequent images and return after the time specified by this argument has elapsed.
	 * However, if a timeout occurs while loading an image, it will not return until the image has finished loading.
	 * @description This method attempts to cache the specified image.
	 * However, while this method attempts to cache the image, there is no guarantee that the image will actually be cached.
	 * If the image cache limit is exceeded or a timeout occurs, image loading will be interrupted.
	 * The image specified in the storages argument is more likely to be cached (priority is given) as it is written first.
	 * If the specified image is already in the cache, it just raises the rank of survival in the cache.
	 * This method ignores any errors during image loading.
	 * In the current version, the images that can be cached with this method are usually images that can be loaded by Layer.loadImages and do not specify a color key (images with an alpha channel are fine).
	 * Universal transition rule images and area images will be read, but they will not be valid data as a cache (the read data will be wasted), so do not specify them.
	 * See System.graphicCacheLimit for the number of bytes an image uses in the cache.
	 */
	function touchImages( storages, limitbytes=0, timeout=0);

	/**
	 * Displaying the [Windows +] about dialog
	 *
	 * @description Display the about dialog.
	 */
	function showVersion();

	/**
	 * [Windows +] Heap information dump
	 *
	 * @description Outputs heap information to the console.
	 */
	function dumpHeap();

	/**
	 * Raise null pointer access
	 * @description Please do not call.
	 */
	function nullpo();
	/**
	 * Version string
	 *
	 * @description You can get the version string of Kirikiri itself.
	 * The version string has the following format. 1.0.0.1
	 */
	 property versionString {
		 getter() { return value; }
	}
	/**
	 * Version information string
	 *
	 * @description You can get the version information string of Kirikiri itself.
	 * The version information string is longer than System.versionString and looks like this:
	 * KiriKiri [Kirikiri] Z Execution Core /1.0.0.0 (Compiled on Dec 16 2013 23:15:27) TJS2 / 2.4.28 Copyright (C) 1997-2013 W.Dee and contributors All rights reserved.
	 */
	 property versionInformation {
		 getter() { return value; }
	}
	/**
	 * Whether event delivery is stopped
	 *
	 * @description This is true if the event delivery of Kirikiri is stopped.
	 * You can also set the value.
	 * When the event delivery is stopped, the event on Kirikiri will not occur or will be postponed (behavior depends on the type of event).
	 */
	 property eventDisabled {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Image cache limit
	 *
	 * @description Kirikiri Represents the image cache limit in bytes.
	 * You can also set the value.
	 * If you specify gcsAuto, the value is automatically set according to the amount of memory installed in the machine.
	 * Rule images and area images consume the number of bytes expressed as width x height.
	 * Other images consume the number of bytes represented by width x height x 4.
	 */
	 property graphicCacheLimit {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Platform name
	 *
	 * @description Kiriki Represents the name of the platform on which Kiriki is running.
	 * For Windows, it will be'Win32' when the OS is his 32-bit version and'Win64' when the OS is the 64-bit version.
	 * For Android, it will be Android.
	 */
	 property platformName {
		 getter() { return value; }
	}
	/**
	 * OS name
	 *
	 * @description Kiriki Represents the name of her OS on which Kiriki is running.
	 */
	 property osName {
		 getter() { return value; }
	}
	/**
	 * Kirikiri The path of the folder containing the main body
	 *
	 * @description Kiriki Represents the path where the main body is installed.
	 * The path name is represented by a unified storage name.
	 * On Android it is the folder name of packageCodePath.
	 * @see System.appDataPath
	 * @see System.personalPath
	 * @see System.packageCodePath
	 */
	 property exePath {
		 getter() { return value; }
	}
	/**
	 * My document path
	 *
	 * @description Represents the path of the user's My Documents.
	 * For Windows, the folder represented by Personal in HKEY_CURRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Explorer \ Shell Folders in the registry is returned.
	 * This usually refers to the "My Documents" folder.
	 * If this folder does not exist, it returns the same folder as System.exePath.
	 * @see System.appDataPath
	 * @see System.exePath
	 */
	 property personalPath {
		 getter() { return value; }
	}
	/**
	 * The path of the user's home directory
	 *
	 * @description Represents the path of the user's home directory.
	 * For Windows, the folder represented by AppData in HKEY_CURRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Explorer \ Shell Folders in the registry is returned.
	 * If this folder does not exist, it returns the same folder as System.exePath.
	 * This is typically:
	 * For XP C: \ Documents and Settings \ <username> \ Application Data \ (C: part depends on the environment)
	 * For Vista, 7 and 8 C: \ Users \ <username> \ AppData \ Roaming (C: part depends on the environment) If for some reason his registry key (see above) could not be read Kirikiri Will be the folder (System.exePath) containing the executable files of
	 * Same as filesDir on Android.
	 * @see System.exePath
	 * @see System.personalPath
	 * @see System.filesDir
	 */
	 property appDataPath {
		 getter() { return value; }
	}
	/**
	 * Data storage path
	 *
	 * @description Represents the directory specified by the command line option -datapath.
	 * By default, all logs etc. are output here.
	 * If the user script saves the data, we recommend that you save it here.
	 * ExternalFilesDir is set on Android.
	 * @see System.externalFilesDir
	 */
	 property dataPath {
		 getter() { return value; }
	}
	/**
	 * Kirikiri body pass
	 *
	 * @description Kiriki Indicates the path name to the main body.
	 * The path name is represented by a unified storage name.
	 * Same as packageCodePath on Android.
	 * @see System.packageCodePath
	 */
	 property exeName {
		 getter() { return value; }
	}
	/**
	 * title
	 *
	 * @description The title of the main window is represented by a character string.
	 * You can also set the value.
	 * @see Window.caption
	 * On Android, it is set as the title of Activity, but it is not displayed because it is hidden in the full screen state.
	 */
	 property title {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Screen width
	 *
	 * @description Represents the horizontal size of the screen size (screen resolution) in pixels.
	 * The value is for a display with a main window.
	 * If there is no main window, the primary display is the target.
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property screenWidth {
		 getter() { return value; }
	}
	/**
	 * Screen height
	 *
	 * @description Represents the vertical size of the screen size (screen resolution) in pixels.
	 * The value is for a display with a main window.
	 * If there is no main window, the primary display is the target.
	 * @see System.screenWidth
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property screenHeight {
		 getter() { return value; }
	}
	/**
	 * Desktop left edge position
	 *
	 * @description Represents the left edge position of the desktop (the area where the window can be displayed) in pixels.
	 * The value is for a display with a main window.
	 * If there is no main window, the primary display is the target.
	 * Always 0 on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property desktopLeft {
		 getter() { return value; }
	}
	/**
	 * Desktop top position
	 *
	 * @description Represents the top edge of the desktop (the area in which the window can be displayed) in pixels.
	 * The value is for a display with a main window.
	 * If there is no main window, the primary display is the target.
	 * Always 0 on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property desktopTop {
		 getter() { return value; }
	}
	/**
	 * Desktop width
	 *
	 * @description Represents the width of the desktop (the area in which the window can be displayed) in pixels.
	 * The value is for a display with a main window.
	 * If there is no main window, the primary display is the target.
	 * Screen width on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopHeight
	 */
	 property desktopWidth {
		 getter() { return value; }
	}
	/**
	 * Desktop height
	 *
	 * @description Represents the height of the desktop (the area in which the window can be displayed) in pixels.
	 * The value is for a display with a main window.
	 * If there is no main window, the primary display is the target.
	 * Screen width height on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 */
	 property desktopHeight {
		 getter() { return value; }
	}
	/**
	 * [Windows] Whether to exit when the main window is closed
	 *
	 * @description Indicates whether to exit when the main window (the first instance of the Window class created) is closed.
	 * You can also set the value.
	 * The default is true.
	 * Please note that if the main window is closed and no other debug related windows are displayed, KiriKiri will remain on the system without terminating and may get out of control (only terminating the process from the task manager). It may disappear).
	 * .
	 */
	 property exitOnWindowClose {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Handler function for uncaught exception
	 *
	 * @description Represents a function that handles uncaught exceptions (exceptions passed to Kirikiri itself without being caught anywhere).
	 * Specifying null is the default behavior.
	 * The default behavior is to stop the delivery of asynchronous events (set System.eventDisabled to true) and start outputting logs to a file (call Debug.logAsError) to display a dialog box informing you of the error and in the script editor. It shows the place.
	 * The handler function takes one argument, which becomes the exception object.
	 * If no handler function is specified, the handler function is null, or the handler function returns false, the default behavior is taken.
	 * If the handler function returns true, the above default behavior will not occur.
	 * Consider the possibility of an asynchronous event occurring while executing a handler function.
	 * If Kirikiri itself can handle asynchronous events, an unexpected exception may occur again while executing the exception handler.
	 * To avoid this, normally, if you want to wait for something in the handler function (when Kirikiri has a chance to handle the asynchronous event), stop the occurrence of the asynchronous event.
	 * Example:
	 *
	 * ```
	 * System.exceptionHandler = function (e){
	 *    // This function is called when an exception that is not caught anywhere is caught on the system side. e is an exception object.
	 *    if(e instanceof "ConductorException"){
	 *        // In the case of a conductor thrown exception
	 *        Debug.logAsError();
	 *        // Start of writing log to file, etc.
	 *        var event_disabled = System.eventDisabled;System.eventDisabled = true;
	 *        // It is troublesome if an event occurs while displaying the reason for the error, so stop the event occurrence once
	 *        System.inform(e.message);
	 *        System.eventDisabled = event_disabled;
	 *        // Whether to raise an event or not to the original state
	 *        return true;
	 *        // If true is returned, exception handling will not be performed on the main unit side.
	 *    }else{
	 *        return false;
	 *        // Normal exception handling if false is returned
	 *    }
	 * };
	 * ```
	 * @see System.eventDisabled
	 * @see Debug.logAsError
	 */
	 property exceptionHandler {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * When the application becomes active
	 *
	 * @description Represents an event function that is called when the application becomes active.
	 * If null is specified, the function will not be called.
	 * Unlike regular event handlers, if you want to receive this event, set this property to the function you want to call.
	 * Window.onActivate is fired when each window in the same application is activated, but this event is fired when the main window is activated.
	 * Note that this event can also occur if the main window is already active (there is no guarantee that it will occur completely onActivate → onDeactivate → onActivate → ……).
	 * @see System.onDeactivate
	 * @see Window.onActivate
	 * @see Window.onDeactivate
	 */
	 property onActivate {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * When the application becomes inactive
	 *
	 * @description Represents an event function that is called when the application becomes inactive.
	 * If null is specified, the function will not be called.
	 * Unlike regular event handlers, if you want to receive this event, set this property to the function you want to call.
	 * Window.onDeactivate is fired when each window in the same application is deactivated, but this event is fired when the main window is deactivated.
	 * Note that this event can also occur if the main window is already inactive (there is no guarantee that it will occur completely onActivate → onDeactivate → onActivate → ……).
	 * @see System.onActivate
	 * @see Window.onActivate
	 * @see Window.onDeactivate
	 */
	 property onDeactivate {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Number of threads used for drawing
	 *
	 * @description Kiriki Represents the number of threads used by Kiriki's layer system when drawing.
	 * You can also set the value.
	 * If you specify dtnAuto, the same number of threads as the OS recognizes is automatically allocated.
	 * Setting multiple drawing threads may improve drawing performance in a multi-core environment, but it may also reduce performance.
	 * Good results may be obtained by applying it to processing with a large drawing area, high-load processing of Affine series, and layer composition processing with heavy calculation.
	 * Even if you set to use multithreading, if the system determines that the drawing process load is light and the effect of multithreading cannot be obtained, it may not be executed in multithreading.
	 */
	 property drawThreadNum {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Saved game path (1.1.0 or later)
	 *
	 * @description Represents the saved game path.
	 * This is typically:
	 * C: \ Users \ <username> \ Saved Games
	 */
	 property savedGamesPath {
		 getter() { return value; }
	}
	/**
	 * Kirikiri Whether the main body is his 32-bit version or 64-bit version (1.3.0 or later)
	 *
	 * @description The integer 32 or 64 indicates whether the executable binary is his 32-bit or 64-bit version.
	 * @see System.osBits
	 * @see System.platformName
	 */
	 property exeBits {
		 getter() { return value; }
	}
	/**
	 * Whether the OS is his 32-bit version or 64-bit version (1.3.0 or later)
	 *
	 * @description The 32 or 64 integer indicates whether the OS is a 32-bit version or a 64-bit version.
	 * @see System.exeBits
	 * @see System.platformName
	 */
	 property osBits {
		 getter() { return value; }
	}
	/**
	 * Determine if the system is Windows [r]
	 */
	property isWindows;

	/**
	 * Determine if the system is Android [r]
	 */
	property isAndroid;

	/**
	 * [Android +] External cache area path [r]
	 * @description What is obtained by Context.getExternalCacheDir ().
	 */
	property externalCacheDir;
	/**
	 * [Android +] Internal cache area [r]
	 * @description What is obtained by Context.getCacheDir ().
	 */
	property cacheDir;
	/**
	 * [Android +] Internal data area [r]
	 * @description What is obtained by Context.getFilesDir ().
	 */
	property filesDir;
	/**
	 * [Android +] External data area [r]
	 * @description What is obtained by Context.getExternalFilesDir ().
	 */
	property externalFilesDir;
	/**
	 * [Android +] Extended file (OBB format) storage area [r]
	 * @description What is obtained by Context.getObbDir ().
	 */
	property obbDir;
	/**
	 * [Android +] Shared Object (* .so) file storage area of the application [r]
	 */
	property sharedObjectPath;
	/**
	 * [Android +] App package name [r]
	 */
	property packageName;
	/**
	 * [Android +] App package code path [r]
	 */
	property packageCodePath;
	/**
	 * [Android +] App package resource path [r]
	 */
	property packageResourcePath;
	/**
	 * [Android +] Data area [r]
	 * @description What is obtained by Environment.getDataDirectory ().
	 */
	property dataDirectory;
	/**
	 * [Android +] Download cache path [r]
	 * @description What is obtained by Environment.getDownloadCacheDirectory ().
	 */
	property downloadCacheDirectory;
	/**
	 * [Android +] External shared area [r]
	 * @description What is obtained by Environment.getExternalStorageDirectory ().
	 */
	property externalStorageDirectory;
	/**
	 * [Android +] Music data path [r]
	 * @description What is obtained from Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_MUSIC).
	 */
	property externalPublicMusicPath;
	/**
	 * [Android +] Podcast Data Path [r]
	 * @description What you get from Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_PODCASTS).
	 */
	property externalPublicPodcastsPath;
	/**
	 * [Android +] Ring data path [r]
	 * @description What is obtained from Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_RINGTONES).
	 */
	property externalPublicRingtonesPath;
	/**
	 * [Android +] Alarm sound data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_ALARMS).
	 */
	property property externalPublicAlaramsPath;
	/**
	 * [Android +] Notification sound data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_NOTIFICATIONS).
	 */
	property externalPublicNotificationsPath;
	/**
	 * [Android +] Photo data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_PICTURES).
	 */
	property externalPublicPicturesPath;
	/**
	 * [Android +] Video data path [r]
	 * @description What is obtained from Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_MOVIES).
	 */
	property externalPublicMoviesPath;
	/**
	 * [Android +] Download path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_DOWNLOADS).
	 */
	property externalPublicDownloadsPath;
	/**
	 * [Android +] DCIM (camera) data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_DCIM).
	 */
	property externalPublicDCIMPath;
	/**
	 * [Android +] Document data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_DOCUMENTS).
	 */
	property externalPublicDocumentsPath;
	/**
	 * [Android +] Root directory [r]
	 * @description What is obtained by Environment.getRootDirectory ().
	 */
	property rootDirectory;
	/**
	 * [Android +] External storage status [r]
	 * @description What is obtained by Environment.getExternalStorageState ().
	 * One of the following
	 *
	 * + "unknown" unknown state
	 * + "removed" removed
	 * + "unmounted" Unmounted
	 * + "checking" Disk checking
	 * + "nofs" unformatted or unsupported filesystem
	 * + "mounted" Mounted and readable and writable
	 * + "mounted_ro" is mounted read-only
	 * + "shared" unmounted, USB mass storage, etc.
	 * + "bad_removal" was removed before being unmounted
	 * + "unmountable" cannot be mounted
	 *
	 */
	property externalStorageState;
	/**
	 * [Android +] Whether it is emulated external storage [r]
	 * @description What is obtained by Environment.isExternalStorageEmulated ().
	 */
	property isExternalStorageEmulated;
	/**
	 * [Android +] Whether external storage is removable [r]
	 * @description What is obtained by Environment.isExternalStorageRemovable ().
	 */
	property isExternalStorageRemovable;

	/**
	 * OpenGL ES version
	 * @description The number obtained by multiplying the actual value by 100, that is, 200 for 2.0 and 300 for 3.0 is returned.
	 */
	property openGLESVersion;
};

