
// Window作ったら自動的に生成されているのがいいか？ drawDevice/fontと同一仕様
// オプションでdrawDevice系かCanvas系か指定できるような(排他指定)
//
// 互換のためCanvasにLTOを問い合わせてなかったら、自動的にデフォルトOffscreenを追加、
// 自動追加されたOffscreenは自動更新がONでLayer更新されたら、その更新をCanvasに通知
// して自動更新がかかるようにする。そうすれば、DrawDevice依存していなければ、そのまま
// のスクリプトで動かすことが可能となる。
class Canvas {
	function Canvas( window? )

    //< クリア色指定・描画処理前の画面クリア色
	property clearColor;

	
	/**
	 * 描画領域全体をクリア
	 * @param argb クリア色(未指定時はclearColorプロパティでクリアされる)
	 */
	function clear(argb);

	/**
	 * 現在の描画内容全体をBitmap/Offscreenにキャプチャ
	 * ビットマップのサイズはスクリーンサイズに補正
	 * Offscreenの場合は変更されず
	 * @param dest キャプチャ先Bitmap/Offscreen
	 * @param front front bufferからのキャプチャかback bufferからのキャプチャかの指定。trueでfront、falseでback
	 *
	 * OpenGLメモ : glCopyTexImage2D でテクスチャへのコピー、glReadPixels でメモリへのコピー。ES3ならMapping機能でもう少し柔軟。
	 */
	function capture(dest,front=true);
	// Offscreenの場合はそれをレンダーターゲットにしてしまった方が良さそうな気がするがどうだろうか？
	// Textureへキャプチャして、Textureとして再利用するのなら、そちらの方が使い勝手良さそうな…
	// left,top,width,heightの指定も可能に出来るが、無用かどうか。あったらあったで使い道ありそうではあるが。

	/**
	 * 描画ターゲットスクリーン指定
	 * @param screen 描画対象となるスクリーンIdを設定する。null で直接描画に戻る
	 */
	//function setTargetScreen(screenId);
	// ---> property の方が良くないかな？
	// Window.drawDevice と同じような扱いで
	// propertyへ canvas.targetScreen で設定


	/**
	 * 描画ターゲット指定
	 * Offscreenクラスを指定可能。null/void指定で直接描画に。
	 */
	property renderTarget;

    /**
	 * スクリーンを描画
	 * クロスフェードトランジション相当描画
	 * @param screenId 描画用スクリーン
	 * @param opacity 不透明度指定(0〜1.0)
	 */
	function drawScreen(screen, opacity);

	/**
	 * スクリーンを描画
	 * ユニバーサルトランジション相当描画
	 * @param screen 描画用スクリーン
	 * @param maskTexture マスク用テクスチャ(grayなものに限る)
	 * @param vague vague値
	 * @param opacity 不透明度指定(0〜1.0)
	 */
	function drawScreenUT(screen, maskTexture, vague, opacity);


	/**
	 * 矩形クリッピングの設定
	 * @param l
	 * @param t
	 * @param w
	 * @param h
	 */
	// function setClip( l, t, w, h );

	/**
	 * アルファクリッピングの設定(setClipとは排他) -> 実装上は clipRect と排他である必要はないので、
	 * @param maskTextureId マスク用テクスチャ(grayなものに限る)
	 * @param l オフセット指定
	 * @param t オフセット指定
	 */
	function setClipMask(maskTexture, l, t);

	/**
	 * クリッピング用矩形のRectクラス
	 * canvas.clipRect.set( l, t, r, b ); 等で呼び出せる。
	 * applyClipRect を呼び出さないとクリッピング矩形は有効化されない。
	 * disableClipRect で無効化。
	 *
	 * setClipRect( l, t, r, b ) の方が扱いやすかったかも……
	 */
	property clipRect;

	/**
	 * 描画の合成モード指定・できれば吉里吉里互換で一式
	 * bmOpaque, bmAlpha, bmAdd, bmAddWithAlpha : まで実装済み。
	 */
	property blendMode;

	/**
	 * 描画のストレッチ指定
	 * OpenGLだとテクスチャに指定するパラメータ
	 * Textureクラスに移動するか？
	 * 補間方法は画像ごとに指定する可能性が高いか？
	 * Nearest と Linear しかないが、Offscreen にはシェーダーで Cubic や Lanczos くらいあった方が良さげ？
	 * とりあえずは Nearest と Linear のみとする
	 *
	 * property stretchType;
	 */


	/**
	 * 描画マトリックス指定
	 */
	//function setMatrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
	//function setMatrix(matrix44);

	property matrix;	// Matrix44 クラス --> setMatrix は canvas.matrix.set(...);で代用できる

	// save/restore で matrix と clip のセーブと復元は欲しいよね。push/pop
	// sprite 作る時も

	// ---------------------------------------------------------------
	// 2D系描画処理

	/**
	 * 単色での塗りつぶし
	 * @param left
	 * @param top
	 * @param width
	 * @param height
	 * @param colors 4頂点の頂点カラーARGB。void/null は未定義(0xffffffff)、単独数値なら単色、配列なら4頂点個別指定
	 */
	function fill(left, top, width, height, colors);

	/**
	 * テクスチャでのメッシュ描画
	 * @param texture テクスチャ番号
	 * @param mesh メッシュ情報(Meshオブジェクトで指定)
	 */
 	function drawMesh(texture, mesh);

	// 追加……(仮？)
	function drawTexture( texture, left, top );


	// シェーダー設定メソッドは OpenGL ES2.0の仕様に起因するものであったが、drawTexture でも shader 指定することになり、二重指定となり煩雑。
	// シェーダークラスのプロパティを保持する形にして内部的に設定する形にすれば、drawTexture で shader 指定すれば済むことになり、そちらの方が
	// 手軽に使えるため、この仕様は変更する。
	/**
	 * シェーダーを設定します。
	 * onDraw 内で描画時に呼び出します。
	 * シェーダークラスのインスタンスを指定して描画を行うメソッドは、シェーダーが既に有効化されているものとして処理します。
	 * 各種プロパティを設定する前に、まずはこのメソッドを呼び出し、必要な値をプロパティに設定した後、Canvasの描画命令を呼び出してください。
	 * @param shader コンパイルしたシェーダーを渡します。
	 */
	/* function setShader( shader:ShaderProgram ); */

	// ---------------------------------------------------------------
	// テキスト描画

// >>>> この辺りはFontクラスが既にあるので、それが使えるのが好ましい。
	/**
	 * フォント生成
	 * @param name フォント名
	 * @return フォントID
	 */
	function createFont(name);
	
	/**
	 * フォント生成
	 * @param fontFile フォントファイル
	 * @return フォントID
	 */
	function createFontFromFile(filename,index=0);//font内には複数格納されている場合もあるので、indexも必要

	/**
	 * フォントの破棄
	 * @param fontID
	 */
	function removeFont(fontId);
// <<<<

	/**
	 * テキスト描画
	 * @param font フォント
	 * @param x X位置
	 * @param y Y位置
	 * @param text テキスト
	 * @param color 色指定
	 */
	function drawText(font, x, y, text, color);

	// Windowの描画領域サイズと同じだが、OpenGLが返すものを取得する、設定は出来ない。
	// Viewport 設定も必要か？
	property width;
	property height;

	// applyMatrix系廃止に伴い、統一するために廃止する予定
	/**
	 * clipRectプロパティの矩形をクリッピング領域として適用します。
	 * プロパティに入れただけではクリッピングはされません。
	 */
	/* function applyClipRect(); */
	/**
	 * 矩形クリッピングを無効化します。
	 */
	/* function disableClipRect(); */

	/**
	 * 上記メソッド廃止に伴い、有効/無効プロパティ追加予定。
	 */
	property enableClipRect;


	// TODO : 以下のメソッドも必要
	// 不要であった。OpenGL ES2.0 の場合は、シェーダーでマトリックス演算前提のため、現在のマトリックスを設定するような処理がない。1.0ではあった。
	// つまり、描画時に毎回シェーダーへマトリックスを設定してやるので、現在設定されているマトリックスが呼び出し時点で設定されることとなる。
	/* function applyMatrix(); */
	/* function applyIdentityMatrix(); */


	// シェーダーは別クラスとし、登録せずにユーザー(TJS2スクリプト)管理と言う形にした。
	// 使う直前にsetShaderを呼び出してシェーダーを設定する。
	/**
	 * Vertex Shader/Fragment Shaderを登録(コンパイル)する。
	 * コンパイルに失敗した場合は例外が出る。エラー詳細はログへ。
	 * シェーダーへ値を渡す辺りはどうするか？ スクリプトでID取得してもらって、それに値設定を細かくやってもらうか？
	 * シェーダーを自由にできると便利だが、各種値の設定が厄介。
	 * @param name 登録名
	 * @param vertex バーティクスシェーダースクリプト
	 * @param gragment フラグメントシェーダースクリプト
	 * @return 登録番号
	 */
	/* function registerShader( name:string, vertex:string, fragment:string ); */
	/**
	 * シェーダー登録を解除する(なくてもいいか？、とりあえずは終了時に自動削除されるようにしておく)
	 */
	/* function unregisterShader( name:string ); */
	/**
	 * 現在のシェーダー番号の設定/取得
	 */
	/* property currentShader; */
};

