
// Window作ったら自動的に生成されているのがいいか？ drawDevice/fontと同一仕様
// オプションでdrawDevice系かCanvas系か指定できるような(排他指定)
//
// 互換のためCanvasにLTOを問い合わせてなかったら、自動的にデフォルトOffscreenを追加、
// 自動追加されたOffscreenは自動更新がONでLayer更新されたら、その更新をCanvasに通知
// して自動更新がかかるようにする。そうすれば、DrawDevice依存していなければ、そのまま
// のスクリプトで動かすことが可能となる。
class Canvas {
	function Canvas( window? )

    //< クリア色指定・描画処理前の画面クリア色
	property clearColor;

	
	/**
	 * 描画領域全体をクリア
	 * @param argb クリア色(未指定時はclearColorプロパティでクリアされる)
	 */
	function clear(argb);

	/**
	 * 現在の描画内容全体をBitmap/Texture/Offscreenにキャプチャ
	 * ビットマップのサイズはスクリーンサイズに補正
	 * Texture/Offscreenの場合は変更されない
	 * @param dest キャプチャ先Bitmap/Texture/Offscreen
	 * @param front front bufferからのキャプチャかback bufferからのキャプチャかの指定。trueでfront、falseでback
	 */
	function capture(dest,front=true);

	/**
	 * 描画ターゲット指定
	 * Offscreenクラスを指定可能。null/void指定で直接描画に。
	 */
	property renderTarget;

	/**
	 * 描画の合成モード指定
	 * bmDisable, bmOpaque, bmAlpha, bmAdd, bmAddWithAlpha が指定可能
	 * ここにないブレンド方法が必要であればシェーダーを記述する。
	 */
	property blendMode;

	/** 描画マトリックス指定(Matrix44 クラス) */
	property matrix;

	// save/restore で matrix と clip のセーブと復元は欲しいよね。push/pop
	// sprite 作る時も

	// ---------------------------------------------------------------
	// 2D系描画処理
	/**
	 * 単色での塗りつぶし
	 * @param left
	 * @param top
	 * @param width
	 * @param height
	 * @param colors 4頂点の頂点カラーARGB。void/null は未定義(0xffffffff)、単独数値なら単色、配列なら4頂点個別指定
	 */
	function fill(left, top, width, height, colors);
	// left, top は省略して、matrix指定の方が統一性が取れるよな……
	// matrix stack 使用するのなら、そっちの方がやりやすいだろうし
	// fill( width, height, colors, shader=null );

	/**
	 * テクスチャでのメッシュ描画
	 * @param texture テクスチャ番号
	 * @param mesh メッシュ情報(Meshオブジェクトで指定)
	 */
 	function drawMesh(texture, mesh);

	/**
	 * テクスチャを描画する。
	 * テクスチャのみを指定した場合はdefaultShaderで描画される。
	 * 位置や拡大縮小、回転は matrix で指定する。
	 * テクスチャはTextureクラスだけでなく、Offscreenクラスを指定しても問題ない。
	 * Offscreenクラスを指定する場合は、renderTargetからそのOffscreenクラスは外されていることが前提(循環しないように)。
	 * @param texture 描画に使用するテクスチャを指定する
	 * @param texture2 描画に使用する2枚目のテクスチャを指定する
	 * @param texture3 描画に使用する3枚目のテクスチャを指定する
	 * @param shader 描画に使用するシェーダーを指定する
	 *
	 * OpenGL ES 2.0の場合はテクスチャ最大8枚、3.0は頂点側最大16枚，フラグメント側最大16枚なので、まだ追加できるが、
	 * とりあえずは3枚まで定義しておく。
	 * 将来的にはテクスチャを配列で渡すバージョンを作り、4枚以上はそちらで対応する。
	 */
	function drawTexture( texture );
	function drawTexture( texture, shader );
	function drawTexture( texture, texture2, shader );
	function drawTexture( texture, texture2, texture3, shader );

	/**
	 * テクスチャの描画に使用されるデフォルトのシェーダー(drawTextureでtexture1枚のみ渡した時のシェーダー)
	 * 設定もできるが、基本的に変更する必要はない
	 */
	property defaultShader;

	/** 描画領域の幅。基本的にはクライアント領域と一致、Windowリサイズから再描画まで一時的にずれる期間あり */
	property width;
	/** 描画領域の高さ */
	property height;

	/**
	 * クリッピング用矩形のRectクラス
	 * canvas.clipRect.set( l, t, r, b ); 等で呼び出せる。
	 * enableClipRect で有効/無効設定可
	 */
	property clipRect;

	/**
	 * 矩形でクリッピングするかどうかの設定
	 * true の時、clipRectプロパティによってクリッピングされる
	 */
	property enableClipRect;


	// ---------------------------------------------------------------
	// テキスト描画
	/**
	 * テキスト描画
	 * @param font フォント
	 * @param x X位置
	 * @param y Y位置
	 * @param text テキスト
	 * @param color 色指定
	 */
	function drawText(font, x, y, text, color);


	// ---------------------------------------------------------------
	// 以下、シェーダーで実現可能なため、メソッドとしての実装は行わない予定
    /**
	 * スクリーンを描画
	 * クロスフェードトランジション相当描画
	 * @param screenId 描画用スクリーン
	 * @param opacity 不透明度指定(0〜1.0)
	 */
	// function drawScreen(screen, opacity);
	// drawTexture に2枚のテクスチャを指定して描画することで代用可能

	/**
	 * スクリーンを描画
	 * ユニバーサルトランジション相当描画
	 * @param screen 描画用スクリーン
	 * @param maskTexture マスク用テクスチャ(grayなものに限る)
	 * @param vague vague値
	 * @param opacity 不透明度指定(0〜1.0)
	 */
	// function drawScreenUT(screen, maskTexture, vague, opacity);
	// drawTexture に3枚のテクスチャを指定して描画することで代用可能

	/**
	 * アルファクリッピングの設定(setClipとは排他) -> 実装上は clipRect と排他である必要はないので、
	 * @param maskTextureId マスク用テクスチャ(grayなものに限る)
	 * @param l オフセット指定
	 * @param t オフセット指定
	 */
	function setClipMask(maskTexture, l, t);
	// drawTextre で通常テクスチャとアルファテクスチャを指定し、シェーダーを書くことで実現可能。
};

